// AUTO GENERATED FILE, DO NOT EDIT.
// 
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;
/// Return the version of the libgit2 library
/// being currently used.
/// 
/// @param major Store the major version number
/// @param minor Store the minor version number
/// @param rev Store the revision (patch) number
/// @return 0 on success or an error code on failure
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Int> , ffi.Pointer<ffi.Int> , ffi.Pointer<ffi.Int> )>()
external int git_libgit2_version(ffi.Pointer<ffi.Int> major,
ffi.Pointer<ffi.Int> minor,
ffi.Pointer<ffi.Int> rev,
);

/// Return the prerelease state of the libgit2 library currently being
/// used.  For nightly builds during active development, this will be
/// "alpha".  Releases may have a "beta" or release candidate ("rc1",
/// "rc2", etc) prerelease.  For a final release, this function returns
/// NULL.
/// 
/// @return the name of the prerelease state or NULL
@ffi.Native<ffi.Pointer<ffi.Char> Function()>()
external ffi.Pointer<ffi.Char> git_libgit2_prerelease();

/// Query compile time options for libgit2.
/// 
/// @return A combination of GIT_FEATURE_* values.
@ffi.Native<ffi.Int Function()>()
external int git_libgit2_features();

/// Query the backend details for the compile-time feature in libgit2.
/// 
/// This will return the "backend" for the feature, which is useful for
/// things like HTTPS or SSH support, that can have multiple backends
/// that could be compiled in.
/// 
/// For example, when libgit2 is compiled with dynamic OpenSSL support,
/// the feature backend will be `openssl-dynamic`. The feature backend
/// names reflect the compilation options specified to the build system
/// (though in all lower case). The backend _may_ be "builtin" for
/// features that are provided by libgit2 itself.
/// 
/// If the feature is not supported by the library, this API returns
/// `NULL`.
/// 
/// @param feature the feature to query details for
/// @return the provider details, or NULL if the feature is not supported
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt )>(symbol: 'git_libgit2_feature_backend')
external ffi.Pointer<ffi.Char> _git_libgit2_feature_backend(int feature,
);

ffi.Pointer<ffi.Char> git_libgit2_feature_backend(git_feature_t feature,
) => _git_libgit2_feature_backend(feature.value,
);

/// Set or query a library global option
/// 
/// Available options:
/// 
/// * opts(GIT_OPT_GET_MWINDOW_SIZE, size_t *):
/// 
/// > Get the maximum mmap window size
/// 
/// * opts(GIT_OPT_SET_MWINDOW_SIZE, size_t):
/// 
/// > Set the maximum mmap window size
/// 
/// * opts(GIT_OPT_GET_MWINDOW_MAPPED_LIMIT, size_t *):
/// 
/// > Get the maximum memory that will be mapped in total by the library
/// 
/// * opts(GIT_OPT_SET_MWINDOW_MAPPED_LIMIT, size_t):
/// 
/// > Set the maximum amount of memory that can be mapped at any time
/// > by the library
/// 
/// * opts(GIT_OPT_GET_MWINDOW_FILE_LIMIT, size_t *):
/// 
/// > Get the maximum number of files that will be mapped at any time by the
/// > library
/// 
/// * opts(GIT_OPT_SET_MWINDOW_FILE_LIMIT, size_t):
/// 
/// > Set the maximum number of files that can be mapped at any time
/// > by the library. The default (0) is unlimited.
/// 
/// * opts(GIT_OPT_GET_SEARCH_PATH, int level, git_buf *buf)
/// 
/// > Get the search path for a given level of config data.  "level" must
/// > be one of `GIT_CONFIG_LEVEL_SYSTEM`, `GIT_CONFIG_LEVEL_GLOBAL`,
/// > `GIT_CONFIG_LEVEL_XDG`, or `GIT_CONFIG_LEVEL_PROGRAMDATA`.
/// > The search path is written to the `out` buffer.
/// 
/// * opts(GIT_OPT_SET_SEARCH_PATH, int level, const char *path)
/// 
/// > Set the search path for a level of config data.  The search path
/// > applied to shared attributes and ignore files, too.
/// >
/// > - `path` lists directories delimited by GIT_PATH_LIST_SEPARATOR.
/// >   Pass NULL to reset to the default (generally based on environment
/// >   variables).  Use magic path `$PATH` to include the old value
/// >   of the path (if you want to prepend or append, for instance).
/// >
/// > - `level` must be `GIT_CONFIG_LEVEL_SYSTEM`,
/// >   `GIT_CONFIG_LEVEL_GLOBAL`, `GIT_CONFIG_LEVEL_XDG`, or
/// >   `GIT_CONFIG_LEVEL_PROGRAMDATA`.
/// 
/// * opts(GIT_OPT_SET_CACHE_OBJECT_LIMIT, git_object_t type, size_t size)
/// 
/// > Set the maximum data size for the given type of object to be
/// > considered eligible for caching in memory.  Setting to value to
/// > zero means that that type of object will not be cached.
/// > Defaults to 0 for GIT_OBJECT_BLOB (i.e. won't cache blobs) and 4k
/// > for GIT_OBJECT_COMMIT, GIT_OBJECT_TREE, and GIT_OBJECT_TAG.
/// 
/// * opts(GIT_OPT_SET_CACHE_MAX_SIZE, ssize_t max_storage_bytes)
/// 
/// > Set the maximum total data size that will be cached in memory
/// > across all repositories before libgit2 starts evicting objects
/// > from the cache.  This is a soft limit, in that the library might
/// > briefly exceed it, but will start aggressively evicting objects
/// > from cache when that happens.  The default cache size is 256MB.
/// 
/// * opts(GIT_OPT_ENABLE_CACHING, int enabled)
/// 
/// > Enable or disable caching completely.
/// >
/// > Because caches are repository-specific, disabling the cache
/// > cannot immediately clear all cached objects, but each cache will
/// > be cleared on the next attempt to update anything in it.
/// 
/// * opts(GIT_OPT_GET_CACHED_MEMORY, ssize_t *current, ssize_t *allowed)
/// 
/// > Get the current bytes in cache and the maximum that would be
/// > allowed in the cache.
/// 
/// * opts(GIT_OPT_GET_TEMPLATE_PATH, git_buf *out)
/// 
/// > Get the default template path.
/// > The path is written to the `out` buffer.
/// 
/// * opts(GIT_OPT_SET_TEMPLATE_PATH, const char *path)
/// 
/// > Set the default template path.
/// >
/// > - `path` directory of template.
/// 
/// * opts(GIT_OPT_SET_SSL_CERT_LOCATIONS, const char *file, const char *path)
/// 
/// > Set the SSL certificate-authority locations.
/// >
/// > - `file` is the location of a file containing several
/// >   certificates concatenated together.
/// > - `path` is the location of a directory holding several
/// >   certificates, one per file.
/// >
/// > Calling `GIT_OPT_ADD_SSL_X509_CERT` may override the
/// > data in `path`.
/// >
/// > Either parameter may be `NULL`, but not both.
/// 
/// * opts(GIT_OPT_ADD_SSL_X509_CERT, const X509 *cert)
/// 
/// > Add a raw X509 certificate into the SSL certs store.
/// > This certificate is only used by libgit2 invocations
/// > during the application lifetime and is not persisted
/// > to disk. This certificate cannot be removed from the
/// > application once is has been added.
/// >
/// > - `cert` is the raw X509 cert will be added to cert store.
/// 
/// * opts(GIT_OPT_SET_USER_AGENT, const char *user_agent)
/// 
/// > Set the value of the comment section of the User-Agent header.
/// > This can be information about your product and its version.
/// > By default this is "libgit2" followed by the libgit2 version.
/// >
/// > This value will be appended to User-Agent _product_, which
/// > is typically set to "git/2.0".
/// >
/// > Set to the empty string ("") to not send any information in the
/// > comment section, or set to NULL to restore the default.
/// 
/// * opts(GIT_OPT_GET_USER_AGENT, git_buf *out)
/// 
/// > Get the value of the User-Agent header.
/// > The User-Agent is written to the `out` buffer.
/// 
/// * opts(GIT_OPT_SET_USER_AGENT_PRODUCT, const char *user_agent_product)
/// 
/// > Set the value of the product portion of the User-Agent header.
/// > This defaults to "git/2.0", for compatibility with other git
/// > clients. It is recommended to keep this as git/<version> for
/// > compatibility with servers that do user-agent detection.
/// >
/// > Set to the empty string ("") to not send any user-agent string,
/// > or set to NULL to restore the default.
/// 
/// * opts(GIT_OPT_GET_USER_AGENT_PRODUCT, git_buf *out)
/// 
/// > Get the value of the User-Agent product header.
/// > The User-Agent product is written to the `out` buffer.
/// 
/// * opts(GIT_OPT_SET_WINDOWS_SHAREMODE, unsigned long value)
/// 
/// > Set the share mode used when opening files on Windows.
/// > For more information, see the documentation for CreateFile.
/// > The default is: FILE_SHARE_READ | FILE_SHARE_WRITE.  This is
/// > ignored and unused on non-Windows platforms.
/// 
/// * opts(GIT_OPT_GET_WINDOWS_SHAREMODE, unsigned long *value)
/// 
/// > Get the share mode used when opening files on Windows.
/// 
/// * opts(GIT_OPT_ENABLE_STRICT_OBJECT_CREATION, int enabled)
/// 
/// > Enable strict input validation when creating new objects
/// > to ensure that all inputs to the new objects are valid.  For
/// > example, when this is enabled, the parent(s) and tree inputs
/// > will be validated when creating a new commit.  This defaults
/// > to enabled.
/// 
/// * opts(GIT_OPT_ENABLE_STRICT_SYMBOLIC_REF_CREATION, int enabled)
/// 
/// > Validate the target of a symbolic ref when creating it.  For
/// > example, `foobar` is not a valid ref, therefore `foobar` is
/// > not a valid target for a symbolic ref by default, whereas
/// > `refs/heads/foobar` is.  Disabling this bypasses validation
/// > so that an arbitrary strings such as `foobar` can be used
/// > for a symbolic ref target.  This defaults to enabled.
/// 
/// * opts(GIT_OPT_SET_SSL_CIPHERS, const char *ciphers)
/// 
/// > Set the SSL ciphers use for HTTPS connections.
/// >
/// > - `ciphers` is the list of ciphers that are eanbled.
/// 
/// * opts(GIT_OPT_ENABLE_OFS_DELTA, int enabled)
/// 
/// > Enable or disable the use of "offset deltas" when creating packfiles,
/// > and the negotiation of them when talking to a remote server.
/// > Offset deltas store a delta base location as an offset into the
/// > packfile from the current location, which provides a shorter encoding
/// > and thus smaller resultant packfiles.
/// > Packfiles containing offset deltas can still be read.
/// > This defaults to enabled.
/// 
/// * opts(GIT_OPT_ENABLE_FSYNC_GITDIR, int enabled)
/// 
/// > Enable synchronized writes of files in the gitdir using `fsync`
/// > (or the platform equivalent) to ensure that new object data
/// > is written to permanent storage, not simply cached.  This
/// > defaults to disabled.
/// 
/// opts(GIT_OPT_ENABLE_STRICT_HASH_VERIFICATION, int enabled)
/// 
/// > Enable strict verification of object hashsums when reading
/// > objects from disk. This may impact performance due to an
/// > additional checksum calculation on each object. This defaults
/// > to enabled.
/// 
/// opts(GIT_OPT_SET_ALLOCATOR, git_allocator *allocator)
/// 
/// > Set the memory allocator to a different memory allocator. This
/// > allocator will then be used to make all memory allocations for
/// > libgit2 operations.  If the given `allocator` is NULL, then the
/// > system default will be restored.
/// 
/// opts(GIT_OPT_ENABLE_UNSAVED_INDEX_SAFETY, int enabled)
/// 
/// > Ensure that there are no unsaved changes in the index before
/// > beginning any operation that reloads the index from disk (eg,
/// > checkout).  If there are unsaved changes, the instruction will
/// > fail.  (Using the FORCE flag to checkout will still overwrite
/// > these changes.)
/// 
/// opts(GIT_OPT_GET_PACK_MAX_OBJECTS, size_t *out)
/// 
/// > Get the maximum number of objects libgit2 will allow in a pack
/// > file when downloading a pack file from a remote. This can be
/// > used to limit maximum memory usage when fetching from an untrusted
/// > remote.
/// 
/// opts(GIT_OPT_SET_PACK_MAX_OBJECTS, size_t objects)
/// 
/// > Set the maximum number of objects libgit2 will allow in a pack
/// > file when downloading a pack file from a remote.
/// 
/// opts(GIT_OPT_DISABLE_PACK_KEEP_FILE_CHECKS, int enabled)
/// > This will cause .keep file existence checks to be skipped when
/// > accessing packfiles, which can help performance with remote filesystems.
/// 
/// opts(GIT_OPT_ENABLE_HTTP_EXPECT_CONTINUE, int enabled)
/// > When connecting to a server using NTLM or Negotiate
/// > authentication, use expect/continue when POSTing data.
/// > This option is not available on Windows.
/// 
/// opts(GIT_OPT_SET_ODB_PACKED_PRIORITY, int priority)
/// > Override the default priority of the packed ODB backend which
/// > is added when default backends are assigned to a repository
/// 
/// opts(GIT_OPT_SET_ODB_LOOSE_PRIORITY, int priority)
/// > Override the default priority of the loose ODB backend which
/// > is added when default backends are assigned to a repository
/// 
/// opts(GIT_OPT_GET_EXTENSIONS, git_strarray *out)
/// > Returns the list of git extensions that are supported.  This
/// > is the list of built-in extensions supported by libgit2 and
/// > custom extensions that have been added with
/// > `GIT_OPT_SET_EXTENSIONS`.  Extensions that have been negated
/// > will not be returned.  The returned list should be released
/// > with `git_strarray_dispose`.
/// 
/// opts(GIT_OPT_SET_EXTENSIONS, const char **extensions, size_t len)
/// > Set that the given git extensions are supported by the caller.
/// > Extensions supported by libgit2 may be negated by prefixing
/// > them with a `!`.  For example: setting extensions to
/// > { "!noop", "newext" } indicates that the caller does not want
/// > to support repositories with the `noop` extension but does want
/// > to support repositories with the `newext` extension.
/// 
/// opts(GIT_OPT_GET_OWNER_VALIDATION, int *enabled)
/// > Gets the owner validation setting for repository
/// > directories.
/// 
/// opts(GIT_OPT_SET_OWNER_VALIDATION, int enabled)
/// > Set that repository directories should be owned by the current
/// > user. The default is to validate ownership.
/// 
/// opts(GIT_OPT_GET_HOMEDIR, git_buf *out)
/// > Gets the current user's home directory, as it will be used
/// > for file lookups. The path is written to the `out` buffer.
/// 
/// opts(GIT_OPT_SET_HOMEDIR, const char *path)
/// > Sets the directory used as the current user's home directory,
/// > for file lookups.
/// >
/// > - `path` directory of home directory.
/// 
/// opts(GIT_OPT_GET_SERVER_CONNECT_TIMEOUT, int *timeout)
/// > Gets the timeout (in milliseconds) to attempt connections to
/// > a remote server.
/// 
/// opts(GIT_OPT_SET_SERVER_CONNECT_TIMEOUT, int timeout)
/// > Sets the timeout (in milliseconds) to attempt connections to
/// > a remote server. Set to 0 to use the system default. Note that
/// > this may not be able to be configured longer than the system
/// > default, typically 75 seconds.
/// 
/// opts(GIT_OPT_GET_SERVER_TIMEOUT, int *timeout)
/// > Gets the timeout (in milliseconds) for reading from and writing
/// > to a remote server.
/// 
/// opts(GIT_OPT_SET_SERVER_TIMEOUT, int timeout)
/// > Sets the timeout (in milliseconds) for reading from and writing
/// > to a remote server. Set to 0 to use the system default.
/// 
/// @param option Option key
/// @return 0 on success, <0 on failure
@ffi.Native<ffi.Int Function(ffi.Int , ffi.VarArgs<(ffi.Pointer<ffi.Char> ,)>)>(symbol: 'git_libgit2_opts')
external int git_libgit2_optsCharPtr(int option,
ffi.Pointer<ffi.Char> va,
);

@ffi.Native<ffi.Int Function(ffi.Int , ffi.VarArgs<(ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> ,)>)>(symbol: 'git_libgit2_opts')
external int git_libgit2_optsCharPtrCharPtr(int option,
ffi.Pointer<ffi.Char> va,
ffi.Pointer<ffi.Char> va$1,
);

@ffi.Native<ffi.Int Function(ffi.Int , ffi.VarArgs<(ffi.Int ,)>)>(symbol: 'git_libgit2_opts')
external int git_libgit2_optsInt(int option,
int va,
);

/// Free the memory referred to by the git_buf.
/// 
/// Note that this does not free the `git_buf` itself, just the memory
/// pointed to by `buffer->ptr`.
/// 
/// @param buffer The buffer to deallocate
@ffi.Native<ffi.Void Function(ffi.Pointer<git_buf> )>()
external void git_buf_dispose(ffi.Pointer<git_buf> buffer,
);

/// Parse a hex formatted object id into a git_oid.
/// 
/// The appropriate number of bytes for the given object ID type will
/// be read from the string - 40 bytes for SHA1, 64 bytes for SHA256.
/// The given string need not be NUL terminated.
/// 
/// @param out oid structure the result is written into.
/// @param str input hex string; must be pointing at the start of
/// the hex sequence and have at least the number of bytes
/// needed for an oid encoded in hex (40 bytes for sha1,
/// 256 bytes for sha256).
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<ffi.Char> )>()
external int git_oid_fromstr(ffi.Pointer<git_oid> out,
ffi.Pointer<ffi.Char> str,
);

/// Parse a hex formatted NUL-terminated string into a git_oid.
/// 
/// @param out oid structure the result is written into.
/// @param str input hex string; must be null-terminated.
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<ffi.Char> )>()
external int git_oid_fromstrp(ffi.Pointer<git_oid> out,
ffi.Pointer<ffi.Char> str,
);

/// Parse N characters of a hex formatted object id into a git_oid.
/// 
/// If N is odd, the last byte's high nibble will be read in and the
/// low nibble set to zero.
/// 
/// @param out oid structure the result is written into.
/// @param str input hex string of at least size `length`
/// @param length length of the input string
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<ffi.Char> , ffi.Size )>()
external int git_oid_fromstrn(ffi.Pointer<git_oid> out,
ffi.Pointer<ffi.Char> str,
int length,
);

/// Copy an already raw oid into a git_oid structure.
/// 
/// @param out oid structure the result is written into.
/// @param raw the raw input bytes to be copied.
/// @return 0 on success or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<ffi.UnsignedChar> )>()
external int git_oid_fromraw(ffi.Pointer<git_oid> out,
ffi.Pointer<ffi.UnsignedChar> raw,
);

/// Format a git_oid into a hex string.
/// 
/// @param out output hex string; must be pointing at the start of
/// the hex sequence and have at least the number of bytes
/// needed for an oid encoded in hex (40 bytes for SHA1,
/// 64 bytes for SHA256). Only the oid digits are written;
/// a '\\0' terminator must be added by the caller if it is
/// required.
/// @param id oid structure to format.
/// @return 0 on success or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char> , ffi.Pointer<git_oid> )>()
external int git_oid_fmt(ffi.Pointer<ffi.Char> out,
ffi.Pointer<git_oid> id,
);

/// Format a git_oid into a partial hex string.
/// 
/// @param out output hex string; you say how many bytes to write.
/// If the number of bytes is > GIT_OID_SHA1_HEXSIZE, extra bytes
/// will be zeroed; if not, a '\0' terminator is NOT added.
/// @param n number of characters to write into out string
/// @param id oid structure to format.
/// @return 0 on success or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char> , ffi.Size , ffi.Pointer<git_oid> )>()
external int git_oid_nfmt(ffi.Pointer<ffi.Char> out,
int n,
ffi.Pointer<git_oid> id,
);

/// Format a git_oid into a loose-object path string.
/// 
/// The resulting string is "aa/...", where "aa" is the first two
/// hex digits of the oid and "..." is the remaining 38 digits.
/// 
/// @param out output hex string; must be pointing at the start of
/// the hex sequence and have at least the number of bytes
/// needed for an oid encoded in hex (41 bytes for SHA1,
/// 65 bytes for SHA256). Only the oid digits are written;
/// a '\\0' terminator must be added by the caller if it
/// is required.
/// @param id oid structure to format.
/// @return 0 on success, non-zero callback return value, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char> , ffi.Pointer<git_oid> )>()
external int git_oid_pathfmt(ffi.Pointer<ffi.Char> out,
ffi.Pointer<git_oid> id,
);

/// Format a git_oid into a statically allocated c-string.
/// 
/// The c-string is owned by the library and should not be freed
/// by the user. If libgit2 is built with thread support, the string
/// will be stored in TLS (i.e. one buffer per thread) to allow for
/// concurrent calls of the function.
/// 
/// @param oid The oid structure to format
/// @return the c-string or NULL on failure
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_oid> )>()
external ffi.Pointer<ffi.Char> git_oid_tostr_s(ffi.Pointer<git_oid> oid,
);

/// Format a git_oid into a buffer as a hex format c-string.
/// 
/// If the buffer is smaller than the size of a hex-formatted oid string
/// plus an additional byte (GIT_OID_SHA_HEXSIZE + 1 for SHA1 or
/// GIT_OID_SHA256_HEXSIZE + 1 for SHA256), then the resulting
/// oid c-string will be truncated to n-1 characters (but will still be
/// NUL-byte terminated).
/// 
/// If there are any input parameter errors (out == NULL, n == 0, oid ==
/// NULL), then a pointer to an empty string is returned, so that the
/// return value can always be printed.
/// 
/// @param out the buffer into which the oid string is output.
/// @param n the size of the out buffer.
/// @param id the oid structure to format.
/// @return the out buffer pointer, assuming no input parameter
/// errors, otherwise a pointer to an empty string.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char> , ffi.Size , ffi.Pointer<git_oid> )>()
external ffi.Pointer<ffi.Char> git_oid_tostr(ffi.Pointer<ffi.Char> out,
int n,
ffi.Pointer<git_oid> id,
);

/// Copy an oid from one structure to another.
/// 
/// @param out oid structure the result is written into.
/// @param src oid structure to copy from.
/// @return 0 on success or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_oid> )>()
external int git_oid_cpy(ffi.Pointer<git_oid> out,
ffi.Pointer<git_oid> src,
);

/// Compare two oid structures.
/// 
/// @param a first oid structure.
/// @param b second oid structure.
/// @return <0, 0, >0 if a < b, a == b, a > b.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_oid> )>()
external int git_oid_cmp(ffi.Pointer<git_oid> a,
ffi.Pointer<git_oid> b,
);

/// Compare two oid structures for equality
/// 
/// @param a first oid structure.
/// @param b second oid structure.
/// @return true if equal, false otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_oid> )>()
external int git_oid_equal(ffi.Pointer<git_oid> a,
ffi.Pointer<git_oid> b,
);

/// Compare the first 'len' hexadecimal characters (packets of 4 bits)
/// of two oid structures.
/// 
/// @param a first oid structure.
/// @param b second oid structure.
/// @param len the number of hex chars to compare
/// @return 0 in case of a match
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_oid> , ffi.Size )>()
external int git_oid_ncmp(ffi.Pointer<git_oid> a,
ffi.Pointer<git_oid> b,
int len,
);

/// Check if an oid equals an hex formatted object id.
/// 
/// @param id oid structure.
/// @param str input hex string of an object id.
/// @return 0 in case of a match, -1 otherwise.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<ffi.Char> )>()
external int git_oid_streq(ffi.Pointer<git_oid> id,
ffi.Pointer<ffi.Char> str,
);

/// Compare an oid to an hex formatted object id.
/// 
/// @param id oid structure.
/// @param str input hex string of an object id.
/// @return -1 if str is not valid, <0 if id sorts before str,
/// 0 if id matches str, >0 if id sorts after str.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<ffi.Char> )>()
external int git_oid_strcmp(ffi.Pointer<git_oid> id,
ffi.Pointer<ffi.Char> str,
);

/// Check is an oid is all zeros.
/// 
/// @param id the object ID to check
/// @return 1 if all zeros, 0 otherwise.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> )>()
external int git_oid_is_zero(ffi.Pointer<git_oid> id,
);

/// Create a new OID shortener.
/// 
/// The OID shortener is used to process a list of OIDs
/// in text form and return the shortest length that would
/// uniquely identify all of them.
/// 
/// E.g. look at the result of `git log --abbrev`.
/// 
/// @param min_length The minimal length for all identifiers,
/// which will be used even if shorter OIDs would still
/// be unique.
/// @return a `git_oid_shorten` instance, NULL if OOM
@ffi.Native<ffi.Pointer<git_oid_shorten> Function(ffi.Size )>()
external ffi.Pointer<git_oid_shorten> git_oid_shorten_new(int min_length,
);

/// Add a new OID to set of shortened OIDs and calculate
/// the minimal length to uniquely identify all the OIDs in
/// the set.
/// 
/// The OID is expected to be a 40-char hexadecimal string.
/// The OID is owned by the user and will not be modified
/// or freed.
/// 
/// For performance reasons, there is a hard-limit of how many
/// OIDs can be added to a single set (around ~32000, assuming
/// a mostly randomized distribution), which should be enough
/// for any kind of program, and keeps the algorithm fast and
/// memory-efficient.
/// 
/// Attempting to add more than those OIDs will result in a
/// GIT_ERROR_INVALID error
/// 
/// @param os a `git_oid_shorten` instance
/// @param text_id an OID in text form
/// @return the minimal length to uniquely identify all OIDs
/// added so far to the set; or an error code (<0) if an
/// error occurs.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid_shorten> , ffi.Pointer<ffi.Char> )>()
external int git_oid_shorten_add(ffi.Pointer<git_oid_shorten> os,
ffi.Pointer<ffi.Char> text_id,
);

/// Free an OID shortener instance
/// 
/// @param os a `git_oid_shorten` instance
@ffi.Native<ffi.Void Function(ffi.Pointer<git_oid_shorten> )>()
external void git_oid_shorten_free(ffi.Pointer<git_oid_shorten> os,
);

/// Free the object IDs contained in an oid_array.  This method should
/// be called on `git_oidarray` objects that were provided by the
/// library.  Not doing so will result in a memory leak.
/// 
/// This does not free the `git_oidarray` itself, since the library will
/// never allocate that object directly itself.
/// 
/// @param array git_oidarray from which to free oid data
@ffi.Native<ffi.Void Function(ffi.Pointer<git_oidarray> )>()
external void git_oidarray_dispose(ffi.Pointer<git_oidarray> array,
);

/// Initializes a `git_indexer_options` with default values. Equivalent to
/// creating an instance with GIT_INDEXER_OPTIONS_INIT.
/// 
/// @param opts the `git_indexer_options` struct to initialize.
/// @param version Version of struct; pass `GIT_INDEXER_OPTIONS_VERSION`
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_indexer_options> , ffi.UnsignedInt )>()
external int git_indexer_options_init(ffi.Pointer<git_indexer_options> opts,
int version,
);

/// Create a new indexer instance
/// 
/// @param out where to store the indexer instance
/// @param path to the directory where the packfile should be stored
/// @param mode permissions to use creating packfile or 0 for defaults
/// @param odb object database from which to read base objects when
/// fixing thin packs. Pass NULL if no thin pack is expected (an error
/// will be returned if there are bases missing)
/// @param opts Optional structure containing additional options. See
/// `git_indexer_options` above.
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_indexer>> , ffi.Pointer<ffi.Char> , ffi.UnsignedInt , ffi.Pointer<git_odb> , ffi.Pointer<git_indexer_options> )>()
external int git_indexer_new(ffi.Pointer<ffi.Pointer<git_indexer>> out,
ffi.Pointer<ffi.Char> path,
int mode,
ffi.Pointer<git_odb> odb,
ffi.Pointer<git_indexer_options> opts,
);

/// Add data to the indexer
/// 
/// @param idx the indexer
/// @param data the data to add
/// @param size the size of the data in bytes
/// @param stats stat storage
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_indexer> , ffi.Pointer<ffi.Void> , ffi.Size , ffi.Pointer<git_indexer_progress> )>()
external int git_indexer_append(ffi.Pointer<git_indexer> idx,
ffi.Pointer<ffi.Void> data,
int size,
ffi.Pointer<git_indexer_progress> stats,
);

/// Finalize the pack and index
/// 
/// Resolve any pending deltas and write out the index file
/// 
/// @param idx the indexer
/// @param stats Stat storage.
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_indexer> , ffi.Pointer<git_indexer_progress> )>()
external int git_indexer_commit(ffi.Pointer<git_indexer> idx,
ffi.Pointer<git_indexer_progress> stats,
);

/// Get the packfile's hash
/// 
/// A packfile's name is derived from the sorted hashing of all object
/// names. This is only correct after the index has been finalized.
/// 
/// @deprecated use git_indexer_name
/// @param idx the indexer instance
/// @return the packfile's hash
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_indexer> )>()
external ffi.Pointer<git_oid> git_indexer_hash(ffi.Pointer<git_indexer> idx,
);

/// Get the unique name for the resulting packfile.
/// 
/// The packfile's name is derived from the packfile's content.
/// This is only correct after the index has been finalized.
/// 
/// @param idx the indexer instance
/// @return a NUL terminated string for the packfile name
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_indexer> )>()
external ffi.Pointer<ffi.Char> git_indexer_name(ffi.Pointer<git_indexer> idx,
);

/// Free the indexer and its resources
/// 
/// @param idx the indexer to free
@ffi.Native<ffi.Void Function(ffi.Pointer<git_indexer> )>()
external void git_indexer_free(ffi.Pointer<git_indexer> idx,
);

/// Create a new object database with no backends.
/// 
/// Before the ODB can be used for read/writing, a custom database
/// backend must be manually added using `git_odb_add_backend()`
/// 
/// @param[out] odb location to store the database pointer, if opened.
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb>> )>()
external int git_odb_new(ffi.Pointer<ffi.Pointer<git_odb>> odb,
);

/// Create a new object database and automatically add
/// the two default backends:
/// 
/// - git_odb_backend_loose: read and write loose object files
/// from disk, assuming `objects_dir` as the Objects folder
/// 
/// - git_odb_backend_pack: read objects from packfiles,
/// assuming `objects_dir` as the Objects folder which
/// contains a 'pack/' folder with the corresponding data
/// 
/// @param[out] odb_out location to store the database pointer, if opened.
/// Set to NULL if the open failed.
/// @param objects_dir path of the backends' "objects" directory.
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb>> , ffi.Pointer<ffi.Char> )>()
external int git_odb_open(ffi.Pointer<ffi.Pointer<git_odb>> odb_out,
ffi.Pointer<ffi.Char> objects_dir,
);

/// Add an on-disk alternate to an existing Object DB.
/// 
/// Note that the added path must point to an `objects`, not
/// to a full repository, to use it as an alternate store.
/// 
/// Alternate backends are always checked for objects *after*
/// all the main backends have been exhausted.
/// 
/// Writing is disabled on alternate backends.
/// 
/// @param odb database to add the backend to
/// @param path path to the objects folder for the alternate
/// @return 0 on success, error code otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_odb> , ffi.Pointer<ffi.Char> )>()
external int git_odb_add_disk_alternate(ffi.Pointer<git_odb> odb,
ffi.Pointer<ffi.Char> path,
);

/// Close an open object database.
/// 
/// @param db database pointer to close. If NULL no action is taken.
@ffi.Native<ffi.Void Function(ffi.Pointer<git_odb> )>()
external void git_odb_free(ffi.Pointer<git_odb> db,
);

/// Read an object from the database.
/// 
/// This method queries all available ODB backends
/// trying to read the given OID.
/// 
/// The returned object is reference counted and
/// internally cached, so it should be closed
/// by the user once it's no longer in use.
/// 
/// @param[out] obj pointer where to store the read object
/// @param db database to search for the object in.
/// @param id identity of the object to read.
/// @return 0 if the object was read, GIT_ENOTFOUND if the object is
/// not in the database.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb_object>> , ffi.Pointer<git_odb> , ffi.Pointer<git_oid> )>()
external int git_odb_read(ffi.Pointer<ffi.Pointer<git_odb_object>> obj,
ffi.Pointer<git_odb> db,
ffi.Pointer<git_oid> id,
);

/// Read an object from the database, given a prefix
/// of its identifier.
/// 
/// This method queries all available ODB backends
/// trying to match the 'len' first hexadecimal
/// characters of the 'short_id'.
/// The remaining (GIT_OID_SHA1_HEXSIZE-len)*4 bits of
/// 'short_id' must be 0s.
/// 'len' must be at least GIT_OID_MINPREFIXLEN,
/// and the prefix must be long enough to identify
/// a unique object in all the backends; the
/// method will fail otherwise.
/// 
/// The returned object is reference counted and
/// internally cached, so it should be closed
/// by the user once it's no longer in use.
/// 
/// @param[out] obj pointer where to store the read object
/// @param db database to search for the object in.
/// @param short_id a prefix of the id of the object to read.
/// @param len the length of the prefix
/// @return 0 if the object was read, GIT_ENOTFOUND if the object is not in the
/// database. GIT_EAMBIGUOUS if the prefix is ambiguous
/// (several objects match the prefix)
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb_object>> , ffi.Pointer<git_odb> , ffi.Pointer<git_oid> , ffi.Size )>()
external int git_odb_read_prefix(ffi.Pointer<ffi.Pointer<git_odb_object>> obj,
ffi.Pointer<git_odb> db,
ffi.Pointer<git_oid> short_id,
int len,
);

/// Read the header of an object from the database, without
/// reading its full contents.
/// 
/// The header includes the length and the type of an object.
/// 
/// Note that most backends do not support reading only the header
/// of an object, so the whole object will be read and then the
/// header will be returned.
/// 
/// @param[out] len_out pointer where to store the length
/// @param[out] type_out pointer where to store the type
/// @param db database to search for the object in.
/// @param id identity of the object to read.
/// @return 0 if the object was read, GIT_ENOTFOUND if the object is not
/// in the database.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Size> , ffi.Pointer<ffi.Int> , ffi.Pointer<git_odb> , ffi.Pointer<git_oid> )>()
external int git_odb_read_header(ffi.Pointer<ffi.Size> len_out,
ffi.Pointer<ffi.Int> type_out,
ffi.Pointer<git_odb> db,
ffi.Pointer<git_oid> id,
);

/// Determine if the given object can be found in the object database.
/// 
/// @param db database to be searched for the given object.
/// @param id the object to search for.
/// @return 1 if the object was found, 0 otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_odb> , ffi.Pointer<git_oid> )>()
external int git_odb_exists(ffi.Pointer<git_odb> db,
ffi.Pointer<git_oid> id,
);

/// Determine if the given object can be found in the object database, with
/// extended options.
/// 
/// @param db database to be searched for the given object.
/// @param id the object to search for.
/// @param flags flags affecting the lookup (see `git_odb_lookup_flags_t`)
/// @return 1 if the object was found, 0 otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_odb> , ffi.Pointer<git_oid> , ffi.UnsignedInt )>()
external int git_odb_exists_ext(ffi.Pointer<git_odb> db,
ffi.Pointer<git_oid> id,
int flags,
);

/// Determine if an object can be found in the object database by an
/// abbreviated object ID.
/// 
/// @param out The full OID of the found object if just one is found.
/// @param db The database to be searched for the given object.
/// @param short_id A prefix of the id of the object to read.
/// @param len The length of the prefix.
/// @return 0 if found, GIT_ENOTFOUND if not found, GIT_EAMBIGUOUS if multiple
/// matches were found, other value < 0 if there was a read error.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_odb> , ffi.Pointer<git_oid> , ffi.Size )>()
external int git_odb_exists_prefix(ffi.Pointer<git_oid> out,
ffi.Pointer<git_odb> db,
ffi.Pointer<git_oid> short_id,
int len,
);

/// Determine if one or more objects can be found in the object database
/// by their abbreviated object ID and type.
/// 
/// The given array will be updated in place: for each abbreviated ID that is
/// unique in the database, and of the given type (if specified),
/// the full object ID, object ID length (`GIT_OID_SHA1_HEXSIZE`) and type will be
/// written back to the array. For IDs that are not found (or are ambiguous),
/// the array entry will be zeroed.
/// 
/// Note that since this function operates on multiple objects, the
/// underlying database will not be asked to be reloaded if an object is
/// not found (which is unlike other object database operations.)
/// 
/// @param db The database to be searched for the given objects.
/// @param ids An array of short object IDs to search for
/// @param count The length of the `ids` array
/// @return 0 on success or an error code on failure
@ffi.Native<ffi.Int Function(ffi.Pointer<git_odb> , ffi.Pointer<git_odb_expand_id> , ffi.Size )>()
external int git_odb_expand_ids(ffi.Pointer<git_odb> db,
ffi.Pointer<git_odb_expand_id> ids,
int count,
);

/// Refresh the object database to load newly added files.
/// 
/// If the object databases have changed on disk while the library
/// is running, this function will force a reload of the underlying
/// indexes.
/// 
/// Use this function when you're confident that an external
/// application has tampered with the ODB.
/// 
/// NOTE that it is not necessary to call this function at all. The
/// library will automatically attempt to refresh the ODB
/// when a lookup fails, to see if the looked up object exists
/// on disk but hasn't been loaded yet.
/// 
/// @param db database to refresh
/// @return 0 on success, error code otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_odb> )>()
external int git_odb_refresh(ffi.Pointer<git_odb> db,
);

/// List all objects available in the database
/// 
/// The callback will be called for each object available in the
/// database. Note that the objects are likely to be returned in the index
/// order, which would make accessing the objects in that order inefficient.
/// Return a non-zero value from the callback to stop looping.
/// 
/// @param db database to use
/// @param cb the callback to call for each object
/// @param payload data to pass to the callback
/// @return 0 on success, non-zero callback return value, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_odb> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_oid> id, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_odb_foreach(ffi.Pointer<git_odb> db,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_oid> id, ffi.Pointer<ffi.Void> payload)>> cb,
ffi.Pointer<ffi.Void> payload,
);

/// Write an object directly into the ODB
/// 
/// This method writes a full object straight into the ODB.
/// For most cases, it is preferred to write objects through a write
/// stream, which is both faster and less memory intensive, specially
/// for big objects.
/// 
/// This method is provided for compatibility with custom backends
/// which are not able to support streaming writes
/// 
/// @param out pointer to store the OID result of the write
/// @param odb object database where to store the object
/// @param data @type `const unsigned char *` buffer with the data to store
/// @param len size of the buffer
/// @param type type of the data to store
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_odb> , ffi.Pointer<ffi.Void> , ffi.Size , ffi.Int )>(symbol: 'git_odb_write')
external int _git_odb_write(ffi.Pointer<git_oid> out,
ffi.Pointer<git_odb> odb,
ffi.Pointer<ffi.Void> data,
int len,
int type,
);

int git_odb_write(ffi.Pointer<git_oid> out,
ffi.Pointer<git_odb> odb,
ffi.Pointer<ffi.Void> data,
int len,
git_object_t type,
) => _git_odb_write(out,
odb,
data,
len,
type.value,
);

/// Open a stream to write an object into the ODB
/// 
/// The type and final length of the object must be specified
/// when opening the stream.
/// 
/// The returned stream will be of type `GIT_STREAM_WRONLY`, and it
/// won't be effective until `git_odb_stream_finalize_write` is called
/// and returns without an error
/// 
/// The stream must always be freed when done with `git_odb_stream_free` or
/// will leak memory.
/// 
/// @see git_odb_stream
/// 
/// @param out pointer where to store the stream
/// @param db object database where the stream will write
/// @param size final size of the object that will be written
/// @param type type of the object that will be written
/// @return 0 if the stream was created; error code otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb_stream>> , ffi.Pointer<git_odb> , ffi.Uint64 , ffi.Int )>(symbol: 'git_odb_open_wstream')
external int _git_odb_open_wstream(ffi.Pointer<ffi.Pointer<git_odb_stream>> out,
ffi.Pointer<git_odb> db,
int size,
int type,
);

int git_odb_open_wstream(ffi.Pointer<ffi.Pointer<git_odb_stream>> out,
ffi.Pointer<git_odb> db,
int size,
git_object_t type,
) => _git_odb_open_wstream(out,
db,
size,
type.value,
);

/// Write to an odb stream
/// 
/// This method will fail if the total number of received bytes exceeds the
/// size declared with `git_odb_open_wstream()`
/// 
/// @param stream the stream
/// @param buffer the data to write
/// @param len the buffer's length
/// @return 0 if the write succeeded, error code otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_odb_stream> , ffi.Pointer<ffi.Char> , ffi.Size )>()
external int git_odb_stream_write(ffi.Pointer<git_odb_stream> stream,
ffi.Pointer<ffi.Char> buffer,
int len,
);

/// Finish writing to an odb stream
/// 
/// The object will take its final name and will be available to the
/// odb.
/// 
/// This method will fail if the total number of received bytes
/// differs from the size declared with `git_odb_open_wstream()`
/// 
/// @param out pointer to store the resulting object's id
/// @param stream the stream
/// @return 0 on success, an error code otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_odb_stream> )>()
external int git_odb_stream_finalize_write(ffi.Pointer<git_oid> out,
ffi.Pointer<git_odb_stream> stream,
);

/// Read from an odb stream
/// 
/// Most backends don't implement streaming reads
/// 
/// @param stream the stream
/// @param buffer a user-allocated buffer to store the data in.
/// @param len the buffer's length
/// @return the number of bytes read if succeeded, error code otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_odb_stream> , ffi.Pointer<ffi.Char> , ffi.Size )>()
external int git_odb_stream_read(ffi.Pointer<git_odb_stream> stream,
ffi.Pointer<ffi.Char> buffer,
int len,
);

/// Free an odb stream
/// 
/// @param stream the stream to free
@ffi.Native<ffi.Void Function(ffi.Pointer<git_odb_stream> )>()
external void git_odb_stream_free(ffi.Pointer<git_odb_stream> stream,
);

/// Open a stream to read an object from the ODB
/// 
/// Note that most backends do *not* support streaming reads
/// because they store their objects as compressed/delta'ed blobs.
/// 
/// It's recommended to use `git_odb_read` instead, which is
/// assured to work on all backends.
/// 
/// The returned stream will be of type `GIT_STREAM_RDONLY` and
/// will have the following methods:
/// 
/// - stream->read: read `n` bytes from the stream
/// - stream->free: free the stream
/// 
/// The stream must always be free'd or will leak memory.
/// 
/// @see git_odb_stream
/// 
/// @param out pointer where to store the stream
/// @param len pointer where to store the length of the object
/// @param type pointer where to store the type of the object
/// @param db object database where the stream will read from
/// @param oid oid of the object the stream will read from
/// @return 0 if the stream was created, error code otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb_stream>> , ffi.Pointer<ffi.Size> , ffi.Pointer<ffi.Int> , ffi.Pointer<git_odb> , ffi.Pointer<git_oid> )>()
external int git_odb_open_rstream(ffi.Pointer<ffi.Pointer<git_odb_stream>> out,
ffi.Pointer<ffi.Size> len,
ffi.Pointer<ffi.Int> type,
ffi.Pointer<git_odb> db,
ffi.Pointer<git_oid> oid,
);

/// Open a stream for writing a pack file to the ODB.
/// 
/// If the ODB layer understands pack files, then the given
/// packfile will likely be streamed directly to disk (and a
/// corresponding index created).  If the ODB layer does not
/// understand pack files, the objects will be stored in whatever
/// format the ODB layer uses.
/// 
/// @see git_odb_writepack
/// 
/// @param out pointer to the writepack functions
/// @param db object database where the stream will read from
/// @param progress_cb function to call with progress information.
/// Be aware that this is called inline with network and indexing operations,
/// so performance may be affected.
/// @param progress_payload payload for the progress callback
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb_writepack>> , ffi.Pointer<git_odb> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_indexer_progress> stats, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_odb_write_pack(ffi.Pointer<ffi.Pointer<git_odb_writepack>> out,
ffi.Pointer<git_odb> db,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_indexer_progress> stats, ffi.Pointer<ffi.Void> payload)>> progress_cb,
ffi.Pointer<ffi.Void> progress_payload,
);

/// Write a `multi-pack-index` file from all the `.pack` files in the ODB.
/// 
/// If the ODB layer understands pack files, then this will create a file called
/// `multi-pack-index` next to the `.pack` and `.idx` files, which will contain
/// an index of all objects stored in `.pack` files. This will allow for
/// O(log n) lookup for n objects (regardless of how many packfiles there
/// exist).
/// 
/// @param db object database where the `multi-pack-index` file will be written.
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_odb> )>()
external int git_odb_write_multi_pack_index(ffi.Pointer<git_odb> db,
);

/// Determine the object-ID (sha1 or sha256 hash) of a data buffer
/// 
/// The resulting OID will be the identifier for the data buffer as if
/// the data buffer it were to written to the ODB.
/// 
/// @param[out] oid the resulting object-ID.
/// @param data data to hash
/// @param len size of the data
/// @param object_type of the data to hash
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<ffi.Void> , ffi.Size , ffi.Int )>(symbol: 'git_odb_hash')
external int _git_odb_hash(ffi.Pointer<git_oid> oid,
ffi.Pointer<ffi.Void> data,
int len,
int object_type,
);

int git_odb_hash(ffi.Pointer<git_oid> oid,
ffi.Pointer<ffi.Void> data,
int len,
git_object_t object_type,
) => _git_odb_hash(oid,
data,
len,
object_type.value,
);

/// Read a file from disk and fill a git_oid with the object id
/// that the file would have if it were written to the Object
/// Database as an object of the given type (w/o applying filters).
/// Similar functionality to git.git's `git hash-object` without
/// the `-w` flag, however, with the --no-filters flag.
/// If you need filters, see git_repository_hashfile.
/// 
/// @param[out] oid oid structure the result is written into.
/// @param path file to read and determine object id for
/// @param object_type of the data to hash
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<ffi.Char> , ffi.Int )>(symbol: 'git_odb_hashfile')
external int _git_odb_hashfile(ffi.Pointer<git_oid> oid,
ffi.Pointer<ffi.Char> path,
int object_type,
);

int git_odb_hashfile(ffi.Pointer<git_oid> oid,
ffi.Pointer<ffi.Char> path,
git_object_t object_type,
) => _git_odb_hashfile(oid,
path,
object_type.value,
);

/// Create a copy of an odb_object
/// 
/// The returned copy must be manually freed with `git_odb_object_free`.
/// Note that because of an implementation detail, the returned copy will be
/// the same pointer as `source`: the object is internally refcounted, so the
/// copy still needs to be freed twice.
/// 
/// @param dest pointer where to store the copy
/// @param source object to copy
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb_object>> , ffi.Pointer<git_odb_object> )>()
external int git_odb_object_dup(ffi.Pointer<ffi.Pointer<git_odb_object>> dest,
ffi.Pointer<git_odb_object> source,
);

/// Close an ODB object
/// 
/// This method must always be called once a `git_odb_object` is no
/// longer needed, otherwise memory will leak.
/// 
/// @param object object to close
@ffi.Native<ffi.Void Function(ffi.Pointer<git_odb_object> )>()
external void git_odb_object_free(ffi.Pointer<git_odb_object> object,
);

/// Return the OID of an ODB object
/// 
/// This is the OID from which the object was read from
/// 
/// @param object the object
/// @return a pointer to the OID
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_odb_object> )>()
external ffi.Pointer<git_oid> git_odb_object_id(ffi.Pointer<git_odb_object> object,
);

/// Return the data of an ODB object
/// 
/// This is the uncompressed, raw data as read from the ODB,
/// without the leading header.
/// 
/// This pointer is owned by the object and shall not be free'd.
/// 
/// @param object the object
/// @return @type `const unsigned char *` a pointer to the data
@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Pointer<git_odb_object> )>()
external ffi.Pointer<ffi.Void> git_odb_object_data(ffi.Pointer<git_odb_object> object,
);

/// Return the size of an ODB object
/// 
/// This is the real size of the `data` buffer, not the
/// actual size of the object.
/// 
/// @param object the object
/// @return the size
@ffi.Native<ffi.Size Function(ffi.Pointer<git_odb_object> )>()
external int git_odb_object_size(ffi.Pointer<git_odb_object> object,
);

/// Return the type of an ODB object
/// 
/// @param object the object
/// @return the type
@ffi.Native<ffi.Int Function(ffi.Pointer<git_odb_object> )>(symbol: 'git_odb_object_type')
external int _git_odb_object_type(ffi.Pointer<git_odb_object> object,
);

git_object_t git_odb_object_type(ffi.Pointer<git_odb_object> object,
) => git_object_t.fromValue(_git_odb_object_type(object,
));

/// Add a custom backend to an existing Object DB
/// 
/// The backends are checked in relative ordering, based on the
/// value of the `priority` parameter.
/// 
/// Read <sys/odb_backend.h> for more information.
/// 
/// @param odb database to add the backend to
/// @param backend pointer to a git_odb_backend instance
/// @param priority Value for ordering the backends queue
/// @return 0 on success, error code otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_odb> , ffi.Pointer<git_odb_backend> , ffi.Int )>()
external int git_odb_add_backend(ffi.Pointer<git_odb> odb,
ffi.Pointer<git_odb_backend> backend,
int priority,
);

/// Add a custom backend to an existing Object DB; this
/// backend will work as an alternate.
/// 
/// Alternate backends are always checked for objects *after*
/// all the main backends have been exhausted.
/// 
/// The backends are checked in relative ordering, based on the
/// value of the `priority` parameter.
/// 
/// Writing is disabled on alternate backends.
/// 
/// Read <sys/odb_backend.h> for more information.
/// 
/// @param odb database to add the backend to
/// @param backend pointer to a git_odb_backend instance
/// @param priority Value for ordering the backends queue
/// @return 0 on success, error code otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_odb> , ffi.Pointer<git_odb_backend> , ffi.Int )>()
external int git_odb_add_alternate(ffi.Pointer<git_odb> odb,
ffi.Pointer<git_odb_backend> backend,
int priority,
);

/// Get the number of ODB backend objects
/// 
/// @param odb object database
/// @return number of backends in the ODB
@ffi.Native<ffi.Size Function(ffi.Pointer<git_odb> )>()
external int git_odb_num_backends(ffi.Pointer<git_odb> odb,
);

/// Lookup an ODB backend object by index
/// 
/// @param out output pointer to ODB backend at pos
/// @param odb object database
/// @param pos index into object database backend list
/// @return 0 on success, GIT_ENOTFOUND if pos is invalid, other errors < 0
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb_backend>> , ffi.Pointer<git_odb> , ffi.Size )>()
external int git_odb_get_backend(ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
ffi.Pointer<git_odb> odb,
int pos,
);

/// Set the git commit-graph for the ODB.
/// 
/// After a successful call, the ownership of the cgraph parameter will be
/// transferred to libgit2, and the caller should not free it.
/// 
/// The commit-graph can also be unset by explicitly passing NULL as the cgraph
/// parameter.
/// 
/// @param odb object database
/// @param cgraph the git commit-graph
/// @return 0 on success; error code otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_odb> , ffi.Pointer<git_commit_graph> )>()
external int git_odb_set_commit_graph(ffi.Pointer<git_odb> odb,
ffi.Pointer<git_commit_graph> cgraph,
);

/// Lookup a reference to one of the objects in a repository.
/// 
/// The generated reference is owned by the repository and
/// should be closed with the `git_object_free` method
/// instead of free'd manually.
/// 
/// The 'type' parameter must match the type of the object
/// in the odb; the method will fail otherwise.
/// The special value 'GIT_OBJECT_ANY' may be passed to let
/// the method guess the object's type.
/// 
/// @param object pointer to the looked-up object
/// @param repo the repository to look up the object
/// @param id the unique identifier for the object
/// @param type the type of the object
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_object>> , ffi.Pointer<git_repository> , ffi.Pointer<git_oid> , ffi.Int )>(symbol: 'git_object_lookup')
external int _git_object_lookup(ffi.Pointer<ffi.Pointer<git_object>> object,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_oid> id,
int type,
);

int git_object_lookup(ffi.Pointer<ffi.Pointer<git_object>> object,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_oid> id,
git_object_t type,
) => _git_object_lookup(object,
repo,
id,
type.value,
);

/// Lookup a reference to one of the objects in a repository,
/// given a prefix of its identifier (short id).
/// 
/// The object obtained will be so that its identifier
/// matches the first 'len' hexadecimal characters
/// (packets of 4 bits) of the given `id`. `len` must be
/// at least `GIT_OID_MINPREFIXLEN`, and long enough to
/// identify a unique object matching the prefix; otherwise
/// the method will fail.
/// 
/// The generated reference is owned by the repository and
/// should be closed with the `git_object_free` method
/// instead of free'd manually.
/// 
/// The `type` parameter must match the type of the object
/// in the odb; the method will fail otherwise.
/// The special value `GIT_OBJECT_ANY` may be passed to let
/// the method guess the object's type.
/// 
/// @param object_out pointer where to store the looked-up object
/// @param repo the repository to look up the object
/// @param id a short identifier for the object
/// @param len the length of the short identifier
/// @param type the type of the object
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_object>> , ffi.Pointer<git_repository> , ffi.Pointer<git_oid> , ffi.Size , ffi.Int )>(symbol: 'git_object_lookup_prefix')
external int _git_object_lookup_prefix(ffi.Pointer<ffi.Pointer<git_object>> object_out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_oid> id,
int len,
int type,
);

int git_object_lookup_prefix(ffi.Pointer<ffi.Pointer<git_object>> object_out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_oid> id,
int len,
git_object_t type,
) => _git_object_lookup_prefix(object_out,
repo,
id,
len,
type.value,
);

/// Lookup an object that represents a tree entry.
/// 
/// @param out buffer that receives a pointer to the object (which must be freed
/// by the caller)
/// @param treeish root object that can be peeled to a tree
/// @param path relative path from the root object to the desired object
/// @param type type of object desired
/// @return 0 on success, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_object>> , ffi.Pointer<git_object> , ffi.Pointer<ffi.Char> , ffi.Int )>(symbol: 'git_object_lookup_bypath')
external int _git_object_lookup_bypath(ffi.Pointer<ffi.Pointer<git_object>> out,
ffi.Pointer<git_object> treeish,
ffi.Pointer<ffi.Char> path,
int type,
);

int git_object_lookup_bypath(ffi.Pointer<ffi.Pointer<git_object>> out,
ffi.Pointer<git_object> treeish,
ffi.Pointer<ffi.Char> path,
git_object_t type,
) => _git_object_lookup_bypath(out,
treeish,
path,
type.value,
);

/// Get the id (SHA1) of a repository object
/// 
/// @param obj the repository object
/// @return the SHA1 id
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_object> )>()
external ffi.Pointer<git_oid> git_object_id(ffi.Pointer<git_object> obj,
);

/// Get a short abbreviated OID string for the object
/// 
/// This starts at the "core.abbrev" length (default 7 characters) and
/// iteratively extends to a longer string if that length is ambiguous.
/// The result will be unambiguous (at least until new objects are added to
/// the repository).
/// 
/// @param out Buffer to write string into
/// @param obj The object to get an ID for
/// @return 0 on success, <0 for error
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_object> )>()
external int git_object_short_id(ffi.Pointer<git_buf> out,
ffi.Pointer<git_object> obj,
);

/// Get the object type of an object
/// 
/// @param obj the repository object
/// @return the object's type
@ffi.Native<ffi.Int Function(ffi.Pointer<git_object> )>(symbol: 'git_object_type')
external int _git_object_type(ffi.Pointer<git_object> obj,
);

git_object_t git_object_type(ffi.Pointer<git_object> obj,
) => git_object_t.fromValue(_git_object_type(obj,
));

/// Get the repository that owns this object
/// 
/// Freeing or calling `git_repository_close` on the
/// returned pointer will invalidate the actual object.
/// 
/// Any other operation may be run on the repository without
/// affecting the object.
/// 
/// @param obj the object
/// @return the repository who owns this object
@ffi.Native<ffi.Pointer<git_repository> Function(ffi.Pointer<git_object> )>()
external ffi.Pointer<git_repository> git_object_owner(ffi.Pointer<git_object> obj,
);

/// Close an open object
/// 
/// This method instructs the library to close an existing
/// object; note that git_objects are owned and cached by the repository
/// so the object may or may not be freed after this library call,
/// depending on how aggressive is the caching mechanism used
/// by the repository.
/// 
/// IMPORTANT:
/// It *is* necessary to call this method when you stop using
/// an object. Failure to do so will cause a memory leak.
/// 
/// @param object the object to close
@ffi.Native<ffi.Void Function(ffi.Pointer<git_object> )>()
external void git_object_free(ffi.Pointer<git_object> object,
);

/// Convert an object type to its string representation.
/// 
/// The result is a pointer to a string in static memory and
/// should not be free()'ed.
/// 
/// @param type object type to convert.
/// @return the corresponding string representation.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Int )>(symbol: 'git_object_type2string')
external ffi.Pointer<ffi.Char> _git_object_type2string(int type,
);

ffi.Pointer<ffi.Char> git_object_type2string(git_object_t type,
) => _git_object_type2string(type.value,
);

/// Convert a string object type representation to it's git_object_t.
/// 
/// @param str the string to convert.
/// @return the corresponding git_object_t.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char> )>(symbol: 'git_object_string2type')
external int _git_object_string2type(ffi.Pointer<ffi.Char> str,
);

git_object_t git_object_string2type(ffi.Pointer<ffi.Char> str,
) => git_object_t.fromValue(_git_object_string2type(str,
));

/// Determine if the given git_object_t is a valid loose object type.
/// 
/// @param type object type to test.
/// @return true if the type represents a valid loose object type,
/// false otherwise.
@ffi.Native<ffi.Int Function(ffi.Int )>(symbol: 'git_object_typeisloose')
external int _git_object_typeisloose(int type,
);

int git_object_typeisloose(git_object_t type,
) => _git_object_typeisloose(type.value,
);

/// Recursively peel an object until an object of the specified type is met.
/// 
/// If the query cannot be satisfied due to the object model,
/// GIT_EINVALIDSPEC will be returned (e.g. trying to peel a blob to a
/// tree).
/// 
/// If you pass `GIT_OBJECT_ANY` as the target type, then the object will
/// be peeled until the type changes. A tag will be peeled until the
/// referenced object is no longer a tag, and a commit will be peeled
/// to a tree. Any other object type will return GIT_EINVALIDSPEC.
/// 
/// If peeling a tag we discover an object which cannot be peeled to
/// the target type due to the object model, GIT_EPEEL will be
/// returned.
/// 
/// You must free the returned object.
/// 
/// @param peeled Pointer to the peeled git_object
/// @param object The object to be processed
/// @param target_type The type of the requested object (a GIT_OBJECT_ value)
/// @return 0 on success, GIT_EINVALIDSPEC, GIT_EPEEL, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_object>> , ffi.Pointer<git_object> , ffi.Int )>(symbol: 'git_object_peel')
external int _git_object_peel(ffi.Pointer<ffi.Pointer<git_object>> peeled,
ffi.Pointer<git_object> object,
int target_type,
);

int git_object_peel(ffi.Pointer<ffi.Pointer<git_object>> peeled,
ffi.Pointer<git_object> object,
git_object_t target_type,
) => _git_object_peel(peeled,
object,
target_type.value,
);

/// Create an in-memory copy of a Git object. The copy must be
/// explicitly free'd or it will leak.
/// 
/// @param dest Pointer to store the copy of the object
/// @param source Original object to copy
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_object>> , ffi.Pointer<git_object> )>()
external int git_object_dup(ffi.Pointer<ffi.Pointer<git_object>> dest,
ffi.Pointer<git_object> source,
);

/// Analyzes a buffer of raw object content and determines its validity.
/// Tree, commit, and tag objects will be parsed and ensured that they
/// are valid, parseable content.  (Blobs are always valid by definition.)
/// An error message will be set with an informative message if the object
/// is not valid.
/// 
/// @warning This function is experimental and its signature may change in
/// the future.
/// 
/// @param[out] valid Output pointer to set with validity of the object content
/// @param buf The contents to validate
/// @param len The length of the buffer
/// @param object_type The type of the object in the buffer
/// @return 0 on success or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Int> , ffi.Pointer<ffi.Char> , ffi.Size , ffi.Int )>(symbol: 'git_object_rawcontent_is_valid')
external int _git_object_rawcontent_is_valid(ffi.Pointer<ffi.Int> valid,
ffi.Pointer<ffi.Char> buf,
int len,
int object_type,
);

int git_object_rawcontent_is_valid(ffi.Pointer<ffi.Int> valid,
ffi.Pointer<ffi.Char> buf,
int len,
git_object_t object_type,
) => _git_object_rawcontent_is_valid(valid,
buf,
len,
object_type.value,
);

/// Lookup a commit object from a repository.
/// 
/// The returned object should be released with `git_commit_free` when no
/// longer needed.
/// 
/// @param commit pointer to the looked up commit
/// @param repo the repo to use when locating the commit.
/// @param id identity of the commit to locate. If the object is
/// an annotated tag it will be peeled back to the commit.
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_commit>> , ffi.Pointer<git_repository> , ffi.Pointer<git_oid> )>()
external int git_commit_lookup(ffi.Pointer<ffi.Pointer<git_commit>> commit,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_oid> id,
);

/// Lookup a commit object from a repository, given a prefix of its
/// identifier (short id).
/// 
/// The returned object should be released with `git_commit_free` when no
/// longer needed.
/// 
/// @see git_object_lookup_prefix
/// 
/// @param commit pointer to the looked up commit
/// @param repo the repo to use when locating the commit.
/// @param id identity of the commit to locate. If the object is
/// an annotated tag it will be peeled back to the commit.
/// @param len the length of the short identifier
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_commit>> , ffi.Pointer<git_repository> , ffi.Pointer<git_oid> , ffi.Size )>()
external int git_commit_lookup_prefix(ffi.Pointer<ffi.Pointer<git_commit>> commit,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_oid> id,
int len,
);

/// Close an open commit
/// 
/// This is a wrapper around git_object_free()
/// 
/// IMPORTANT:
/// It *is* necessary to call this method when you stop
/// using a commit. Failure to do so will cause a memory leak.
/// 
/// @param commit the commit to close
@ffi.Native<ffi.Void Function(ffi.Pointer<git_commit> )>()
external void git_commit_free(ffi.Pointer<git_commit> commit,
);

/// Get the id of a commit.
/// 
/// @param commit a previously loaded commit.
/// @return object identity for the commit.
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_commit> )>()
external ffi.Pointer<git_oid> git_commit_id(ffi.Pointer<git_commit> commit,
);

/// Get the repository that contains the commit.
/// 
/// @param commit A previously loaded commit.
/// @return Repository that contains this commit.
@ffi.Native<ffi.Pointer<git_repository> Function(ffi.Pointer<git_commit> )>()
external ffi.Pointer<git_repository> git_commit_owner(ffi.Pointer<git_commit> commit,
);

/// Get the encoding for the message of a commit,
/// as a string representing a standard encoding name.
/// 
/// The encoding may be NULL if the `encoding` header
/// in the commit is missing; in that case UTF-8 is assumed.
/// 
/// @param commit a previously loaded commit.
/// @return NULL, or the encoding
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_commit> )>()
external ffi.Pointer<ffi.Char> git_commit_message_encoding(ffi.Pointer<git_commit> commit,
);

/// Get the full message of a commit.
/// 
/// The returned message will be slightly prettified by removing any
/// potential leading newlines.
/// 
/// @param commit a previously loaded commit.
/// @return the message of a commit
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_commit> )>()
external ffi.Pointer<ffi.Char> git_commit_message(ffi.Pointer<git_commit> commit,
);

/// Get the full raw message of a commit.
/// 
/// @param commit a previously loaded commit.
/// @return the raw message of a commit
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_commit> )>()
external ffi.Pointer<ffi.Char> git_commit_message_raw(ffi.Pointer<git_commit> commit,
);

/// Get the short "summary" of the git commit message.
/// 
/// The returned message is the summary of the commit, comprising the
/// first paragraph of the message with whitespace trimmed and squashed.
/// 
/// @param commit a previously loaded commit.
/// @return the summary of a commit or NULL on error
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_commit> )>()
external ffi.Pointer<ffi.Char> git_commit_summary(ffi.Pointer<git_commit> commit,
);

/// Get the long "body" of the git commit message.
/// 
/// The returned message is the body of the commit, comprising
/// everything but the first paragraph of the message. Leading and
/// trailing whitespaces are trimmed.
/// 
/// @param commit a previously loaded commit.
/// @return the body of a commit or NULL when no the message only
/// consists of a summary
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_commit> )>()
external ffi.Pointer<ffi.Char> git_commit_body(ffi.Pointer<git_commit> commit,
);

/// Get the commit time (i.e. committer time) of a commit.
/// 
/// @param commit a previously loaded commit.
/// @return the time of a commit
@ffi.Native<ffi.Int64 Function(ffi.Pointer<git_commit> )>()
external int git_commit_time(ffi.Pointer<git_commit> commit,
);

/// Get the commit timezone offset (i.e. committer's preferred timezone) of a commit.
/// 
/// @param commit a previously loaded commit.
/// @return positive or negative timezone offset, in minutes from UTC
@ffi.Native<ffi.Int Function(ffi.Pointer<git_commit> )>()
external int git_commit_time_offset(ffi.Pointer<git_commit> commit,
);

/// Get the committer of a commit.
/// 
/// @param commit a previously loaded commit.
/// @return the committer of a commit
@ffi.Native<ffi.Pointer<git_signature> Function(ffi.Pointer<git_commit> )>()
external ffi.Pointer<git_signature> git_commit_committer(ffi.Pointer<git_commit> commit,
);

/// Get the author of a commit.
/// 
/// @param commit a previously loaded commit.
/// @return the author of a commit
@ffi.Native<ffi.Pointer<git_signature> Function(ffi.Pointer<git_commit> )>()
external ffi.Pointer<git_signature> git_commit_author(ffi.Pointer<git_commit> commit,
);

/// Get the committer of a commit, using the mailmap to map names and email
/// addresses to canonical real names and email addresses.
/// 
/// Call `git_signature_free` to free the signature.
/// 
/// @param out a pointer to store the resolved signature.
/// @param commit a previously loaded commit.
/// @param mailmap the mailmap to resolve with. (may be NULL)
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_signature>> , ffi.Pointer<git_commit> , ffi.Pointer<git_mailmap> )>()
external int git_commit_committer_with_mailmap(ffi.Pointer<ffi.Pointer<git_signature>> out,
ffi.Pointer<git_commit> commit,
ffi.Pointer<git_mailmap> mailmap,
);

/// Get the author of a commit, using the mailmap to map names and email
/// addresses to canonical real names and email addresses.
/// 
/// Call `git_signature_free` to free the signature.
/// 
/// @param out a pointer to store the resolved signature.
/// @param commit a previously loaded commit.
/// @param mailmap the mailmap to resolve with. (may be NULL)
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_signature>> , ffi.Pointer<git_commit> , ffi.Pointer<git_mailmap> )>()
external int git_commit_author_with_mailmap(ffi.Pointer<ffi.Pointer<git_signature>> out,
ffi.Pointer<git_commit> commit,
ffi.Pointer<git_mailmap> mailmap,
);

/// Get the full raw text of the commit header.
/// 
/// @param commit a previously loaded commit
/// @return the header text of the commit
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_commit> )>()
external ffi.Pointer<ffi.Char> git_commit_raw_header(ffi.Pointer<git_commit> commit,
);

/// Get the tree pointed to by a commit.
/// 
/// @param tree_out pointer where to store the tree object
/// @param commit a previously loaded commit.
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_tree>> , ffi.Pointer<git_commit> )>()
external int git_commit_tree(ffi.Pointer<ffi.Pointer<git_tree>> tree_out,
ffi.Pointer<git_commit> commit,
);

/// Get the id of the tree pointed to by a commit. This differs from
/// `git_commit_tree` in that no attempts are made to fetch an object
/// from the ODB.
/// 
/// @param commit a previously loaded commit.
/// @return the id of tree pointed to by commit.
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_commit> )>()
external ffi.Pointer<git_oid> git_commit_tree_id(ffi.Pointer<git_commit> commit,
);

/// Get the number of parents of this commit
/// 
/// @param commit a previously loaded commit.
/// @return integer of count of parents
@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<git_commit> )>()
external int git_commit_parentcount(ffi.Pointer<git_commit> commit,
);

/// Get the specified parent of the commit.
/// 
/// @param out Pointer where to store the parent commit
/// @param commit a previously loaded commit.
/// @param n the position of the parent (from 0 to `parentcount`)
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_commit>> , ffi.Pointer<git_commit> , ffi.UnsignedInt )>()
external int git_commit_parent(ffi.Pointer<ffi.Pointer<git_commit>> out,
ffi.Pointer<git_commit> commit,
int n,
);

/// Get the oid of a specified parent for a commit. This is different from
/// `git_commit_parent`, which will attempt to load the parent commit from
/// the ODB.
/// 
/// @param commit a previously loaded commit.
/// @param n the position of the parent (from 0 to `parentcount`)
/// @return the id of the parent, NULL on error.
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_commit> , ffi.UnsignedInt )>()
external ffi.Pointer<git_oid> git_commit_parent_id(ffi.Pointer<git_commit> commit,
int n,
);

/// Get the commit object that is the <n>th generation ancestor
/// of the named commit object, following only the first parents.
/// The returned commit has to be freed by the caller.
/// 
/// Passing `0` as the generation number returns another instance of the
/// base commit itself.
/// 
/// @param ancestor Pointer where to store the ancestor commit
/// @param commit a previously loaded commit.
/// @param n the requested generation
/// @return 0 on success; GIT_ENOTFOUND if no matching ancestor exists
/// or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_commit>> , ffi.Pointer<git_commit> , ffi.UnsignedInt )>()
external int git_commit_nth_gen_ancestor(ffi.Pointer<ffi.Pointer<git_commit>> ancestor,
ffi.Pointer<git_commit> commit,
int n,
);

/// Get an arbitrary header field
/// 
/// @param out the buffer to fill; existing content will be
/// overwritten
/// @param commit the commit to look in
/// @param field the header field to return
/// @return 0 on succeess, GIT_ENOTFOUND if the field does not exist,
/// or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_commit> , ffi.Pointer<ffi.Char> )>()
external int git_commit_header_field(ffi.Pointer<git_buf> out,
ffi.Pointer<git_commit> commit,
ffi.Pointer<ffi.Char> field,
);

/// Extract the signature from a commit
/// 
/// If the id is not for a commit, the error class will be
/// `GIT_ERROR_INVALID`. If the commit does not have a signature, the
/// error class will be `GIT_ERROR_OBJECT`.
/// 
/// @param signature the signature block; existing content will be
/// overwritten
/// @param signed_data signed data; this is the commit contents minus the signature block;
/// existing content will be overwritten
/// @param repo the repository in which the commit exists
/// @param commit_id the commit from which to extract the data
/// @param field the name of the header field containing the signature
/// block; pass `NULL` to extract the default 'gpgsig'
/// @return 0 on success, GIT_ENOTFOUND if the id is not for a commit
/// or the commit does not have a signature.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_buf> , ffi.Pointer<git_repository> , ffi.Pointer<git_oid> , ffi.Pointer<ffi.Char> )>()
external int git_commit_extract_signature(ffi.Pointer<git_buf> signature,
ffi.Pointer<git_buf> signed_data,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_oid> commit_id,
ffi.Pointer<ffi.Char> field,
);

/// Create new commit in the repository from a list of `git_object` pointers
/// 
/// The message will **not** be cleaned up automatically. You can do that
/// with the `git_message_prettify()` function.
/// 
/// @param id Pointer in which to store the OID of the newly created commit
/// 
/// @param repo Repository where to store the commit
/// 
/// @param update_ref If not NULL, name of the reference that
/// will be updated to point to this commit. If the reference
/// is not direct, it will be resolved to a direct reference.
/// Use "HEAD" to update the HEAD of the current branch and
/// make it point to this commit. If the reference doesn't
/// exist yet, it will be created. If it does exist, the first
/// parent must be the tip of this branch.
/// 
/// @param author Signature with author and author time of commit
/// 
/// @param committer Signature with committer and * commit time of commit
/// 
/// @param message_encoding The encoding for the message in the
/// commit, represented with a standard encoding name.
/// E.g. "UTF-8". If NULL, no encoding header is written and
/// UTF-8 is assumed.
/// 
/// @param message Full message for this commit
/// 
/// @param tree An instance of a `git_tree` object that will
/// be used as the tree for the commit. This tree object must
/// also be owned by the given `repo`.
/// 
/// @param parent_count Number of parents for this commit
/// 
/// @param parents Array of `parent_count` pointers to `git_commit`
/// objects that will be used as the parents for this commit. This
/// array may be NULL if `parent_count` is 0 (root commit). All the
/// given commits must be owned by the `repo`.
/// 
/// @return 0 or an error code
/// The created commit will be written to the Object Database and
/// the given reference will be updated to point to it
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_signature> , ffi.Pointer<git_signature> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_tree> , ffi.Size , ffi.Pointer<ffi.Pointer<git_commit>> )>()
external int git_commit_create(ffi.Pointer<git_oid> id,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> update_ref,
ffi.Pointer<git_signature> author,
ffi.Pointer<git_signature> committer,
ffi.Pointer<ffi.Char> message_encoding,
ffi.Pointer<ffi.Char> message,
ffi.Pointer<git_tree> tree,
int parent_count,
ffi.Pointer<ffi.Pointer<git_commit>> parents,
);

/// Create new commit in the repository using a variable argument list.
/// 
/// The message will **not** be cleaned up automatically. You can do that
/// with the `git_message_prettify()` function.
/// 
/// The parents for the commit are specified as a variable list of pointers
/// to `const git_commit *`. Note that this is a convenience method which may
/// not be safe to export for certain languages or compilers
/// 
/// All other parameters remain the same as `git_commit_create()`.
/// 
/// @param id Pointer in which to store the OID of the newly created commit
/// 
/// @param repo Repository where to store the commit
/// 
/// @param update_ref If not NULL, name of the reference that
/// will be updated to point to this commit. If the reference
/// is not direct, it will be resolved to a direct reference.
/// Use "HEAD" to update the HEAD of the current branch and
/// make it point to this commit. If the reference doesn't
/// exist yet, it will be created. If it does exist, the first
/// parent must be the tip of this branch.
/// 
/// @param author Signature with author and author time of commit
/// 
/// @param committer Signature with committer and * commit time of commit
/// 
/// @param message_encoding The encoding for the message in the
/// commit, represented with a standard encoding name.
/// E.g. "UTF-8". If NULL, no encoding header is written and
/// UTF-8 is assumed.
/// 
/// @param message Full message for this commit
/// 
/// @param tree An instance of a `git_tree` object that will
/// be used as the tree for the commit. This tree object must
/// also be owned by the given `repo`.
/// 
/// @param parent_count Number of parents for this commit
/// 
/// @return 0 or an error code
/// The created commit will be written to the Object Database and
/// the given reference will be updated to point to it
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_signature> , ffi.Pointer<git_signature> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_tree> , ffi.Size )>()
external int git_commit_create_v(ffi.Pointer<git_oid> id,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> update_ref,
ffi.Pointer<git_signature> author,
ffi.Pointer<git_signature> committer,
ffi.Pointer<ffi.Char> message_encoding,
ffi.Pointer<ffi.Char> message,
ffi.Pointer<git_tree> tree,
int parent_count,
);

/// Commits the staged changes in the repository; this is a near analog to
/// `git commit -m message`.
/// 
/// By default, empty commits are not allowed.
/// 
/// @param id pointer to store the new commit's object id
/// @param repo repository to commit changes in
/// @param message the commit message
/// @param opts options for creating the commit
/// @return 0 on success, GIT_EUNCHANGED if there were no changes to commit, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_commit_create_options> )>()
external int git_commit_create_from_stage(ffi.Pointer<git_oid> id,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> message,
ffi.Pointer<git_commit_create_options> opts,
);

/// Amend an existing commit by replacing only non-NULL values.
/// 
/// This creates a new commit that is exactly the same as the old commit,
/// except that any non-NULL values will be updated.  The new commit has
/// the same parents as the old commit.
/// 
/// The `update_ref` value works as in the regular `git_commit_create()`,
/// updating the ref to point to the newly rewritten commit.  If you want
/// to amend a commit that is not currently the tip of the branch and then
/// rewrite the following commits to reach a ref, pass this as NULL and
/// update the rest of the commit chain and ref separately.
/// 
/// Unlike `git_commit_create()`, the `author`, `committer`, `message`,
/// `message_encoding`, and `tree` parameters can be NULL in which case this
/// will use the values from the original `commit_to_amend`.
/// 
/// All parameters have the same meanings as in `git_commit_create()`.
/// 
/// @param id Pointer in which to store the OID of the newly created commit
/// 
/// @param commit_to_amend The commit to amend
/// 
/// @param update_ref If not NULL, name of the reference that
/// will be updated to point to this commit. If the reference
/// is not direct, it will be resolved to a direct reference.
/// Use "HEAD" to update the HEAD of the current branch and
/// make it point to this commit. If the reference doesn't
/// exist yet, it will be created. If it does exist, the first
/// parent must be the tip of this branch.
/// 
/// @param author Signature with author and author time of commit
/// 
/// @param committer Signature with committer and * commit time of commit
/// 
/// @param message_encoding The encoding for the message in the
/// commit, represented with a standard encoding name.
/// E.g. "UTF-8". If NULL, no encoding header is written and
/// UTF-8 is assumed.
/// 
/// @param message Full message for this commit
/// 
/// @param tree An instance of a `git_tree` object that will
/// be used as the tree for the commit. This tree object must
/// also be owned by the given `repo`.
/// 
/// @return 0 or an error code
/// The created commit will be written to the Object Database and
/// the given reference will be updated to point to it
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_commit> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_signature> , ffi.Pointer<git_signature> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_tree> )>()
external int git_commit_amend(ffi.Pointer<git_oid> id,
ffi.Pointer<git_commit> commit_to_amend,
ffi.Pointer<ffi.Char> update_ref,
ffi.Pointer<git_signature> author,
ffi.Pointer<git_signature> committer,
ffi.Pointer<ffi.Char> message_encoding,
ffi.Pointer<ffi.Char> message,
ffi.Pointer<git_tree> tree,
);

/// Create a commit and write it into a buffer
/// 
/// Create a commit as with `git_commit_create()` but instead of
/// writing it to the objectdb, write the contents of the object into a
/// buffer.
/// 
/// @param out the buffer into which to write the commit object content
/// 
/// @param repo Repository where the referenced tree and parents live
/// 
/// @param author Signature with author and author time of commit
/// 
/// @param committer Signature with committer and * commit time of commit
/// 
/// @param message_encoding The encoding for the message in the
/// commit, represented with a standard encoding name.
/// E.g. "UTF-8". If NULL, no encoding header is written and
/// UTF-8 is assumed.
/// 
/// @param message Full message for this commit
/// 
/// @param tree An instance of a `git_tree` object that will
/// be used as the tree for the commit. This tree object must
/// also be owned by the given `repo`.
/// 
/// @param parent_count Number of parents for this commit
/// 
/// @param parents Array of `parent_count` pointers to `git_commit`
/// objects that will be used as the parents for this commit. This
/// array may be NULL if `parent_count` is 0 (root commit). All the
/// given commits must be owned by the `repo`.
/// 
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_repository> , ffi.Pointer<git_signature> , ffi.Pointer<git_signature> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_tree> , ffi.Size , ffi.Pointer<ffi.Pointer<git_commit>> )>()
external int git_commit_create_buffer(ffi.Pointer<git_buf> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_signature> author,
ffi.Pointer<git_signature> committer,
ffi.Pointer<ffi.Char> message_encoding,
ffi.Pointer<ffi.Char> message,
ffi.Pointer<git_tree> tree,
int parent_count,
ffi.Pointer<ffi.Pointer<git_commit>> parents,
);

/// Create a commit object from the given buffer and signature
/// 
/// Given the unsigned commit object's contents, its signature and the
/// header field in which to store the signature, attach the signature
/// to the commit and write it into the given repository.
/// 
/// @param out the resulting commit id
/// @param repo the repository to create the commit in.
/// @param commit_content the content of the unsigned commit object
/// @param signature the signature to add to the commit. Leave `NULL`
/// to create a commit without adding a signature field.
/// @param signature_field which header field should contain this
/// signature. Leave `NULL` for the default of "gpgsig"
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_commit_create_with_signature(ffi.Pointer<git_oid> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> commit_content,
ffi.Pointer<ffi.Char> signature,
ffi.Pointer<ffi.Char> signature_field,
);

/// Create an in-memory copy of a commit. The copy must be explicitly
/// free'd or it will leak.
/// 
/// @param out Pointer to store the copy of the commit
/// @param source Original commit to copy
/// @return 0
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_commit>> , ffi.Pointer<git_commit> )>()
external int git_commit_dup(ffi.Pointer<ffi.Pointer<git_commit>> out,
ffi.Pointer<git_commit> source,
);

/// Free the commits contained in a commit array.  This method should
/// be called on `git_commitarray` objects that were provided by the
/// library.  Not doing so will result in a memory leak.
/// 
/// This does not free the `git_commitarray` itself, since the library
/// will never allocate that object directly itself.
/// 
/// @param array The git_commitarray that contains commits to free
@ffi.Native<ffi.Void Function(ffi.Pointer<git_commitarray> )>()
external void git_commitarray_dispose(ffi.Pointer<git_commitarray> array,
);

/// Open a git repository.
/// 
/// The 'path' argument must point to either a git repository
/// folder, or an existing work dir.
/// 
/// The method will automatically detect if 'path' is a normal
/// or bare repository or fail is 'path' is neither.
/// 
/// Note that the libgit2 library _must_ be initialized using
/// `git_libgit2_init` before any APIs can be called, including
/// this one.
/// 
/// @param[out] out pointer to the repo which will be opened
/// @param path the path to the repository
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>> , ffi.Pointer<ffi.Char> )>()
external int git_repository_open(ffi.Pointer<ffi.Pointer<git_repository>> out,
ffi.Pointer<ffi.Char> path,
);

/// Open working tree as a repository
/// 
/// Open the working directory of the working tree as a normal
/// repository that can then be worked on.
/// 
/// @param out Output pointer containing opened repository
/// @param wt Working tree to open
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>> , ffi.Pointer<git_worktree> )>()
external int git_repository_open_from_worktree(ffi.Pointer<ffi.Pointer<git_repository>> out,
ffi.Pointer<git_worktree> wt,
);

/// Create a "fake" repository to wrap an object database
/// 
/// Create a repository object to wrap an object database to be used
/// with the API when all you have is an object database. This doesn't
/// have any paths associated with it, so use with care.
/// 
/// @param out pointer to the repo
/// @param odb the object database to wrap
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>> , ffi.Pointer<git_odb> )>()
external int git_repository_wrap_odb(ffi.Pointer<ffi.Pointer<git_repository>> out,
ffi.Pointer<git_odb> odb,
);

/// Look for a git repository and copy its path in the given buffer.
/// The lookup start from base_path and walk across parent directories
/// if nothing has been found. The lookup ends when the first repository
/// is found, or when reaching a directory referenced in ceiling_dirs
/// or when the filesystem changes (in case across_fs is true).
/// 
/// The method will automatically detect if the repository is bare
/// (if there is a repository).
/// 
/// Note that the libgit2 library _must_ be initialized using
/// `git_libgit2_init` before any APIs can be called, including
/// this one.
/// 
/// @param out A pointer to a user-allocated git_buf which will contain
/// the found path.
/// 
/// @param start_path The base path where the lookup starts.
/// 
/// @param across_fs If true, then the lookup will not stop when a
/// filesystem device change is detected while exploring parent directories.
/// 
/// @param ceiling_dirs A GIT_PATH_LIST_SEPARATOR separated list of
/// absolute symbolic link free paths. The lookup will stop when any
/// of this paths is reached. Note that the lookup always performs on
/// start_path no matter start_path appears in ceiling_dirs ceiling_dirs
/// might be NULL (which is equivalent to an empty string)
/// 
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<ffi.Char> , ffi.Int , ffi.Pointer<ffi.Char> )>()
external int git_repository_discover(ffi.Pointer<git_buf> out,
ffi.Pointer<ffi.Char> start_path,
int across_fs,
ffi.Pointer<ffi.Char> ceiling_dirs,
);

/// Find and open a repository with extended controls.
/// 
/// Note that the libgit2 library _must_ be initialized using
/// `git_libgit2_init` before any APIs can be called, including
/// this one.
/// 
/// @param[out] out Pointer to the repo which will be opened.  This can
/// actually be NULL if you only want to use the error code to
/// see if a repo at this path could be opened.
/// @param path Path to open as git repository.  If the flags
/// permit "searching", then this can be a path to a subdirectory
/// inside the working directory of the repository. May be NULL if
/// flags is GIT_REPOSITORY_OPEN_FROM_ENV.
/// @param flags A combination of the GIT_REPOSITORY_OPEN flags above.
/// @param ceiling_dirs A GIT_PATH_LIST_SEPARATOR delimited list of path
/// prefixes at which the search for a containing repository should
/// terminate.
/// @return 0 on success, GIT_ENOTFOUND if no repository could be found,
/// or -1 if there was a repository but open failed for some reason
/// (such as repo corruption or system errors).
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>> , ffi.Pointer<ffi.Char> , ffi.UnsignedInt , ffi.Pointer<ffi.Char> )>()
external int git_repository_open_ext(ffi.Pointer<ffi.Pointer<git_repository>> out,
ffi.Pointer<ffi.Char> path,
int flags,
ffi.Pointer<ffi.Char> ceiling_dirs,
);

/// Open a bare repository on the serverside.
/// 
/// This is a fast open for bare repositories that will come in handy
/// if you're e.g. hosting git repositories and need to access them
/// efficiently
/// 
/// Note that the libgit2 library _must_ be initialized using
/// `git_libgit2_init` before any APIs can be called, including
/// this one.
/// 
/// @param[out] out Pointer to the repo which will be opened.
/// @param bare_path Direct path to the bare repository
/// @return 0 on success, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>> , ffi.Pointer<ffi.Char> )>()
external int git_repository_open_bare(ffi.Pointer<ffi.Pointer<git_repository>> out,
ffi.Pointer<ffi.Char> bare_path,
);

/// Free a previously allocated repository
/// 
/// Note that after a repository is free'd, all the objects it has spawned
/// will still exist until they are manually closed by the user
/// with `git_object_free`, but accessing any of the attributes of
/// an object without a backing repository will result in undefined
/// behavior
/// 
/// @param repo repository handle to close. If NULL nothing occurs.
@ffi.Native<ffi.Void Function(ffi.Pointer<git_repository> )>()
external void git_repository_free(ffi.Pointer<git_repository> repo,
);

/// Creates a new Git repository in the given folder.
/// 
/// TODO:
/// - Reinit the repository
/// 
/// Note that the libgit2 library _must_ be initialized using
/// `git_libgit2_init` before any APIs can be called, including
/// this one.
/// 
/// @param[out] out pointer to the repo which will be created or reinitialized
/// @param path the path to the repository
/// @param is_bare if true, a Git repository without a working directory is
/// created at the pointed path. If false, provided path will be
/// considered as the working directory into which the .git directory
/// will be created.
/// 
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>> , ffi.Pointer<ffi.Char> , ffi.UnsignedInt )>()
external int git_repository_init(ffi.Pointer<ffi.Pointer<git_repository>> out,
ffi.Pointer<ffi.Char> path,
int is_bare,
);

/// Initialize git_repository_init_options structure
/// 
/// Initializes a `git_repository_init_options` with default values. Equivalent to
/// creating an instance with `GIT_REPOSITORY_INIT_OPTIONS_INIT`.
/// 
/// @param opts The `git_repository_init_options` struct to initialize.
/// @param version The struct version; pass `GIT_REPOSITORY_INIT_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository_init_options> , ffi.UnsignedInt )>()
external int git_repository_init_options_init(ffi.Pointer<git_repository_init_options> opts,
int version,
);

/// Create a new Git repository in the given folder with extended controls.
/// 
/// This will initialize a new git repository (creating the repo_path
/// if requested by flags) and working directory as needed.  It will
/// auto-detect the case sensitivity of the file system and if the
/// file system supports file mode bits correctly.
/// 
/// Note that the libgit2 library _must_ be initialized using
/// `git_libgit2_init` before any APIs can be called, including
/// this one.
/// 
/// @param out Pointer to the repo which will be created or reinitialized.
/// @param repo_path The path to the repository.
/// @param opts Pointer to git_repository_init_options struct.
/// @return 0 or an error code on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_repository_init_options> )>()
external int git_repository_init_ext(ffi.Pointer<ffi.Pointer<git_repository>> out,
ffi.Pointer<ffi.Char> repo_path,
ffi.Pointer<git_repository_init_options> opts,
);

/// Retrieve and resolve the reference pointed at by HEAD.
/// 
/// The returned `git_reference` will be owned by caller and
/// `git_reference_free()` must be called when done with it to release the
/// allocated memory and prevent a leak.
/// 
/// @param[out] out pointer to the reference which will be retrieved
/// @param repo a repository object
/// 
/// @return 0 on success, GIT_EUNBORNBRANCH when HEAD points to a non existing
/// branch, GIT_ENOTFOUND when HEAD is missing; an error code otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>> , ffi.Pointer<git_repository> )>()
external int git_repository_head(ffi.Pointer<ffi.Pointer<git_reference>> out,
ffi.Pointer<git_repository> repo,
);

/// Retrieve the referenced HEAD for the worktree
/// 
/// @param out pointer to the reference which will be retrieved
/// @param repo a repository object
/// @param name name of the worktree to retrieve HEAD for
/// @return 0 when successful, error-code otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_repository_head_for_worktree(ffi.Pointer<ffi.Pointer<git_reference>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
);

/// Check if a repository's HEAD is detached
/// 
/// A repository's HEAD is detached when it points directly to a commit
/// instead of a branch.
/// 
/// @param repo Repo to test
/// @return 1 if HEAD is detached, 0 if it's not; error code if there
/// was an error.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> )>()
external int git_repository_head_detached(ffi.Pointer<git_repository> repo,
);

/// Check if a worktree's HEAD is detached
/// 
/// A worktree's HEAD is detached when it points directly to a
/// commit instead of a branch.
/// 
/// @param repo a repository object
/// @param name name of the worktree to retrieve HEAD for
/// @return 1 if HEAD is detached, 0 if its not; error code if
/// there was an error
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_repository_head_detached_for_worktree(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
);

/// Check if the current branch is unborn
/// 
/// An unborn branch is one named from HEAD but which doesn't exist in
/// the refs namespace, because it doesn't have any commit to point to.
/// 
/// @param repo Repo to test
/// @return 1 if the current branch is unborn, 0 if it's not; error
/// code if there was an error
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> )>()
external int git_repository_head_unborn(ffi.Pointer<git_repository> repo,
);

/// Check if a repository is empty
/// 
/// An empty repository has just been initialized and contains no references
/// apart from HEAD, which must be pointing to the unborn master branch,
/// or the branch specified for the repository in the `init.defaultBranch`
/// configuration variable.
/// 
/// @param repo Repo to test
/// @return 1 if the repository is empty, 0 if it isn't, error code
/// if the repository is corrupted
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> )>()
external int git_repository_is_empty(ffi.Pointer<git_repository> repo,
);

/// Get the location of a specific repository file or directory
/// 
/// This function will retrieve the path of a specific repository
/// item. It will thereby honor things like the repository's
/// common directory, gitdir, etc. In case a file path cannot
/// exist for a given item (e.g. the working directory of a bare
/// repository), GIT_ENOTFOUND is returned.
/// 
/// @param out Buffer to store the path at
/// @param repo Repository to get path for
/// @param item The repository item for which to retrieve the path
/// @return 0, GIT_ENOTFOUND if the path cannot exist or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_repository> , ffi.UnsignedInt )>(symbol: 'git_repository_item_path')
external int _git_repository_item_path(ffi.Pointer<git_buf> out,
ffi.Pointer<git_repository> repo,
int item,
);

int git_repository_item_path(ffi.Pointer<git_buf> out,
ffi.Pointer<git_repository> repo,
git_repository_item_t item,
) => _git_repository_item_path(out,
repo,
item.value,
);

/// Get the path of this repository
/// 
/// This is the path of the `.git` folder for normal repositories,
/// or of the repository itself for bare repositories.
/// 
/// @param repo A repository object
/// @return the path to the repository
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_repository> )>()
external ffi.Pointer<ffi.Char> git_repository_path(ffi.Pointer<git_repository> repo,
);

/// Get the path of the working directory for this repository
/// 
/// If the repository is bare, this function will always return
/// NULL.
/// 
/// @param repo A repository object
/// @return the path to the working dir, if it exists
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_repository> )>()
external ffi.Pointer<ffi.Char> git_repository_workdir(ffi.Pointer<git_repository> repo,
);

/// Get the path of the shared common directory for this repository.
/// 
/// If the repository is bare, it is the root directory for the repository.
/// If the repository is a worktree, it is the parent repo's gitdir.
/// Otherwise, it is the gitdir.
/// 
/// @param repo A repository object
/// @return the path to the common dir
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_repository> )>()
external ffi.Pointer<ffi.Char> git_repository_commondir(ffi.Pointer<git_repository> repo,
);

/// Set the path to the working directory for this repository
/// 
/// The working directory doesn't need to be the same one
/// that contains the `.git` folder for this repository.
/// 
/// If this repository is bare, setting its working directory
/// will turn it into a normal repository, capable of performing
/// all the common workdir operations (checkout, status, index
/// manipulation, etc).
/// 
/// @param repo A repository object
/// @param workdir The path to a working directory
/// @param update_gitlink Create/update gitlink in workdir and set config
/// "core.worktree" (if workdir is not the parent of the .git directory)
/// @return 0, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Int )>()
external int git_repository_set_workdir(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> workdir,
int update_gitlink,
);

/// Check if a repository is bare
/// 
/// @param repo Repo to test
/// @return 1 if the repository is bare, 0 otherwise.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> )>()
external int git_repository_is_bare(ffi.Pointer<git_repository> repo,
);

/// Check if a repository is a linked work tree
/// 
/// @param repo Repo to test
/// @return 1 if the repository is a linked work tree, 0 otherwise.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> )>()
external int git_repository_is_worktree(ffi.Pointer<git_repository> repo,
);

/// Get the configuration file for this repository.
/// 
/// If a configuration file has not been set, the default
/// config set for the repository will be returned, including
/// global and system configurations (if they are available).
/// 
/// The configuration file must be freed once it's no longer
/// being used by the user.
/// 
/// @param out Pointer to store the loaded configuration
/// @param repo A repository object
/// @return 0, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config>> , ffi.Pointer<git_repository> )>()
external int git_repository_config(ffi.Pointer<ffi.Pointer<git_config>> out,
ffi.Pointer<git_repository> repo,
);

/// Get a snapshot of the repository's configuration
/// 
/// Convenience function to take a snapshot from the repository's
/// configuration.  The contents of this snapshot will not change,
/// even if the underlying config files are modified.
/// 
/// The configuration file must be freed once it's no longer
/// being used by the user.
/// 
/// @param out Pointer to store the loaded configuration
/// @param repo the repository
/// @return 0, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config>> , ffi.Pointer<git_repository> )>()
external int git_repository_config_snapshot(ffi.Pointer<ffi.Pointer<git_config>> out,
ffi.Pointer<git_repository> repo,
);

/// Get the Object Database for this repository.
/// 
/// If a custom ODB has not been set, the default
/// database for the repository will be returned (the one
/// located in `.git/objects`).
/// 
/// The ODB must be freed once it's no longer being used by
/// the user.
/// 
/// @param[out] out Pointer to store the loaded ODB
/// @param repo A repository object
/// @return 0, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb>> , ffi.Pointer<git_repository> )>()
external int git_repository_odb(ffi.Pointer<ffi.Pointer<git_odb>> out,
ffi.Pointer<git_repository> repo,
);

/// Get the Reference Database Backend for this repository.
/// 
/// If a custom refsdb has not been set, the default database for
/// the repository will be returned (the one that manipulates loose
/// and packed references in the `.git` directory).
/// 
/// The refdb must be freed once it's no longer being used by
/// the user.
/// 
/// @param[out] out Pointer to store the loaded refdb
/// @param repo A repository object
/// @return 0, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_refdb>> , ffi.Pointer<git_repository> )>()
external int git_repository_refdb(ffi.Pointer<ffi.Pointer<git_refdb>> out,
ffi.Pointer<git_repository> repo,
);

/// Get the Index file for this repository.
/// 
/// If a custom index has not been set, the default
/// index for the repository will be returned (the one
/// located in `.git/index`).
/// 
/// The index must be freed once it's no longer being used by
/// the user.
/// 
/// @param[out] out Pointer to store the loaded index
/// @param repo A repository object
/// @return 0, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index>> , ffi.Pointer<git_repository> )>()
external int git_repository_index(ffi.Pointer<ffi.Pointer<git_index>> out,
ffi.Pointer<git_repository> repo,
);

/// Retrieve git's prepared message
/// 
/// Operations such as git revert/cherry-pick/merge with the -n option
/// stop just short of creating a commit with the changes and save
/// their prepared message in .git/MERGE_MSG so the next git-commit
/// execution can present it to the user for them to amend if they
/// wish.
/// 
/// Use this function to get the contents of this file. Don't forget to
/// remove the file after you create the commit.
/// 
/// @param out git_buf to write data into
/// @param repo Repository to read prepared message from
/// @return 0, GIT_ENOTFOUND if no message exists or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_repository> )>()
external int git_repository_message(ffi.Pointer<git_buf> out,
ffi.Pointer<git_repository> repo,
);

/// Remove git's prepared message.
/// 
/// Remove the message that `git_repository_message` retrieves.
/// 
/// @param repo Repository to remove prepared message from.
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> )>()
external int git_repository_message_remove(ffi.Pointer<git_repository> repo,
);

/// Remove all the metadata associated with an ongoing command like merge,
/// revert, cherry-pick, etc.  For example: MERGE_HEAD, MERGE_MSG, etc.
/// 
/// @param repo A repository object
/// @return 0 on success, or error
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> )>()
external int git_repository_state_cleanup(ffi.Pointer<git_repository> repo,
);

/// Invoke 'callback' for each entry in the given FETCH_HEAD file.
/// 
/// Return a non-zero value from the callback to stop the loop.
/// 
/// @param repo A repository object
/// @param callback Callback function
/// @param payload Pointer to callback data (optional)
/// @return 0 on success, non-zero callback return value, GIT_ENOTFOUND if
/// there is no FETCH_HEAD file, or other error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> ref_name, ffi.Pointer<ffi.Char> remote_url, ffi.Pointer<git_oid> oid, ffi.UnsignedInt is_merge, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_repository_fetchhead_foreach(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> ref_name, ffi.Pointer<ffi.Char> remote_url, ffi.Pointer<git_oid> oid, ffi.UnsignedInt is_merge, ffi.Pointer<ffi.Void> payload)>> callback,
ffi.Pointer<ffi.Void> payload,
);

/// If a merge is in progress, invoke 'callback' for each commit ID in the
/// MERGE_HEAD file.
/// 
/// Return a non-zero value from the callback to stop the loop.
/// 
/// @param repo A repository object
/// @param callback Callback function
/// @param payload Pointer to callback data (optional)
/// @return 0 on success, non-zero callback return value, GIT_ENOTFOUND if
/// there is no MERGE_HEAD file, or other error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_oid> oid, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_repository_mergehead_foreach(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_oid> oid, ffi.Pointer<ffi.Void> payload)>> callback,
ffi.Pointer<ffi.Void> payload,
);

/// Calculate hash of file using repository filtering rules.
/// 
/// If you simply want to calculate the hash of a file on disk with no filters,
/// you can just use the `git_odb_hashfile()` API.  However, if you want to
/// hash a file in the repository and you want to apply filtering rules (e.g.
/// crlf filters) before generating the SHA, then use this function.
/// 
/// Note: if the repository has `core.safecrlf` set to fail and the
/// filtering triggers that failure, then this function will return an
/// error and not calculate the hash of the file.
/// 
/// @param out Output value of calculated SHA
/// @param repo Repository pointer
/// @param path Path to file on disk whose contents should be hashed.  This
/// may be an absolute path or a relative path, in which case it
/// will be treated as a path within the working directory.
/// @param type The object type to hash as (e.g. GIT_OBJECT_BLOB)
/// @param as_path The path to use to look up filtering rules. If this is
/// an empty string then no filters will be applied when
/// calculating the hash. If this is `NULL` and the `path`
/// parameter is a file within the repository's working
/// directory, then the `path` will be used.
/// @return 0 on success, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Int , ffi.Pointer<ffi.Char> )>(symbol: 'git_repository_hashfile')
external int _git_repository_hashfile(ffi.Pointer<git_oid> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> path,
int type,
ffi.Pointer<ffi.Char> as_path,
);

int git_repository_hashfile(ffi.Pointer<git_oid> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> path,
git_object_t type,
ffi.Pointer<ffi.Char> as_path,
) => _git_repository_hashfile(out,
repo,
path,
type.value,
as_path,
);

/// Make the repository HEAD point to the specified reference.
/// 
/// If the provided reference points to a Tree or a Blob, the HEAD is
/// unaltered and -1 is returned.
/// 
/// If the provided reference points to a branch, the HEAD will point
/// to that branch, staying attached, or become attached if it isn't yet.
/// If the branch doesn't exist yet, no error will be return. The HEAD
/// will then be attached to an unborn branch.
/// 
/// Otherwise, the HEAD will be detached and will directly point to
/// the Commit.
/// 
/// @param repo Repository pointer
/// @param refname Canonical name of the reference the HEAD should point at
/// @return 0 on success, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_repository_set_head(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> refname,
);

/// Make the repository HEAD directly point to the Commit.
/// 
/// If the provided committish cannot be found in the repository, the HEAD
/// is unaltered and GIT_ENOTFOUND is returned.
/// 
/// If the provided committish cannot be peeled into a commit, the HEAD
/// is unaltered and -1 is returned.
/// 
/// Otherwise, the HEAD will eventually be detached and will directly point to
/// the peeled Commit.
/// 
/// @param repo Repository pointer
/// @param committish Object id of the Commit the HEAD should point to
/// @return 0 on success, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<git_oid> )>()
external int git_repository_set_head_detached(ffi.Pointer<git_repository> repo,
ffi.Pointer<git_oid> committish,
);

/// Make the repository HEAD directly point to the Commit.
/// 
/// This behaves like `git_repository_set_head_detached()` but takes an
/// annotated commit, which lets you specify which extended sha syntax
/// string was specified by a user, allowing for more exact reflog
/// messages.
/// 
/// See the documentation for `git_repository_set_head_detached()`.
/// 
/// @param repo Repository pointer
/// @param committish annotated commit to point HEAD to
/// @return 0 on success, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<git_annotated_commit> )>()
external int git_repository_set_head_detached_from_annotated(ffi.Pointer<git_repository> repo,
ffi.Pointer<git_annotated_commit> committish,
);

/// Detach the HEAD.
/// 
/// If the HEAD is already detached and points to a Commit, 0 is returned.
/// 
/// If the HEAD is already detached and points to a Tag, the HEAD is
/// updated into making it point to the peeled Commit, and 0 is returned.
/// 
/// If the HEAD is already detached and points to a non committish, the HEAD is
/// unaltered, and -1 is returned.
/// 
/// Otherwise, the HEAD will be detached and point to the peeled Commit.
/// 
/// @param repo Repository pointer
/// @return 0 on success, GIT_EUNBORNBRANCH when HEAD points to a non existing
/// branch or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> )>()
external int git_repository_detach_head(ffi.Pointer<git_repository> repo,
);

/// Determines the status of a git repository - ie, whether an operation
/// (merge, cherry-pick, etc) is in progress.
/// 
/// @param repo Repository pointer
/// @return The state of the repository
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> )>()
external int git_repository_state(ffi.Pointer<git_repository> repo,
);

/// Sets the active namespace for this Git Repository
/// 
/// This namespace affects all reference operations for the repo.
/// See `man gitnamespaces`
/// 
/// @param repo The repo
/// @param nmspace The namespace. This should not include the refs
/// folder, e.g. to namespace all references under `refs/namespaces/foo/`,
/// use `foo` as the namespace.
/// @return 0 on success, -1 on error
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_repository_set_namespace(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> nmspace,
);

/// Get the currently active namespace for this repository
/// 
/// @param repo The repo
/// @return the active namespace, or NULL if there isn't one
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_repository> )>()
external ffi.Pointer<ffi.Char> git_repository_get_namespace(ffi.Pointer<git_repository> repo,
);

/// Determine if the repository was a shallow clone
/// 
/// @param repo The repository
/// @return 1 if shallow, zero if not
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> )>()
external int git_repository_is_shallow(ffi.Pointer<git_repository> repo,
);

/// Retrieve the configured identity to use for reflogs
/// 
/// The memory is owned by the repository and must not be freed by the
/// user.
/// 
/// @param[out] name where to store the pointer to the name
/// @param[out] email where to store the pointer to the email
/// @param repo the repository
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>> , ffi.Pointer<ffi.Pointer<ffi.Char>> , ffi.Pointer<git_repository> )>()
external int git_repository_ident(ffi.Pointer<ffi.Pointer<ffi.Char>> name,
ffi.Pointer<ffi.Pointer<ffi.Char>> email,
ffi.Pointer<git_repository> repo,
);

/// Set the identity to be used for writing reflogs
/// 
/// If both are set, this name and email will be used to write to the
/// reflog. Pass NULL to unset. When unset, the identity will be taken
/// from the repository's configuration.
/// 
/// @param repo the repository to configure
/// @param name the name to use for the reflog entries
/// @param email the email to use for the reflog entries
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_repository_set_ident(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
ffi.Pointer<ffi.Char> email,
);

/// Gets the object type used by this repository.
/// 
/// @param repo the repository
/// @return the object id type
@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<git_repository> )>(symbol: 'git_repository_oid_type')
external int _git_repository_oid_type(ffi.Pointer<git_repository> repo,
);

git_oid_t git_repository_oid_type(ffi.Pointer<git_repository> repo,
) => git_oid_t.fromValue(_git_repository_oid_type(repo,
));

/// Gets the parents of the next commit, given the current repository state.
/// Generally, this is the HEAD commit, except when performing a merge, in
/// which case it is two or more commits.
/// 
/// @param commits a `git_commitarray` that will contain the commit parents
/// @param repo the repository
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_commitarray> , ffi.Pointer<git_repository> )>()
external int git_repository_commit_parents(ffi.Pointer<git_commitarray> commits,
ffi.Pointer<git_repository> repo,
);

/// Creates a `git_annotated_commit` from the given reference.
/// The resulting git_annotated_commit must be freed with
/// `git_annotated_commit_free`.
/// 
/// @param[out] out pointer to store the git_annotated_commit result in
/// @param repo repository that contains the given reference
/// @param ref reference to use to lookup the git_annotated_commit
/// @return 0 on success or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_annotated_commit>> , ffi.Pointer<git_repository> , ffi.Pointer<git_reference> )>()
external int git_annotated_commit_from_ref(ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_reference> ref,
);

/// Creates a `git_annotated_commit` from the given fetch head data.
/// The resulting git_annotated_commit must be freed with
/// `git_annotated_commit_free`.
/// 
/// @param[out] out pointer to store the git_annotated_commit result in
/// @param repo repository that contains the given commit
/// @param branch_name name of the (remote) branch
/// @param remote_url url of the remote
/// @param id the commit object id of the remote branch
/// @return 0 on success or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_annotated_commit>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_oid> )>()
external int git_annotated_commit_from_fetchhead(ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> branch_name,
ffi.Pointer<ffi.Char> remote_url,
ffi.Pointer<git_oid> id,
);

/// Creates a `git_annotated_commit` from the given commit id.
/// The resulting git_annotated_commit must be freed with
/// `git_annotated_commit_free`.
/// 
/// An annotated commit contains information about how it was
/// looked up, which may be useful for functions like merge or
/// rebase to provide context to the operation.  For example,
/// conflict files will include the name of the source or target
/// branches being merged.  It is therefore preferable to use the
/// most specific function (eg `git_annotated_commit_from_ref`)
/// instead of this one when that data is known.
/// 
/// @param[out] out pointer to store the git_annotated_commit result in
/// @param repo repository that contains the given commit
/// @param id the commit object id to lookup
/// @return 0 on success or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_annotated_commit>> , ffi.Pointer<git_repository> , ffi.Pointer<git_oid> )>()
external int git_annotated_commit_lookup(ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_oid> id,
);

/// Creates a `git_annotated_commit` from a revision string.
/// 
/// See `man gitrevisions`, or
/// http://git-scm.com/docs/git-rev-parse.html#_specifying_revisions for
/// information on the syntax accepted.
/// 
/// @param[out] out pointer to store the git_annotated_commit result in
/// @param repo repository that contains the given commit
/// @param revspec the extended sha syntax string to use to lookup the commit
/// @return 0 on success or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_annotated_commit>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_annotated_commit_from_revspec(ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> revspec,
);

/// Gets the commit ID that the given `git_annotated_commit` refers to.
/// 
/// @param commit the given annotated commit
/// @return commit id
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_annotated_commit> )>()
external ffi.Pointer<git_oid> git_annotated_commit_id(ffi.Pointer<git_annotated_commit> commit,
);

/// Get the refname that the given `git_annotated_commit` refers to.
/// 
/// @param commit the given annotated commit
/// @return ref name.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_annotated_commit> )>()
external ffi.Pointer<ffi.Char> git_annotated_commit_ref(ffi.Pointer<git_annotated_commit> commit,
);

/// Frees a `git_annotated_commit`.
/// 
/// @param commit annotated commit to free
@ffi.Native<ffi.Void Function(ffi.Pointer<git_annotated_commit> )>()
external void git_annotated_commit_free(ffi.Pointer<git_annotated_commit> commit,
);

/// Lookup a tree object from the repository.
/// 
/// @param[out] out Pointer to the looked up tree
/// @param repo The repo to use when locating the tree.
/// @param id Identity of the tree to locate.
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_tree>> , ffi.Pointer<git_repository> , ffi.Pointer<git_oid> )>()
external int git_tree_lookup(ffi.Pointer<ffi.Pointer<git_tree>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_oid> id,
);

/// Lookup a tree object from the repository,
/// given a prefix of its identifier (short id).
/// 
/// @see git_object_lookup_prefix
/// 
/// @param out pointer to the looked up tree
/// @param repo the repo to use when locating the tree.
/// @param id identity of the tree to locate.
/// @param len the length of the short identifier
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_tree>> , ffi.Pointer<git_repository> , ffi.Pointer<git_oid> , ffi.Size )>()
external int git_tree_lookup_prefix(ffi.Pointer<ffi.Pointer<git_tree>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_oid> id,
int len,
);

/// Close an open tree
/// 
/// You can no longer use the git_tree pointer after this call.
/// 
/// IMPORTANT: You MUST call this method when you stop using a tree to
/// release memory. Failure to do so will cause a memory leak.
/// 
/// @param tree The tree to close
@ffi.Native<ffi.Void Function(ffi.Pointer<git_tree> )>()
external void git_tree_free(ffi.Pointer<git_tree> tree,
);

/// Get the id of a tree.
/// 
/// @param tree a previously loaded tree.
/// @return object identity for the tree.
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_tree> )>()
external ffi.Pointer<git_oid> git_tree_id(ffi.Pointer<git_tree> tree,
);

/// Get the repository that contains the tree.
/// 
/// @param tree A previously loaded tree.
/// @return Repository that contains this tree.
@ffi.Native<ffi.Pointer<git_repository> Function(ffi.Pointer<git_tree> )>()
external ffi.Pointer<git_repository> git_tree_owner(ffi.Pointer<git_tree> tree,
);

/// Get the number of entries listed in a tree
/// 
/// @param tree a previously loaded tree.
/// @return the number of entries in the tree
@ffi.Native<ffi.Size Function(ffi.Pointer<git_tree> )>()
external int git_tree_entrycount(ffi.Pointer<git_tree> tree,
);

/// Lookup a tree entry by its filename
/// 
/// This returns a git_tree_entry that is owned by the git_tree.  You don't
/// have to free it, but you must not use it after the git_tree is released.
/// 
/// @param tree a previously loaded tree.
/// @param filename the filename of the desired entry
/// @return the tree entry; NULL if not found
@ffi.Native<ffi.Pointer<git_tree_entry> Function(ffi.Pointer<git_tree> , ffi.Pointer<ffi.Char> )>()
external ffi.Pointer<git_tree_entry> git_tree_entry_byname(ffi.Pointer<git_tree> tree,
ffi.Pointer<ffi.Char> filename,
);

/// Lookup a tree entry by its position in the tree
/// 
/// This returns a git_tree_entry that is owned by the git_tree.  You don't
/// have to free it, but you must not use it after the git_tree is released.
/// 
/// @param tree a previously loaded tree.
/// @param idx the position in the entry list
/// @return the tree entry; NULL if not found
@ffi.Native<ffi.Pointer<git_tree_entry> Function(ffi.Pointer<git_tree> , ffi.Size )>()
external ffi.Pointer<git_tree_entry> git_tree_entry_byindex(ffi.Pointer<git_tree> tree,
int idx,
);

/// Lookup a tree entry by SHA value.
/// 
/// This returns a git_tree_entry that is owned by the git_tree.  You don't
/// have to free it, but you must not use it after the git_tree is released.
/// 
/// Warning: this must examine every entry in the tree, so it is not fast.
/// 
/// @param tree a previously loaded tree.
/// @param id the sha being looked for
/// @return the tree entry; NULL if not found
@ffi.Native<ffi.Pointer<git_tree_entry> Function(ffi.Pointer<git_tree> , ffi.Pointer<git_oid> )>()
external ffi.Pointer<git_tree_entry> git_tree_entry_byid(ffi.Pointer<git_tree> tree,
ffi.Pointer<git_oid> id,
);

/// Retrieve a tree entry contained in a tree or in any of its subtrees,
/// given its relative path.
/// 
/// Unlike the other lookup functions, the returned tree entry is owned by
/// the user and must be freed explicitly with `git_tree_entry_free()`.
/// 
/// @param out Pointer where to store the tree entry
/// @param root Previously loaded tree which is the root of the relative path
/// @param path Path to the contained entry
/// @return 0 on success; GIT_ENOTFOUND if the path does not exist
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_tree_entry>> , ffi.Pointer<git_tree> , ffi.Pointer<ffi.Char> )>()
external int git_tree_entry_bypath(ffi.Pointer<ffi.Pointer<git_tree_entry>> out,
ffi.Pointer<git_tree> root,
ffi.Pointer<ffi.Char> path,
);

/// Duplicate a tree entry
/// 
/// Create a copy of a tree entry. The returned copy is owned by the user,
/// and must be freed explicitly with `git_tree_entry_free()`.
/// 
/// @param dest pointer where to store the copy
/// @param source tree entry to duplicate
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_tree_entry>> , ffi.Pointer<git_tree_entry> )>()
external int git_tree_entry_dup(ffi.Pointer<ffi.Pointer<git_tree_entry>> dest,
ffi.Pointer<git_tree_entry> source,
);

/// Free a user-owned tree entry
/// 
/// IMPORTANT: This function is only needed for tree entries owned by the
/// user, such as the ones returned by `git_tree_entry_dup()` or
/// `git_tree_entry_bypath()`.
/// 
/// @param entry The entry to free
@ffi.Native<ffi.Void Function(ffi.Pointer<git_tree_entry> )>()
external void git_tree_entry_free(ffi.Pointer<git_tree_entry> entry,
);

/// Get the filename of a tree entry
/// 
/// @param entry a tree entry
/// @return the name of the file
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_tree_entry> )>()
external ffi.Pointer<ffi.Char> git_tree_entry_name(ffi.Pointer<git_tree_entry> entry,
);

/// Get the id of the object pointed by the entry
/// 
/// @param entry a tree entry
/// @return the oid of the object
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_tree_entry> )>()
external ffi.Pointer<git_oid> git_tree_entry_id(ffi.Pointer<git_tree_entry> entry,
);

/// Get the type of the object pointed by the entry
/// 
/// @param entry a tree entry
/// @return the type of the pointed object
@ffi.Native<ffi.Int Function(ffi.Pointer<git_tree_entry> )>(symbol: 'git_tree_entry_type')
external int _git_tree_entry_type(ffi.Pointer<git_tree_entry> entry,
);

git_object_t git_tree_entry_type(ffi.Pointer<git_tree_entry> entry,
) => git_object_t.fromValue(_git_tree_entry_type(entry,
));

/// Get the UNIX file attributes of a tree entry
/// 
/// @param entry a tree entry
/// @return filemode as an integer
@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<git_tree_entry> )>(symbol: 'git_tree_entry_filemode')
external int _git_tree_entry_filemode(ffi.Pointer<git_tree_entry> entry,
);

git_filemode_t git_tree_entry_filemode(ffi.Pointer<git_tree_entry> entry,
) => git_filemode_t.fromValue(_git_tree_entry_filemode(entry,
));

/// Get the raw UNIX file attributes of a tree entry
/// 
/// This function does not perform any normalization and is only useful
/// if you need to be able to recreate the original tree object.
/// 
/// @param entry a tree entry
/// @return filemode as an integer
@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<git_tree_entry> )>(symbol: 'git_tree_entry_filemode_raw')
external int _git_tree_entry_filemode_raw(ffi.Pointer<git_tree_entry> entry,
);

git_filemode_t git_tree_entry_filemode_raw(ffi.Pointer<git_tree_entry> entry,
) => git_filemode_t.fromValue(_git_tree_entry_filemode_raw(entry,
));

/// Compare two tree entries
/// 
/// @param e1 first tree entry
/// @param e2 second tree entry
/// @return <0 if e1 is before e2, 0 if e1 == e2, >0 if e1 is after e2
@ffi.Native<ffi.Int Function(ffi.Pointer<git_tree_entry> , ffi.Pointer<git_tree_entry> )>()
external int git_tree_entry_cmp(ffi.Pointer<git_tree_entry> e1,
ffi.Pointer<git_tree_entry> e2,
);

/// Convert a tree entry to the git_object it points to.
/// 
/// You must call `git_object_free()` on the object when you are done with it.
/// 
/// @param object_out pointer to the converted object
/// @param repo repository where to lookup the pointed object
/// @param entry a tree entry
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_object>> , ffi.Pointer<git_repository> , ffi.Pointer<git_tree_entry> )>()
external int git_tree_entry_to_object(ffi.Pointer<ffi.Pointer<git_object>> object_out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_tree_entry> entry,
);

/// Create a new tree builder.
/// 
/// The tree builder can be used to create or modify trees in memory and
/// write them as tree objects to the database.
/// 
/// If the `source` parameter is not NULL, the tree builder will be
/// initialized with the entries of the given tree.
/// 
/// If the `source` parameter is NULL, the tree builder will start with no
/// entries and will have to be filled manually.
/// 
/// @param out Pointer where to store the tree builder
/// @param repo Repository in which to store the object
/// @param source Source tree to initialize the builder (optional)
/// @return 0 on success; error code otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_treebuilder>> , ffi.Pointer<git_repository> , ffi.Pointer<git_tree> )>()
external int git_treebuilder_new(ffi.Pointer<ffi.Pointer<git_treebuilder>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_tree> source,
);

/// Clear all the entries in the builder
/// 
/// @param bld Builder to clear
/// @return 0 on success; error code otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_treebuilder> )>()
external int git_treebuilder_clear(ffi.Pointer<git_treebuilder> bld,
);

/// Get the number of entries listed in a treebuilder
/// 
/// @param bld a previously loaded treebuilder.
/// @return the number of entries in the treebuilder
@ffi.Native<ffi.Size Function(ffi.Pointer<git_treebuilder> )>()
external int git_treebuilder_entrycount(ffi.Pointer<git_treebuilder> bld,
);

/// Free a tree builder
/// 
/// This will clear all the entries and free to builder.
/// Failing to free the builder after you're done using it
/// will result in a memory leak
/// 
/// @param bld Builder to free
@ffi.Native<ffi.Void Function(ffi.Pointer<git_treebuilder> )>()
external void git_treebuilder_free(ffi.Pointer<git_treebuilder> bld,
);

/// Get an entry from the builder from its filename
/// 
/// The returned entry is owned by the builder and should
/// not be freed manually.
/// 
/// @param bld Tree builder
/// @param filename Name of the entry
/// @return pointer to the entry; NULL if not found
@ffi.Native<ffi.Pointer<git_tree_entry> Function(ffi.Pointer<git_treebuilder> , ffi.Pointer<ffi.Char> )>()
external ffi.Pointer<git_tree_entry> git_treebuilder_get(ffi.Pointer<git_treebuilder> bld,
ffi.Pointer<ffi.Char> filename,
);

/// Add or update an entry to the builder
/// 
/// Insert a new entry for `filename` in the builder with the
/// given attributes.
/// 
/// If an entry named `filename` already exists, its attributes
/// will be updated with the given ones.
/// 
/// The optional pointer `out` can be used to retrieve a pointer to the
/// newly created/updated entry.  Pass NULL if you do not need it. The
/// pointer may not be valid past the next operation in this
/// builder. Duplicate the entry if you want to keep it.
/// 
/// By default the entry that you are inserting will be checked for
/// validity; that it exists in the object database and is of the
/// correct type.  If you do not want this behavior, set the
/// `GIT_OPT_ENABLE_STRICT_OBJECT_CREATION` library option to false.
/// 
/// @param out Pointer to store the entry (optional)
/// @param bld Tree builder
/// @param filename Filename of the entry
/// @param id SHA1 oid of the entry
/// @param filemode Folder attributes of the entry. This parameter must
/// be valued with one of the following entries: 0040000, 0100644,
/// 0100755, 0120000 or 0160000.
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_tree_entry>> , ffi.Pointer<git_treebuilder> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_oid> , ffi.UnsignedInt )>(symbol: 'git_treebuilder_insert')
external int _git_treebuilder_insert(ffi.Pointer<ffi.Pointer<git_tree_entry>> out,
ffi.Pointer<git_treebuilder> bld,
ffi.Pointer<ffi.Char> filename,
ffi.Pointer<git_oid> id,
int filemode,
);

int git_treebuilder_insert(ffi.Pointer<ffi.Pointer<git_tree_entry>> out,
ffi.Pointer<git_treebuilder> bld,
ffi.Pointer<ffi.Char> filename,
ffi.Pointer<git_oid> id,
git_filemode_t filemode,
) => _git_treebuilder_insert(out,
bld,
filename,
id,
filemode.value,
);

/// Remove an entry from the builder by its filename
/// 
/// @param bld Tree builder
/// @param filename Filename of the entry to remove
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_treebuilder> , ffi.Pointer<ffi.Char> )>()
external int git_treebuilder_remove(ffi.Pointer<git_treebuilder> bld,
ffi.Pointer<ffi.Char> filename,
);

/// Selectively remove entries in the tree
/// 
/// The `filter` callback will be called for each entry in the tree with a
/// pointer to the entry and the provided `payload`; if the callback returns
/// non-zero, the entry will be filtered (removed from the builder).
/// 
/// @param bld Tree builder
/// @param filter Callback to filter entries
/// @param payload Extra data to pass to filter callback
/// @return 0 on success, non-zero callback return value, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_treebuilder> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_tree_entry> entry, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_treebuilder_filter(ffi.Pointer<git_treebuilder> bld,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_tree_entry> entry, ffi.Pointer<ffi.Void> payload)>> filter,
ffi.Pointer<ffi.Void> payload,
);

/// Write the contents of the tree builder as a tree object
/// 
/// The tree builder will be written to the given `repo`, and its
/// identifying SHA1 hash will be stored in the `id` pointer.
/// 
/// @param id Pointer to store the OID of the newly written tree
/// @param bld Tree builder to write
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_treebuilder> )>()
external int git_treebuilder_write(ffi.Pointer<git_oid> id,
ffi.Pointer<git_treebuilder> bld,
);

/// Traverse the entries in a tree and its subtrees in post or pre order.
/// 
/// The entries will be traversed in the specified order, children subtrees
/// will be automatically loaded as required, and the `callback` will be
/// called once per entry with the current (relative) root for the entry and
/// the entry data itself.
/// 
/// If the callback returns a positive value, the passed entry will be
/// skipped on the traversal (in pre mode). A negative value stops the walk.
/// 
/// @param tree The tree to walk
/// @param mode Traversal mode (pre or post-order)
/// @param callback Function to call on each tree entry
/// @param payload Opaque pointer to be passed on each callback
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_tree> , ffi.UnsignedInt , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> root, ffi.Pointer<git_tree_entry> entry, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>(symbol: 'git_tree_walk')
external int _git_tree_walk(ffi.Pointer<git_tree> tree,
int mode,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> root, ffi.Pointer<git_tree_entry> entry, ffi.Pointer<ffi.Void> payload)>> callback,
ffi.Pointer<ffi.Void> payload,
);

int git_tree_walk(ffi.Pointer<git_tree> tree,
git_treewalk_mode mode,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> root, ffi.Pointer<git_tree_entry> entry, ffi.Pointer<ffi.Void> payload)>> callback,
ffi.Pointer<ffi.Void> payload,
) => _git_tree_walk(tree,
mode.value,
callback,
payload,
);

/// Create an in-memory copy of a tree. The copy must be explicitly
/// free'd or it will leak.
/// 
/// @param out Pointer to store the copy of the tree
/// @param source Original tree to copy
/// @return 0
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_tree>> , ffi.Pointer<git_tree> )>()
external int git_tree_dup(ffi.Pointer<ffi.Pointer<git_tree>> out,
ffi.Pointer<git_tree> source,
);

/// Create a tree based on another one with the specified modifications
/// 
/// Given the `baseline` perform the changes described in the list of
/// `updates` and create a new tree.
/// 
/// This function is optimized for common file/directory addition, removal and
/// replacement in trees. It is much more efficient than reading the tree into a
/// `git_index` and modifying that, but in exchange it is not as flexible.
/// 
/// Deleting and adding the same entry is undefined behaviour, changing
/// a tree to a blob or viceversa is not supported.
/// 
/// @param out id of the new tree
/// @param repo the repository in which to create the tree, must be the
/// same as for `baseline`
/// @param baseline the tree to base these changes on
/// @param nupdates the number of elements in the update list
/// @param updates the list of updates to perform
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<git_tree> , ffi.Size , ffi.Pointer<git_tree_update> )>()
external int git_tree_create_updated(ffi.Pointer<git_oid> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_tree> baseline,
int nupdates,
ffi.Pointer<git_tree_update> updates,
);

/// Free the strings contained in a string array.  This method should
/// be called on `git_strarray` objects that were provided by the
/// library.  Not doing so, will result in a memory leak.
/// 
/// This does not free the `git_strarray` itself, since the library will
/// never allocate that object directly itself.
/// 
/// @param array The git_strarray that contains strings to free
@ffi.Native<ffi.Void Function(ffi.Pointer<git_strarray> )>()
external void git_strarray_dispose(ffi.Pointer<git_strarray> array,
);

/// Lookup a reference by name in a repository.
/// 
/// The returned reference must be freed by the user.
/// 
/// The name will be checked for validity.
/// See `git_reference_symbolic_create()` for rules about valid names.
/// 
/// @param[out] out pointer to the looked-up reference
/// @param repo the repository to look up the reference
/// @param name the long name for the reference (e.g. HEAD, refs/heads/master, refs/tags/v0.1.0, ...)
/// @return 0 on success, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_reference_lookup(ffi.Pointer<ffi.Pointer<git_reference>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
);

/// Lookup a reference by name and resolve immediately to OID.
/// 
/// This function provides a quick way to resolve a reference name straight
/// through to the object id that it refers to.  This avoids having to
/// allocate or free any `git_reference` objects for simple situations.
/// 
/// The name will be checked for validity.
/// See `git_reference_symbolic_create()` for rules about valid names.
/// 
/// @param out Pointer to oid to be filled in
/// @param repo The repository in which to look up the reference
/// @param name The long name for the reference (e.g. HEAD, refs/heads/master, refs/tags/v0.1.0, ...)
/// @return 0 on success, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_reference_name_to_id(ffi.Pointer<git_oid> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
);

/// Lookup a reference by DWIMing its short name
/// 
/// Apply the git precedence rules to the given shorthand to determine
/// which reference the user is referring to.
/// 
/// @param out pointer in which to store the reference
/// @param repo the repository in which to look
/// @param shorthand the short name for the reference
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_reference_dwim(ffi.Pointer<ffi.Pointer<git_reference>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> shorthand,
);

/// Conditionally create a new symbolic reference.
/// 
/// A symbolic reference is a reference name that refers to another
/// reference name.  If the other name moves, the symbolic name will move,
/// too.  As a simple example, the "HEAD" reference might refer to
/// "refs/heads/master" while on the "master" branch of a repository.
/// 
/// The symbolic reference will be created in the repository and written to
/// the disk.  The generated reference object must be freed by the user.
/// 
/// Valid reference names must follow one of two patterns:
/// 
/// 1. Top-level names must contain only capital letters and underscores,
/// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
/// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
/// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
/// sequences ".." and "@{" which have special meaning to revparse.
/// 
/// This function will return an error if a reference already exists with the
/// given name unless `force` is true, in which case it will be overwritten.
/// 
/// The message for the reflog will be ignored if the reference does
/// not belong in the standard set (HEAD, branches and remote-tracking
/// branches) and it does not have a reflog.
/// 
/// It will return GIT_EMODIFIED if the reference's value at the time
/// of updating does not match the one passed through `current_value`
/// (i.e. if the ref has changed since the user read it).
/// 
/// If `current_value` is all zeros, this function will return GIT_EMODIFIED
/// if the ref already exists.
/// 
/// @param out Pointer to the newly created reference
/// @param repo Repository where that reference will live
/// @param name The name of the reference
/// @param target The target of the reference
/// @param force Overwrite existing references
/// @param current_value The expected value of the reference when updating
/// @param log_message The one line long message to be appended to the reflog
/// @return 0 on success, GIT_EEXISTS, GIT_EINVALIDSPEC, GIT_EMODIFIED or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Int , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_reference_symbolic_create_matching(ffi.Pointer<ffi.Pointer<git_reference>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
ffi.Pointer<ffi.Char> target,
int force,
ffi.Pointer<ffi.Char> current_value,
ffi.Pointer<ffi.Char> log_message,
);

/// Create a new symbolic reference.
/// 
/// A symbolic reference is a reference name that refers to another
/// reference name.  If the other name moves, the symbolic name will move,
/// too.  As a simple example, the "HEAD" reference might refer to
/// "refs/heads/master" while on the "master" branch of a repository.
/// 
/// The symbolic reference will be created in the repository and written to
/// the disk.  The generated reference object must be freed by the user.
/// 
/// Valid reference names must follow one of two patterns:
/// 
/// 1. Top-level names must contain only capital letters and underscores,
/// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
/// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
/// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
/// sequences ".." and "@{" which have special meaning to revparse.
/// 
/// This function will return an error if a reference already exists with the
/// given name unless `force` is true, in which case it will be overwritten.
/// 
/// The message for the reflog will be ignored if the reference does
/// not belong in the standard set (HEAD, branches and remote-tracking
/// branches) and it does not have a reflog.
/// 
/// @param out Pointer to the newly created reference
/// @param repo Repository where that reference will live
/// @param name The name of the reference
/// @param target The target of the reference
/// @param force Overwrite existing references
/// @param log_message The one line long message to be appended to the reflog
/// @return 0 on success, GIT_EEXISTS, GIT_EINVALIDSPEC or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Int , ffi.Pointer<ffi.Char> )>()
external int git_reference_symbolic_create(ffi.Pointer<ffi.Pointer<git_reference>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
ffi.Pointer<ffi.Char> target,
int force,
ffi.Pointer<ffi.Char> log_message,
);

/// Create a new direct reference.
/// 
/// A direct reference (also called an object id reference) refers directly
/// to a specific object id (a.k.a. OID or SHA) in the repository.  The id
/// permanently refers to the object (although the reference itself can be
/// moved).  For example, in libgit2 the direct ref "refs/tags/v0.17.0"
/// refers to OID 5b9fac39d8a76b9139667c26a63e6b3f204b3977.
/// 
/// The direct reference will be created in the repository and written to
/// the disk.  The generated reference object must be freed by the user.
/// 
/// Valid reference names must follow one of two patterns:
/// 
/// 1. Top-level names must contain only capital letters and underscores,
/// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
/// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
/// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
/// sequences ".." and "@{" which have special meaning to revparse.
/// 
/// This function will return an error if a reference already exists with the
/// given name unless `force` is true, in which case it will be overwritten.
/// 
/// The message for the reflog will be ignored if the reference does
/// not belong in the standard set (HEAD, branches and remote-tracking
/// branches) and it does not have a reflog.
/// 
/// @param out Pointer to the newly created reference
/// @param repo Repository where that reference will live
/// @param name The name of the reference
/// @param id The object id pointed to by the reference.
/// @param force Overwrite existing references
/// @param log_message The one line long message to be appended to the reflog
/// @return 0 on success, GIT_EEXISTS, GIT_EINVALIDSPEC or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_oid> , ffi.Int , ffi.Pointer<ffi.Char> )>()
external int git_reference_create(ffi.Pointer<ffi.Pointer<git_reference>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
ffi.Pointer<git_oid> id,
int force,
ffi.Pointer<ffi.Char> log_message,
);

/// Conditionally create new direct reference
/// 
/// A direct reference (also called an object id reference) refers directly
/// to a specific object id (a.k.a. OID or SHA) in the repository.  The id
/// permanently refers to the object (although the reference itself can be
/// moved).  For example, in libgit2 the direct ref "refs/tags/v0.17.0"
/// refers to OID 5b9fac39d8a76b9139667c26a63e6b3f204b3977.
/// 
/// The direct reference will be created in the repository and written to
/// the disk.  The generated reference object must be freed by the user.
/// 
/// Valid reference names must follow one of two patterns:
/// 
/// 1. Top-level names must contain only capital letters and underscores,
/// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
/// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
/// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
/// sequences ".." and "@{" which have special meaning to revparse.
/// 
/// This function will return an error if a reference already exists with the
/// given name unless `force` is true, in which case it will be overwritten.
/// 
/// The message for the reflog will be ignored if the reference does
/// not belong in the standard set (HEAD, branches and remote-tracking
/// branches) and it does not have a reflog.
/// 
/// It will return GIT_EMODIFIED if the reference's value at the time
/// of updating does not match the one passed through `current_id`
/// (i.e. if the ref has changed since the user read it).
/// 
/// @param out Pointer to the newly created reference
/// @param repo Repository where that reference will live
/// @param name The name of the reference
/// @param id The object id pointed to by the reference.
/// @param force Overwrite existing references
/// @param current_id The expected value of the reference at the time of update
/// @param log_message The one line long message to be appended to the reflog
/// @return 0 on success, GIT_EMODIFIED if the value of the reference
/// has changed, GIT_EEXISTS, GIT_EINVALIDSPEC or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_oid> , ffi.Int , ffi.Pointer<git_oid> , ffi.Pointer<ffi.Char> )>()
external int git_reference_create_matching(ffi.Pointer<ffi.Pointer<git_reference>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
ffi.Pointer<git_oid> id,
int force,
ffi.Pointer<git_oid> current_id,
ffi.Pointer<ffi.Char> log_message,
);

/// Get the OID pointed to by a direct reference.
/// 
/// Only available if the reference is direct (i.e. an object id reference,
/// not a symbolic one).
/// 
/// To find the OID of a symbolic ref, call `git_reference_resolve()` and
/// then this function (or maybe use `git_reference_name_to_id()` to
/// directly resolve a reference name all the way through to an OID).
/// 
/// @param ref The reference
/// @return a pointer to the oid if available, NULL otherwise
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_reference> )>()
external ffi.Pointer<git_oid> git_reference_target(ffi.Pointer<git_reference> ref,
);

/// Return the peeled OID target of this reference.
/// 
/// This peeled OID only applies to direct references that point to
/// a hard Tag object: it is the result of peeling such Tag.
/// 
/// @param ref The reference
/// @return a pointer to the oid if available, NULL otherwise
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_reference> )>()
external ffi.Pointer<git_oid> git_reference_target_peel(ffi.Pointer<git_reference> ref,
);

/// Get full name to the reference pointed to by a symbolic reference.
/// 
/// Only available if the reference is symbolic.
/// 
/// @param ref The reference
/// @return a pointer to the name if available, NULL otherwise
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_reference> )>()
external ffi.Pointer<ffi.Char> git_reference_symbolic_target(ffi.Pointer<git_reference> ref,
);

/// Get the type of a reference.
/// 
/// Either direct (GIT_REFERENCE_DIRECT) or symbolic (GIT_REFERENCE_SYMBOLIC)
/// 
/// @param ref The reference
/// @return the type
@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<git_reference> )>(symbol: 'git_reference_type')
external int _git_reference_type(ffi.Pointer<git_reference> ref,
);

git_reference_t git_reference_type(ffi.Pointer<git_reference> ref,
) => git_reference_t.fromValue(_git_reference_type(ref,
));

/// Get the full name of a reference.
/// 
/// See `git_reference_symbolic_create()` for rules about valid names.
/// 
/// @param ref The reference
/// @return the full name for the ref
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_reference> )>()
external ffi.Pointer<ffi.Char> git_reference_name(ffi.Pointer<git_reference> ref,
);

/// Resolve a symbolic reference to a direct reference.
/// 
/// This method iteratively peels a symbolic reference until it resolves to
/// a direct reference to an OID.
/// 
/// The peeled reference is returned in the `resolved_ref` argument, and
/// must be freed manually once it's no longer needed.
/// 
/// If a direct reference is passed as an argument, a copy of that
/// reference is returned. This copy must be manually freed too.
/// 
/// @param out Pointer to the peeled reference
/// @param ref The reference
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>> , ffi.Pointer<git_reference> )>()
external int git_reference_resolve(ffi.Pointer<ffi.Pointer<git_reference>> out,
ffi.Pointer<git_reference> ref,
);

/// Get the repository where a reference resides.
/// 
/// @param ref The reference
/// @return a pointer to the repo
@ffi.Native<ffi.Pointer<git_repository> Function(ffi.Pointer<git_reference> )>()
external ffi.Pointer<git_repository> git_reference_owner(ffi.Pointer<git_reference> ref,
);

/// Create a new reference with the same name as the given reference but a
/// different symbolic target. The reference must be a symbolic reference,
/// otherwise this will fail.
/// 
/// The new reference will be written to disk, overwriting the given reference.
/// 
/// The target name will be checked for validity.
/// See `git_reference_symbolic_create()` for rules about valid names.
/// 
/// The message for the reflog will be ignored if the reference does
/// not belong in the standard set (HEAD, branches and remote-tracking
/// branches) and it does not have a reflog.
/// 
/// @param out Pointer to the newly created reference
/// @param ref The reference
/// @param target The new target for the reference
/// @param log_message The one line long message to be appended to the reflog
/// @return 0 on success, GIT_EINVALIDSPEC or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>> , ffi.Pointer<git_reference> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_reference_symbolic_set_target(ffi.Pointer<ffi.Pointer<git_reference>> out,
ffi.Pointer<git_reference> ref,
ffi.Pointer<ffi.Char> target,
ffi.Pointer<ffi.Char> log_message,
);

/// Conditionally create a new reference with the same name as the given reference but a
/// different OID target. The reference must be a direct reference, otherwise
/// this will fail.
/// 
/// The new reference will be written to disk, overwriting the given reference.
/// 
/// @param out Pointer to the newly created reference
/// @param ref The reference
/// @param id The new target OID for the reference
/// @param log_message The one line long message to be appended to the reflog
/// @return 0 on success, GIT_EMODIFIED if the value of the reference
/// has changed since it was read, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>> , ffi.Pointer<git_reference> , ffi.Pointer<git_oid> , ffi.Pointer<ffi.Char> )>()
external int git_reference_set_target(ffi.Pointer<ffi.Pointer<git_reference>> out,
ffi.Pointer<git_reference> ref,
ffi.Pointer<git_oid> id,
ffi.Pointer<ffi.Char> log_message,
);

/// Rename an existing reference.
/// 
/// This method works for both direct and symbolic references.
/// 
/// The new name will be checked for validity.
/// See `git_reference_symbolic_create()` for rules about valid names.
/// 
/// If the `force` flag is not enabled, and there's already
/// a reference with the given name, the renaming will fail.
/// 
/// IMPORTANT:
/// The user needs to write a proper reflog entry if the
/// reflog is enabled for the repository. We only rename
/// the reflog if it exists.
/// 
/// @param[out] new_ref The new reference
/// @param ref The reference to rename
/// @param new_name The new name for the reference
/// @param force Overwrite an existing reference
/// @param log_message The one line long message to be appended to the reflog
/// @return 0 on success, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>> , ffi.Pointer<git_reference> , ffi.Pointer<ffi.Char> , ffi.Int , ffi.Pointer<ffi.Char> )>()
external int git_reference_rename(ffi.Pointer<ffi.Pointer<git_reference>> new_ref,
ffi.Pointer<git_reference> ref,
ffi.Pointer<ffi.Char> new_name,
int force,
ffi.Pointer<ffi.Char> log_message,
);

/// Delete an existing reference.
/// 
/// This method works for both direct and symbolic references.  The reference
/// will be immediately removed on disk but the memory will not be freed.
/// Callers must call `git_reference_free`.
/// 
/// This function will return an error if the reference has changed
/// from the time it was looked up.
/// 
/// @param ref The reference to remove
/// @return 0, GIT_EMODIFIED or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_reference> )>()
external int git_reference_delete(ffi.Pointer<git_reference> ref,
);

/// Delete an existing reference by name
/// 
/// This method removes the named reference from the repository without
/// looking at its old value.
/// 
/// @param repo The repository to remove the reference from
/// @param name The reference to remove
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_reference_remove(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
);

/// Fill a list with all the references that can be found in a repository.
/// 
/// The string array will be filled with the names of all references; these
/// values are owned by the user and should be free'd manually when no
/// longer needed, using `git_strarray_free()`.
/// 
/// @param array Pointer to a git_strarray structure where
/// the reference names will be stored
/// @param repo Repository where to find the refs
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_strarray> , ffi.Pointer<git_repository> )>()
external int git_reference_list(ffi.Pointer<git_strarray> array,
ffi.Pointer<git_repository> repo,
);

/// Perform a callback on each reference in the repository.
/// 
/// The `callback` function will be called for each reference in the
/// repository, receiving the reference object and the `payload` value
/// passed to this method.  Returning a non-zero value from the callback
/// will terminate the iteration.
/// 
/// Note that the callback function is responsible to call `git_reference_free`
/// on each reference passed to it.
/// 
/// @param repo Repository where to find the refs
/// @param callback Function which will be called for every listed ref
/// @param payload Additional data to pass to the callback
/// @return 0 on success, non-zero callback return value, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_reference> reference, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_reference_foreach(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_reference> reference, ffi.Pointer<ffi.Void> payload)>> callback,
ffi.Pointer<ffi.Void> payload,
);

/// Perform a callback on the fully-qualified name of each reference.
/// 
/// The `callback` function will be called for each reference in the
/// repository, receiving the name of the reference and the `payload` value
/// passed to this method.  Returning a non-zero value from the callback
/// will terminate the iteration.
/// 
/// @param repo Repository where to find the refs
/// @param callback Function which will be called for every listed ref name
/// @param payload Additional data to pass to the callback
/// @return 0 on success, non-zero callback return value, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> name, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_reference_foreach_name(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> name, ffi.Pointer<ffi.Void> payload)>> callback,
ffi.Pointer<ffi.Void> payload,
);

/// Create a copy of an existing reference.
/// 
/// Call `git_reference_free` to free the data.
/// 
/// @param dest pointer where to store the copy
/// @param source object to copy
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>> , ffi.Pointer<git_reference> )>()
external int git_reference_dup(ffi.Pointer<ffi.Pointer<git_reference>> dest,
ffi.Pointer<git_reference> source,
);

/// Free the given reference.
/// 
/// @param ref git_reference
@ffi.Native<ffi.Void Function(ffi.Pointer<git_reference> )>()
external void git_reference_free(ffi.Pointer<git_reference> ref,
);

/// Compare two references.
/// 
/// @param ref1 The first git_reference
/// @param ref2 The second git_reference
/// @return 0 if the same, else a stable but meaningless ordering.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_reference> , ffi.Pointer<git_reference> )>()
external int git_reference_cmp(ffi.Pointer<git_reference> ref1,
ffi.Pointer<git_reference> ref2,
);

/// Create an iterator for the repo's references
/// 
/// @param[out] out pointer in which to store the iterator
/// @param repo the repository
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference_iterator>> , ffi.Pointer<git_repository> )>()
external int git_reference_iterator_new(ffi.Pointer<ffi.Pointer<git_reference_iterator>> out,
ffi.Pointer<git_repository> repo,
);

/// Create an iterator for the repo's references that match the
/// specified glob
/// 
/// @param out pointer in which to store the iterator
/// @param repo the repository
/// @param glob the glob to match against the reference names
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference_iterator>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_reference_iterator_glob_new(ffi.Pointer<ffi.Pointer<git_reference_iterator>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> glob,
);

/// Get the next reference
/// 
/// @param[out] out pointer in which to store the reference
/// @param iter the iterator
/// @return 0, GIT_ITEROVER if there are no more; or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>> , ffi.Pointer<git_reference_iterator> )>()
external int git_reference_next(ffi.Pointer<ffi.Pointer<git_reference>> out,
ffi.Pointer<git_reference_iterator> iter,
);

/// Get the next reference's name
/// 
/// This function is provided for convenience in case only the names
/// are interesting as it avoids the allocation of the `git_reference`
/// object which `git_reference_next()` needs.
/// 
/// @param out pointer in which to store the string
/// @param iter the iterator
/// @return 0, GIT_ITEROVER if there are no more; or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>> , ffi.Pointer<git_reference_iterator> )>()
external int git_reference_next_name(ffi.Pointer<ffi.Pointer<ffi.Char>> out,
ffi.Pointer<git_reference_iterator> iter,
);

/// Free the iterator and its associated resources
/// 
/// @param iter the iterator to free
@ffi.Native<ffi.Void Function(ffi.Pointer<git_reference_iterator> )>()
external void git_reference_iterator_free(ffi.Pointer<git_reference_iterator> iter,
);

/// Perform a callback on each reference in the repository whose name
/// matches the given pattern.
/// 
/// This function acts like `git_reference_foreach()` with an additional
/// pattern match being applied to the reference name before issuing the
/// callback function.  See that function for more information.
/// 
/// The pattern is matched using fnmatch or "glob" style where a '*' matches
/// any sequence of letters, a '?' matches any letter, and square brackets
/// can be used to define character ranges (such as "[0-9]" for digits).
/// 
/// @param repo Repository where to find the refs
/// @param glob Pattern to match (fnmatch-style) against reference name.
/// @param callback Function which will be called for every listed ref
/// @param payload Additional data to pass to the callback
/// @return 0 on success, GIT_EUSER on non-zero callback, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> name, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_reference_foreach_glob(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> glob,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> name, ffi.Pointer<ffi.Void> payload)>> callback,
ffi.Pointer<ffi.Void> payload,
);

/// Check if a reflog exists for the specified reference.
/// 
/// @param repo the repository
/// @param refname the reference's name
/// @return 0 when no reflog can be found, 1 when it exists;
/// otherwise an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_reference_has_log(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> refname,
);

/// Ensure there is a reflog for a particular reference.
/// 
/// Make sure that successive updates to the reference will append to
/// its log.
/// 
/// @param repo the repository
/// @param refname the reference's name
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_reference_ensure_log(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> refname,
);

/// Check if a reference is a local branch.
/// 
/// @param ref A git reference
/// 
/// @return 1 when the reference lives in the refs/heads
/// namespace; 0 otherwise.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_reference> )>()
external int git_reference_is_branch(ffi.Pointer<git_reference> ref,
);

/// Check if a reference is a remote tracking branch
/// 
/// @param ref A git reference
/// 
/// @return 1 when the reference lives in the refs/remotes
/// namespace; 0 otherwise.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_reference> )>()
external int git_reference_is_remote(ffi.Pointer<git_reference> ref,
);

/// Check if a reference is a tag
/// 
/// @param ref A git reference
/// 
/// @return 1 when the reference lives in the refs/tags
/// namespace; 0 otherwise.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_reference> )>()
external int git_reference_is_tag(ffi.Pointer<git_reference> ref,
);

/// Check if a reference is a note
/// 
/// @param ref A git reference
/// 
/// @return 1 when the reference lives in the refs/notes
/// namespace; 0 otherwise.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_reference> )>()
external int git_reference_is_note(ffi.Pointer<git_reference> ref,
);

/// Normalize reference name and check validity.
/// 
/// This will normalize the reference name by removing any leading slash
/// '/' characters and collapsing runs of adjacent slashes between name
/// components into a single slash.
/// 
/// Once normalized, if the reference name is valid, it will be returned in
/// the user allocated buffer.
/// 
/// See `git_reference_symbolic_create()` for rules about valid names.
/// 
/// @param buffer_out User allocated buffer to store normalized name
/// @param buffer_size Size of buffer_out
/// @param name Reference name to be checked.
/// @param flags Flags to constrain name validation rules - see the
/// GIT_REFERENCE_FORMAT constants above.
/// @return 0 on success, GIT_EBUFS if buffer is too small, GIT_EINVALIDSPEC
/// or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char> , ffi.Size , ffi.Pointer<ffi.Char> , ffi.UnsignedInt )>()
external int git_reference_normalize_name(ffi.Pointer<ffi.Char> buffer_out,
int buffer_size,
ffi.Pointer<ffi.Char> name,
int flags,
);

/// Recursively peel reference until object of the specified type is found.
/// 
/// The retrieved `peeled` object is owned by the repository
/// and should be closed with the `git_object_free` method.
/// 
/// If you pass `GIT_OBJECT_ANY` as the target type, then the object
/// will be peeled until a non-tag object is met.
/// 
/// @param[out] out Pointer to the peeled git_object
/// @param ref The reference to be processed
/// @param type The type of the requested object (GIT_OBJECT_COMMIT,
/// GIT_OBJECT_TAG, GIT_OBJECT_TREE, GIT_OBJECT_BLOB or GIT_OBJECT_ANY).
/// @return 0 on success, GIT_EAMBIGUOUS, GIT_ENOTFOUND or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_object>> , ffi.Pointer<git_reference> , ffi.Int )>(symbol: 'git_reference_peel')
external int _git_reference_peel(ffi.Pointer<ffi.Pointer<git_object>> out,
ffi.Pointer<git_reference> ref,
int type,
);

int git_reference_peel(ffi.Pointer<ffi.Pointer<git_object>> out,
ffi.Pointer<git_reference> ref,
git_object_t type,
) => _git_reference_peel(out,
ref,
type.value,
);

/// Ensure the reference name is well-formed.
/// 
/// Valid reference names must follow one of two patterns:
/// 
/// 1. Top-level names must contain only capital letters and underscores,
/// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
/// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
/// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
/// sequences ".." and "@{" which have special meaning to revparse.
/// 
/// @param valid output pointer to set with validity of given reference name
/// @param refname name to be checked.
/// @return 0 on success or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Int> , ffi.Pointer<ffi.Char> )>()
external int git_reference_name_is_valid(ffi.Pointer<ffi.Int> valid,
ffi.Pointer<ffi.Char> refname,
);

/// Get the reference's short name
/// 
/// This will transform the reference name into a name "human-readable"
/// version. If no shortname is appropriate, it will return the full
/// name.
/// 
/// The memory is owned by the reference and must not be freed.
/// 
/// @param ref a reference
/// @return the human-readable version of the name
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_reference> )>()
external ffi.Pointer<ffi.Char> git_reference_shorthand(ffi.Pointer<git_reference> ref,
);

/// Initialize git_diff_options structure
/// 
/// Initializes a `git_diff_options` with default values. Equivalent to creating
/// an instance with GIT_DIFF_OPTIONS_INIT.
/// 
/// @param opts The `git_diff_options` struct to initialize.
/// @param version The struct version; pass `GIT_DIFF_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_diff_options> , ffi.UnsignedInt )>()
external int git_diff_options_init(ffi.Pointer<git_diff_options> opts,
int version,
);

/// Initialize git_diff_find_options structure
/// 
/// Initializes a `git_diff_find_options` with default values. Equivalent to creating
/// an instance with GIT_DIFF_FIND_OPTIONS_INIT.
/// 
/// @param opts The `git_diff_find_options` struct to initialize.
/// @param version The struct version; pass `GIT_DIFF_FIND_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_diff_find_options> , ffi.UnsignedInt )>()
external int git_diff_find_options_init(ffi.Pointer<git_diff_find_options> opts,
int version,
);

/// Deallocate a diff.
/// 
/// @param diff The previously created diff; cannot be used after free.
@ffi.Native<ffi.Void Function(ffi.Pointer<git_diff> )>()
external void git_diff_free(ffi.Pointer<git_diff> diff,
);

/// Create a diff with the difference between two tree objects.
/// 
/// This is equivalent to `git diff <old-tree> <new-tree>`
/// 
/// The first tree will be used for the "old_file" side of the delta and the
/// second tree will be used for the "new_file" side of the delta.  You can
/// pass NULL to indicate an empty tree, although it is an error to pass
/// NULL for both the `old_tree` and `new_tree`.
/// 
/// @param diff Output pointer to a git_diff pointer to be allocated.
/// @param repo The repository containing the trees.
/// @param old_tree A git_tree object to diff from, or NULL for empty tree.
/// @param new_tree A git_tree object to diff to, or NULL for empty tree.
/// @param opts Structure with options to influence diff or NULL for defaults.
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_diff>> , ffi.Pointer<git_repository> , ffi.Pointer<git_tree> , ffi.Pointer<git_tree> , ffi.Pointer<git_diff_options> )>()
external int git_diff_tree_to_tree(ffi.Pointer<ffi.Pointer<git_diff>> diff,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_tree> old_tree,
ffi.Pointer<git_tree> new_tree,
ffi.Pointer<git_diff_options> opts,
);

/// Create a diff between a tree and repository index.
/// 
/// This is equivalent to `git diff --cached <treeish>` or if you pass
/// the HEAD tree, then like `git diff --cached`.
/// 
/// The tree you pass will be used for the "old_file" side of the delta, and
/// the index will be used for the "new_file" side of the delta.
/// 
/// If you pass NULL for the index, then the existing index of the `repo`
/// will be used.  In this case, the index will be refreshed from disk
/// (if it has changed) before the diff is generated.
/// 
/// @param diff Output pointer to a git_diff pointer to be allocated.
/// @param repo The repository containing the tree and index.
/// @param old_tree A git_tree object to diff from, or NULL for empty tree.
/// @param index The index to diff with; repo index used if NULL.
/// @param opts Structure with options to influence diff or NULL for defaults.
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_diff>> , ffi.Pointer<git_repository> , ffi.Pointer<git_tree> , ffi.Pointer<git_index> , ffi.Pointer<git_diff_options> )>()
external int git_diff_tree_to_index(ffi.Pointer<ffi.Pointer<git_diff>> diff,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_tree> old_tree,
ffi.Pointer<git_index> index,
ffi.Pointer<git_diff_options> opts,
);

/// Create a diff between the repository index and the workdir directory.
/// 
/// This matches the `git diff` command.  See the note below on
/// `git_diff_tree_to_workdir` for a discussion of the difference between
/// `git diff` and `git diff HEAD` and how to emulate a `git diff <treeish>`
/// using libgit2.
/// 
/// The index will be used for the "old_file" side of the delta, and the
/// working directory will be used for the "new_file" side of the delta.
/// 
/// If you pass NULL for the index, then the existing index of the `repo`
/// will be used.  In this case, the index will be refreshed from disk
/// (if it has changed) before the diff is generated.
/// 
/// @param diff Output pointer to a git_diff pointer to be allocated.
/// @param repo The repository.
/// @param index The index to diff from; repo index used if NULL.
/// @param opts Structure with options to influence diff or NULL for defaults.
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_diff>> , ffi.Pointer<git_repository> , ffi.Pointer<git_index> , ffi.Pointer<git_diff_options> )>()
external int git_diff_index_to_workdir(ffi.Pointer<ffi.Pointer<git_diff>> diff,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_index> index,
ffi.Pointer<git_diff_options> opts,
);

/// Create a diff between a tree and the working directory.
/// 
/// The tree you provide will be used for the "old_file" side of the delta,
/// and the working directory will be used for the "new_file" side.
/// 
/// This is not the same as `git diff <treeish>` or `git diff-index
/// <treeish>`.  Those commands use information from the index, whereas this
/// function strictly returns the differences between the tree and the files
/// in the working directory, regardless of the state of the index.  Use
/// `git_diff_tree_to_workdir_with_index` to emulate those commands.
/// 
/// To see difference between this and `git_diff_tree_to_workdir_with_index`,
/// consider the example of a staged file deletion where the file has then
/// been put back into the working dir and further modified.  The
/// tree-to-workdir diff for that file is 'modified', but `git diff` would
/// show status 'deleted' since there is a staged delete.
/// 
/// @param diff A pointer to a git_diff pointer that will be allocated.
/// @param repo The repository containing the tree.
/// @param old_tree A git_tree object to diff from, or NULL for empty tree.
/// @param opts Structure with options to influence diff or NULL for defaults.
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_diff>> , ffi.Pointer<git_repository> , ffi.Pointer<git_tree> , ffi.Pointer<git_diff_options> )>()
external int git_diff_tree_to_workdir(ffi.Pointer<ffi.Pointer<git_diff>> diff,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_tree> old_tree,
ffi.Pointer<git_diff_options> opts,
);

/// Create a diff between a tree and the working directory using index data
/// to account for staged deletes, tracked files, etc.
/// 
/// This emulates `git diff <tree>` by diffing the tree to the index and
/// the index to the working directory and blending the results into a
/// single diff that includes staged deleted, etc.
/// 
/// @param diff A pointer to a git_diff pointer that will be allocated.
/// @param repo The repository containing the tree.
/// @param old_tree A git_tree object to diff from, or NULL for empty tree.
/// @param opts Structure with options to influence diff or NULL for defaults.
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_diff>> , ffi.Pointer<git_repository> , ffi.Pointer<git_tree> , ffi.Pointer<git_diff_options> )>()
external int git_diff_tree_to_workdir_with_index(ffi.Pointer<ffi.Pointer<git_diff>> diff,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_tree> old_tree,
ffi.Pointer<git_diff_options> opts,
);

/// Create a diff with the difference between two index objects.
/// 
/// The first index will be used for the "old_file" side of the delta and the
/// second index will be used for the "new_file" side of the delta.
/// 
/// @param diff Output pointer to a git_diff pointer to be allocated.
/// @param repo The repository containing the indexes.
/// @param old_index A git_index object to diff from.
/// @param new_index A git_index object to diff to.
/// @param opts Structure with options to influence diff or NULL for defaults.
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_diff>> , ffi.Pointer<git_repository> , ffi.Pointer<git_index> , ffi.Pointer<git_index> , ffi.Pointer<git_diff_options> )>()
external int git_diff_index_to_index(ffi.Pointer<ffi.Pointer<git_diff>> diff,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_index> old_index,
ffi.Pointer<git_index> new_index,
ffi.Pointer<git_diff_options> opts,
);

/// Merge one diff into another.
/// 
/// This merges items from the "from" list into the "onto" list.  The
/// resulting diff will have all items that appear in either list.
/// If an item appears in both lists, then it will be "merged" to appear
/// as if the old version was from the "onto" list and the new version
/// is from the "from" list (with the exception that if the item has a
/// pending DELETE in the middle, then it will show as deleted).
/// 
/// @param onto Diff to merge into.
/// @param from Diff to merge.
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_diff> , ffi.Pointer<git_diff> )>()
external int git_diff_merge(ffi.Pointer<git_diff> onto,
ffi.Pointer<git_diff> from,
);

/// Transform a diff marking file renames, copies, etc.
/// 
/// This modifies a diff in place, replacing old entries that look
/// like renames or copies with new entries reflecting those changes.
/// This also will, if requested, break modified files into add/remove
/// pairs if the amount of change is above a threshold.
/// 
/// @param diff diff to run detection algorithms on
/// @param options Control how detection should be run, NULL for defaults
/// @return 0 on success, -1 on failure
@ffi.Native<ffi.Int Function(ffi.Pointer<git_diff> , ffi.Pointer<git_diff_find_options> )>()
external int git_diff_find_similar(ffi.Pointer<git_diff> diff,
ffi.Pointer<git_diff_find_options> options,
);

/// Query how many diff records are there in a diff.
/// 
/// @param diff A git_diff generated by one of the above functions
/// @return Count of number of deltas in the list
@ffi.Native<ffi.Size Function(ffi.Pointer<git_diff> )>()
external int git_diff_num_deltas(ffi.Pointer<git_diff> diff,
);

/// Query how many diff deltas are there in a diff filtered by type.
/// 
/// This works just like `git_diff_num_deltas()` with an extra parameter
/// that is a `git_delta_t` and returns just the count of how many deltas
/// match that particular type.
/// 
/// @param diff A git_diff generated by one of the above functions
/// @param type A git_delta_t value to filter the count
/// @return Count of number of deltas matching delta_t type
@ffi.Native<ffi.Size Function(ffi.Pointer<git_diff> , ffi.UnsignedInt )>(symbol: 'git_diff_num_deltas_of_type')
external int _git_diff_num_deltas_of_type(ffi.Pointer<git_diff> diff,
int type,
);

int git_diff_num_deltas_of_type(ffi.Pointer<git_diff> diff,
git_delta_t type,
) => _git_diff_num_deltas_of_type(diff,
type.value,
);

/// Return the diff delta for an entry in the diff list.
/// 
/// The `git_diff_delta` pointer points to internal data and you do not
/// have to release it when you are done with it.  It will go away when
/// the * `git_diff` (or any associated `git_patch`) goes away.
/// 
/// Note that the flags on the delta related to whether it has binary
/// content or not may not be set if there are no attributes set for the
/// file and there has been no reason to load the file data at this point.
/// For now, if you need those flags to be up to date, your only option is
/// to either use `git_diff_foreach` or create a `git_patch`.
/// 
/// @param diff Diff list object
/// @param idx Index into diff list
/// @return Pointer to git_diff_delta (or NULL if `idx` out of range)
@ffi.Native<ffi.Pointer<git_diff_delta> Function(ffi.Pointer<git_diff> , ffi.Size )>()
external ffi.Pointer<git_diff_delta> git_diff_get_delta(ffi.Pointer<git_diff> diff,
int idx,
);

/// Check if deltas are sorted case sensitively or insensitively.
/// 
/// @param diff diff to check
/// @return 0 if case sensitive, 1 if case is ignored
@ffi.Native<ffi.Int Function(ffi.Pointer<git_diff> )>()
external int git_diff_is_sorted_icase(ffi.Pointer<git_diff> diff,
);

/// Loop over all deltas in a diff issuing callbacks.
/// 
/// This will iterate through all of the files described in a diff.  You
/// should provide a file callback to learn about each file.
/// 
/// The "hunk" and "line" callbacks are optional, and the text diff of the
/// files will only be calculated if they are not NULL.  Of course, these
/// callbacks will not be invoked for binary files on the diff or for
/// files whose only changed is a file mode change.
/// 
/// Returning a non-zero value from any of the callbacks will terminate
/// the iteration and return the value to the user.
/// 
/// @param diff A git_diff generated by one of the above functions.
/// @param file_cb Callback function to make per file in the diff.
/// @param binary_cb Optional callback to make for binary files.
/// @param hunk_cb Optional callback to make per hunk of text diff.  This
/// callback is called to describe a range of lines in the
/// diff.  It will not be issued for binary files.
/// @param line_cb Optional callback to make per line of diff text.  This
/// same callback will be made for context lines, added, and
/// removed lines, and even for a deleted trailing newline.
/// @param payload Reference pointer that will be passed to your callbacks.
/// @return 0 on success, non-zero callback return value, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_diff> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Float progress, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_binary> binary, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<git_diff_line> line, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_diff_foreach(ffi.Pointer<git_diff> diff,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Float progress, ffi.Pointer<ffi.Void> payload)>> file_cb,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_binary> binary, ffi.Pointer<ffi.Void> payload)>> binary_cb,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<ffi.Void> payload)>> hunk_cb,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<git_diff_line> line, ffi.Pointer<ffi.Void> payload)>> line_cb,
ffi.Pointer<ffi.Void> payload,
);

/// Look up the single character abbreviation for a delta status code.
/// 
/// When you run `git diff --name-status` it uses single letter codes in
/// the output such as 'A' for added, 'D' for deleted, 'M' for modified,
/// etc.  This function converts a git_delta_t value into these letters for
/// your own purposes.  GIT_DELTA_UNTRACKED will return a space (i.e. ' ').
/// 
/// @param status The git_delta_t value to look up
/// @return The single character label for that code
@ffi.Native<ffi.Char Function(ffi.UnsignedInt )>(symbol: 'git_diff_status_char')
external int _git_diff_status_char(int status,
);

int git_diff_status_char(git_delta_t status,
) => _git_diff_status_char(status.value,
);

/// Iterate over a diff generating formatted text output.
/// 
/// Returning a non-zero value from the callbacks will terminate the
/// iteration and return the non-zero value to the caller.
/// 
/// @param diff A git_diff generated by one of the above functions.
/// @param format A git_diff_format_t value to pick the text format.
/// @param print_cb Callback to make per line of diff text.
/// @param payload Reference pointer that will be passed to your callback.
/// @return 0 on success, non-zero callback return value, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_diff> , ffi.UnsignedInt , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<git_diff_line> line, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>(symbol: 'git_diff_print')
external int _git_diff_print(ffi.Pointer<git_diff> diff,
int format,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<git_diff_line> line, ffi.Pointer<ffi.Void> payload)>> print_cb,
ffi.Pointer<ffi.Void> payload,
);

int git_diff_print(ffi.Pointer<git_diff> diff,
git_diff_format_t format,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<git_diff_line> line, ffi.Pointer<ffi.Void> payload)>> print_cb,
ffi.Pointer<ffi.Void> payload,
) => _git_diff_print(diff,
format.value,
print_cb,
payload,
);

/// Produce the complete formatted text output from a diff into a
/// buffer.
/// 
/// @param out A pointer to a user-allocated git_buf that will
/// contain the diff text
/// @param diff A git_diff generated by one of the above functions.
/// @param format A git_diff_format_t value to pick the text format.
/// @return 0 on success or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_diff> , ffi.UnsignedInt )>(symbol: 'git_diff_to_buf')
external int _git_diff_to_buf(ffi.Pointer<git_buf> out,
ffi.Pointer<git_diff> diff,
int format,
);

int git_diff_to_buf(ffi.Pointer<git_buf> out,
ffi.Pointer<git_diff> diff,
git_diff_format_t format,
) => _git_diff_to_buf(out,
diff,
format.value,
);

/// Directly run a diff on two blobs.
/// 
/// Compared to a file, a blob lacks some contextual information. As such,
/// the `git_diff_file` given to the callback will have some fake data; i.e.
/// `mode` will be 0 and `path` will be NULL.
/// 
/// NULL is allowed for either `old_blob` or `new_blob` and will be treated
/// as an empty blob, with the `oid` set to NULL in the `git_diff_file` data.
/// Passing NULL for both blobs is a noop; no callbacks will be made at all.
/// 
/// We do run a binary content check on the blob content and if either blob
/// looks like binary data, the `git_diff_delta` binary attribute will be set
/// to 1 and no call to the hunk_cb nor line_cb will be made (unless you pass
/// `GIT_DIFF_FORCE_TEXT` of course).
/// 
/// @param old_blob Blob for old side of diff, or NULL for empty blob
/// @param old_as_path Treat old blob as if it had this filename; can be NULL
/// @param new_blob Blob for new side of diff, or NULL for empty blob
/// @param new_as_path Treat new blob as if it had this filename; can be NULL
/// @param options Options for diff, or NULL for default options
/// @param file_cb Callback for "file"; made once if there is a diff; can be NULL
/// @param binary_cb Callback for binary files; can be NULL
/// @param hunk_cb Callback for each hunk in diff; can be NULL
/// @param line_cb Callback for each line in diff; can be NULL
/// @param payload Payload passed to each callback function
/// @return 0 on success, non-zero callback return value, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_blob> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_blob> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_diff_options> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Float progress, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_binary> binary, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<git_diff_line> line, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_diff_blobs(ffi.Pointer<git_blob> old_blob,
ffi.Pointer<ffi.Char> old_as_path,
ffi.Pointer<git_blob> new_blob,
ffi.Pointer<ffi.Char> new_as_path,
ffi.Pointer<git_diff_options> options,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Float progress, ffi.Pointer<ffi.Void> payload)>> file_cb,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_binary> binary, ffi.Pointer<ffi.Void> payload)>> binary_cb,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<ffi.Void> payload)>> hunk_cb,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<git_diff_line> line, ffi.Pointer<ffi.Void> payload)>> line_cb,
ffi.Pointer<ffi.Void> payload,
);

/// Directly run a diff between a blob and a buffer.
/// 
/// As with `git_diff_blobs`, comparing a blob and buffer lacks some context,
/// so the `git_diff_file` parameters to the callbacks will be faked a la the
/// rules for `git_diff_blobs()`.
/// 
/// Passing NULL for `old_blob` will be treated as an empty blob (i.e. the
/// `file_cb` will be invoked with GIT_DELTA_ADDED and the diff will be the
/// entire content of the buffer added).  Passing NULL to the buffer will do
/// the reverse, with GIT_DELTA_REMOVED and blob content removed.
/// 
/// @param old_blob Blob for old side of diff, or NULL for empty blob
/// @param old_as_path Treat old blob as if it had this filename; can be NULL
/// @param buffer Raw data for new side of diff, or NULL for empty
/// @param buffer_len Length of raw data for new side of diff
/// @param buffer_as_path Treat buffer as if it had this filename; can be NULL
/// @param options Options for diff, or NULL for default options
/// @param file_cb Callback for "file"; made once if there is a diff; can be NULL
/// @param binary_cb Callback for binary files; can be NULL
/// @param hunk_cb Callback for each hunk in diff; can be NULL
/// @param line_cb Callback for each line in diff; can be NULL
/// @param payload Payload passed to each callback function
/// @return 0 on success, non-zero callback return value, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_blob> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Size , ffi.Pointer<ffi.Char> , ffi.Pointer<git_diff_options> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Float progress, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_binary> binary, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<git_diff_line> line, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_diff_blob_to_buffer(ffi.Pointer<git_blob> old_blob,
ffi.Pointer<ffi.Char> old_as_path,
ffi.Pointer<ffi.Char> buffer,
int buffer_len,
ffi.Pointer<ffi.Char> buffer_as_path,
ffi.Pointer<git_diff_options> options,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Float progress, ffi.Pointer<ffi.Void> payload)>> file_cb,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_binary> binary, ffi.Pointer<ffi.Void> payload)>> binary_cb,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<ffi.Void> payload)>> hunk_cb,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<git_diff_line> line, ffi.Pointer<ffi.Void> payload)>> line_cb,
ffi.Pointer<ffi.Void> payload,
);

/// Directly run a diff between two buffers.
/// 
/// Even more than with `git_diff_blobs`, comparing two buffer lacks
/// context, so the `git_diff_file` parameters to the callbacks will be
/// faked a la the rules for `git_diff_blobs()`.
/// 
/// @param old_buffer Raw data for old side of diff, or NULL for empty
/// @param old_len Length of the raw data for old side of the diff
/// @param old_as_path Treat old buffer as if it had this filename; can be NULL
/// @param new_buffer Raw data for new side of diff, or NULL for empty
/// @param new_len Length of raw data for new side of diff
/// @param new_as_path Treat buffer as if it had this filename; can be NULL
/// @param options Options for diff, or NULL for default options
/// @param file_cb Callback for "file"; made once if there is a diff; can be NULL
/// @param binary_cb Callback for binary files; can be NULL
/// @param hunk_cb Callback for each hunk in diff; can be NULL
/// @param line_cb Callback for each line in diff; can be NULL
/// @param payload Payload passed to each callback function
/// @return 0 on success, non-zero callback return value, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Void> , ffi.Size , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Void> , ffi.Size , ffi.Pointer<ffi.Char> , ffi.Pointer<git_diff_options> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Float progress, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_binary> binary, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<git_diff_line> line, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_diff_buffers(ffi.Pointer<ffi.Void> old_buffer,
int old_len,
ffi.Pointer<ffi.Char> old_as_path,
ffi.Pointer<ffi.Void> new_buffer,
int new_len,
ffi.Pointer<ffi.Char> new_as_path,
ffi.Pointer<git_diff_options> options,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Float progress, ffi.Pointer<ffi.Void> payload)>> file_cb,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_binary> binary, ffi.Pointer<ffi.Void> payload)>> binary_cb,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<ffi.Void> payload)>> hunk_cb,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<git_diff_line> line, ffi.Pointer<ffi.Void> payload)>> line_cb,
ffi.Pointer<ffi.Void> payload,
);

/// Read the contents of a git patch file into a `git_diff` object.
/// 
/// The diff object produced is similar to the one that would be
/// produced if you actually produced it computationally by comparing
/// two trees, however there may be subtle differences.  For example,
/// a patch file likely contains abbreviated object IDs, so the
/// object IDs in a `git_diff_delta` produced by this function will
/// also be abbreviated.
/// 
/// This function will only read patch files created by a git
/// implementation, it will not read unified diffs produced by
/// the `diff` program, nor any other types of patch files.
/// 
/// @param out A pointer to a git_diff pointer that will be allocated.
/// @param content The contents of a patch file
/// @param content_len The length of the patch file contents
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_diff>> , ffi.Pointer<ffi.Char> , ffi.Size )>()
external int git_diff_from_buffer(ffi.Pointer<ffi.Pointer<git_diff>> out,
ffi.Pointer<ffi.Char> content,
int content_len,
);

/// Accumulate diff statistics for all patches.
/// 
/// @param out Structure containing the diff statistics.
/// @param diff A git_diff generated by one of the above functions.
/// @return 0 on success; non-zero on error
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_diff_stats>> , ffi.Pointer<git_diff> )>()
external int git_diff_get_stats(ffi.Pointer<ffi.Pointer<git_diff_stats>> out,
ffi.Pointer<git_diff> diff,
);

/// Get the total number of files changed in a diff
/// 
/// @param stats A `git_diff_stats` generated by one of the above functions.
/// @return total number of files changed in the diff
@ffi.Native<ffi.Size Function(ffi.Pointer<git_diff_stats> )>()
external int git_diff_stats_files_changed(ffi.Pointer<git_diff_stats> stats,
);

/// Get the total number of insertions in a diff
/// 
/// @param stats A `git_diff_stats` generated by one of the above functions.
/// @return total number of insertions in the diff
@ffi.Native<ffi.Size Function(ffi.Pointer<git_diff_stats> )>()
external int git_diff_stats_insertions(ffi.Pointer<git_diff_stats> stats,
);

/// Get the total number of deletions in a diff
/// 
/// @param stats A `git_diff_stats` generated by one of the above functions.
/// @return total number of deletions in the diff
@ffi.Native<ffi.Size Function(ffi.Pointer<git_diff_stats> )>()
external int git_diff_stats_deletions(ffi.Pointer<git_diff_stats> stats,
);

/// Print diff statistics to a `git_buf`.
/// 
/// @param out buffer to store the formatted diff statistics in.
/// @param stats A `git_diff_stats` generated by one of the above functions.
/// @param format Formatting option.
/// @param width Target width for output (only affects GIT_DIFF_STATS_FULL)
/// @return 0 on success; non-zero on error
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_diff_stats> , ffi.UnsignedInt , ffi.Size )>(symbol: 'git_diff_stats_to_buf')
external int _git_diff_stats_to_buf(ffi.Pointer<git_buf> out,
ffi.Pointer<git_diff_stats> stats,
int format,
int width,
);

int git_diff_stats_to_buf(ffi.Pointer<git_buf> out,
ffi.Pointer<git_diff_stats> stats,
git_diff_stats_format_t format,
int width,
) => _git_diff_stats_to_buf(out,
stats,
format.value,
width,
);

/// Deallocate a `git_diff_stats`.
/// 
/// @param stats The previously created statistics object;
/// cannot be used after free.
@ffi.Native<ffi.Void Function(ffi.Pointer<git_diff_stats> )>()
external void git_diff_stats_free(ffi.Pointer<git_diff_stats> stats,
);

/// Initialize git_diff_patchid_options structure
/// 
/// Initializes a `git_diff_patchid_options` with default values. Equivalent to
/// creating an instance with `GIT_DIFF_PATCHID_OPTIONS_INIT`.
/// 
/// @param opts The `git_diff_patchid_options` struct to initialize.
/// @param version The struct version; pass `GIT_DIFF_PATCHID_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_diff_patchid_options> , ffi.UnsignedInt )>()
external int git_diff_patchid_options_init(ffi.Pointer<git_diff_patchid_options> opts,
int version,
);

/// Calculate the patch ID for the given patch.
/// 
/// Calculate a stable patch ID for the given patch by summing the
/// hash of the file diffs, ignoring whitespace and line numbers.
/// This can be used to derive whether two diffs are the same with
/// a high probability.
/// 
/// Currently, this function only calculates stable patch IDs, as
/// defined in git-patch-id(1), and should in fact generate the
/// same IDs as the upstream git project does.
/// 
/// @param out Pointer where the calculated patch ID should be stored
/// @param diff The diff to calculate the ID for
/// @param opts Options for how to calculate the patch ID. This is
/// intended for future changes, as currently no options are
/// available.
/// @return 0 on success, an error code otherwise.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_diff> , ffi.Pointer<git_diff_patchid_options> )>()
external int git_diff_patchid(ffi.Pointer<git_oid> out,
ffi.Pointer<git_diff> diff,
ffi.Pointer<git_diff_patchid_options> opts,
);

/// Initialize git_apply_options structure
/// 
/// Initialize a `git_apply_options` with default values. Equivalent to creating
/// an instance with GIT_APPLY_OPTIONS_INIT.
/// 
/// @param opts The `git_apply_options` struct to initialize.
/// @param version The struct version; pass `GIT_APPLY_OPTIONS_VERSION`
/// @return 0 on success or -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_apply_options> , ffi.UnsignedInt )>()
external int git_apply_options_init(ffi.Pointer<git_apply_options> opts,
int version,
);

/// Apply a `git_diff` to a `git_tree`, and return the resulting image
/// as an index.
/// 
/// @param out the postimage of the application
/// @param repo the repository to apply
/// @param preimage the tree to apply the diff to
/// @param diff the diff to apply
/// @param options the options for the apply (or null for defaults)
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index>> , ffi.Pointer<git_repository> , ffi.Pointer<git_tree> , ffi.Pointer<git_diff> , ffi.Pointer<git_apply_options> )>()
external int git_apply_to_tree(ffi.Pointer<ffi.Pointer<git_index>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_tree> preimage,
ffi.Pointer<git_diff> diff,
ffi.Pointer<git_apply_options> options,
);

/// Apply a `git_diff` to the given repository, making changes directly
/// in the working directory, the index, or both.
/// 
/// @param repo the repository to apply to
/// @param diff the diff to apply
/// @param location the location to apply (workdir, index or both)
/// @param options the options for the apply (or null for defaults)
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<git_diff> , ffi.UnsignedInt , ffi.Pointer<git_apply_options> )>(symbol: 'git_apply')
external int _git_apply(ffi.Pointer<git_repository> repo,
ffi.Pointer<git_diff> diff,
int location,
ffi.Pointer<git_apply_options> options,
);

int git_apply(ffi.Pointer<git_repository> repo,
ffi.Pointer<git_diff> diff,
git_apply_location_t location,
ffi.Pointer<git_apply_options> options,
) => _git_apply(repo,
diff,
location.value,
options,
);

/// Return the value type for a given attribute.
/// 
/// This can be either `TRUE`, `FALSE`, `UNSPECIFIED` (if the attribute
/// was not set at all), or `VALUE`, if the attribute was set to an
/// actual string.
/// 
/// If the attribute has a `VALUE` string, it can be accessed normally
/// as a NULL-terminated C string.
/// 
/// @param attr The attribute
/// @return the value type for the attribute
@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<ffi.Char> )>(symbol: 'git_attr_value')
external int _git_attr_value(ffi.Pointer<ffi.Char> attr,
);

git_attr_value_t git_attr_value(ffi.Pointer<ffi.Char> attr,
) => git_attr_value_t.fromValue(_git_attr_value(attr,
));

/// Look up the value of one git attribute for path.
/// 
/// @param value_out Output of the value of the attribute.  Use the GIT_ATTR_...
/// macros to test for TRUE, FALSE, UNSPECIFIED, etc. or just
/// use the string value for attributes set to a value.  You
/// should NOT modify or free this value.
/// @param repo The repository containing the path.
/// @param flags A combination of GIT_ATTR_CHECK... flags.
/// @param path The path to check for attributes.  Relative paths are
/// interpreted relative to the repo root.  The file does
/// not have to exist, but if it does not, then it will be
/// treated as a plain file (not a directory).
/// @param name The name of the attribute to look up.
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>> , ffi.Pointer<git_repository> , ffi.Uint32 , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_attr_get(ffi.Pointer<ffi.Pointer<ffi.Char>> value_out,
ffi.Pointer<git_repository> repo,
int flags,
ffi.Pointer<ffi.Char> path,
ffi.Pointer<ffi.Char> name,
);

/// Look up the value of one git attribute for path with extended options.
/// 
/// @param value_out Output of the value of the attribute.  Use the GIT_ATTR_...
/// macros to test for TRUE, FALSE, UNSPECIFIED, etc. or just
/// use the string value for attributes set to a value.  You
/// should NOT modify or free this value.
/// @param repo The repository containing the path.
/// @param opts The `git_attr_options` to use when querying these attributes.
/// @param path The path to check for attributes.  Relative paths are
/// interpreted relative to the repo root.  The file does
/// not have to exist, but if it does not, then it will be
/// treated as a plain file (not a directory).
/// @param name The name of the attribute to look up.
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>> , ffi.Pointer<git_repository> , ffi.Pointer<git_attr_options> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_attr_get_ext(ffi.Pointer<ffi.Pointer<ffi.Char>> value_out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_attr_options> opts,
ffi.Pointer<ffi.Char> path,
ffi.Pointer<ffi.Char> name,
);

/// Look up a list of git attributes for path.
/// 
/// Use this if you have a known list of attributes that you want to
/// look up in a single call.  This is somewhat more efficient than
/// calling `git_attr_get()` multiple times.
/// 
/// For example, you might write:
/// 
/// const char *attrs[] = { "crlf", "diff", "foo" };
/// const char **values[3];
/// git_attr_get_many(values, repo, 0, "my/fun/file.c", 3, attrs);
/// 
/// Then you could loop through the 3 values to get the settings for
/// the three attributes you asked about.
/// 
/// @param values_out An array of num_attr entries that will have string
/// pointers written into it for the values of the attributes.
/// You should not modify or free the values that are written
/// into this array (although of course, you should free the
/// array itself if you allocated it).
/// @param repo The repository containing the path.
/// @param flags A combination of GIT_ATTR_CHECK... flags.
/// @param path The path inside the repo to check attributes.  This
/// does not have to exist, but if it does not, then
/// it will be treated as a plain file (i.e. not a directory).
/// @param num_attr The number of attributes being looked up
/// @param names An array of num_attr strings containing attribute names.
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>> , ffi.Pointer<git_repository> , ffi.Uint32 , ffi.Pointer<ffi.Char> , ffi.Size , ffi.Pointer<ffi.Pointer<ffi.Char>> )>()
external int git_attr_get_many(ffi.Pointer<ffi.Pointer<ffi.Char>> values_out,
ffi.Pointer<git_repository> repo,
int flags,
ffi.Pointer<ffi.Char> path,
int num_attr,
ffi.Pointer<ffi.Pointer<ffi.Char>> names,
);

/// Look up a list of git attributes for path with extended options.
/// 
/// @param values_out An array of num_attr entries that will have string
/// pointers written into it for the values of the attributes.
/// You should not modify or free the values that are written
/// into this array (although of course, you should free the
/// array itself if you allocated it).
/// @param repo The repository containing the path.
/// @param opts The `git_attr_options` to use when querying these attributes.
/// @param path The path inside the repo to check attributes.  This
/// does not have to exist, but if it does not, then
/// it will be treated as a plain file (i.e. not a directory).
/// @param num_attr The number of attributes being looked up
/// @param names An array of num_attr strings containing attribute names.
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>> , ffi.Pointer<git_repository> , ffi.Pointer<git_attr_options> , ffi.Pointer<ffi.Char> , ffi.Size , ffi.Pointer<ffi.Pointer<ffi.Char>> )>()
external int git_attr_get_many_ext(ffi.Pointer<ffi.Pointer<ffi.Char>> values_out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_attr_options> opts,
ffi.Pointer<ffi.Char> path,
int num_attr,
ffi.Pointer<ffi.Pointer<ffi.Char>> names,
);

/// Loop over all the git attributes for a path.
/// 
/// @param repo The repository containing the path.
/// @param flags A combination of GIT_ATTR_CHECK... flags.
/// @param path Path inside the repo to check attributes.  This does not have
/// to exist, but if it does not, then it will be treated as a
/// plain file (i.e. not a directory).
/// @param callback Function to invoke on each attribute name and value.
/// See git_attr_foreach_cb.
/// @param payload Passed on as extra parameter to callback function.
/// @return 0 on success, non-zero callback return value, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Uint32 , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> name, ffi.Pointer<ffi.Char> value, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_attr_foreach(ffi.Pointer<git_repository> repo,
int flags,
ffi.Pointer<ffi.Char> path,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> name, ffi.Pointer<ffi.Char> value, ffi.Pointer<ffi.Void> payload)>> callback,
ffi.Pointer<ffi.Void> payload,
);

/// Loop over all the git attributes for a path with extended options.
/// 
/// @param repo The repository containing the path.
/// @param opts The `git_attr_options` to use when querying these attributes.
/// @param path Path inside the repo to check attributes.  This does not have
/// to exist, but if it does not, then it will be treated as a
/// plain file (i.e. not a directory).
/// @param callback Function to invoke on each attribute name and value.
/// See git_attr_foreach_cb.
/// @param payload Passed on as extra parameter to callback function.
/// @return 0 on success, non-zero callback return value, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<git_attr_options> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> name, ffi.Pointer<ffi.Char> value, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_attr_foreach_ext(ffi.Pointer<git_repository> repo,
ffi.Pointer<git_attr_options> opts,
ffi.Pointer<ffi.Char> path,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> name, ffi.Pointer<ffi.Char> value, ffi.Pointer<ffi.Void> payload)>> callback,
ffi.Pointer<ffi.Void> payload,
);

/// Flush the gitattributes cache.
/// 
/// Call this if you have reason to believe that the attributes files on
/// disk no longer match the cached contents of memory.  This will cause
/// the attributes files to be reloaded the next time that an attribute
/// access function is called.
/// 
/// @param repo The repository containing the gitattributes cache
/// @return 0 on success, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> )>()
external int git_attr_cache_flush(ffi.Pointer<git_repository> repo,
);

/// Add a macro definition.
/// 
/// Macros will automatically be loaded from the top level `.gitattributes`
/// file of the repository (plus the built-in "binary" macro).  This
/// function allows you to add others.  For example, to add the default
/// macro, you would call:
/// 
/// git_attr_add_macro(repo, "binary", "-diff -crlf");
/// 
/// @param repo The repository to add the macro in.
/// @param name The name of the macro.
/// @param values The value for the macro.
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_attr_add_macro(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
ffi.Pointer<ffi.Char> values,
);

/// Lookup a blob object from a repository.
/// 
/// @param[out] blob pointer to the looked up blob
/// @param repo the repo to use when locating the blob.
/// @param id identity of the blob to locate.
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_blob>> , ffi.Pointer<git_repository> , ffi.Pointer<git_oid> )>()
external int git_blob_lookup(ffi.Pointer<ffi.Pointer<git_blob>> blob,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_oid> id,
);

/// Lookup a blob object from a repository,
/// given a prefix of its identifier (short id).
/// 
/// @see git_object_lookup_prefix
/// 
/// @param[out] blob pointer to the looked up blob
/// @param repo the repo to use when locating the blob.
/// @param id identity of the blob to locate.
/// @param len the length of the short identifier
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_blob>> , ffi.Pointer<git_repository> , ffi.Pointer<git_oid> , ffi.Size )>()
external int git_blob_lookup_prefix(ffi.Pointer<ffi.Pointer<git_blob>> blob,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_oid> id,
int len,
);

/// Close an open blob
/// 
/// This is a wrapper around git_object_free()
/// 
/// IMPORTANT:
/// It *is* necessary to call this method when you stop
/// using a blob. Failure to do so will cause a memory leak.
/// 
/// @param blob the blob to close
@ffi.Native<ffi.Void Function(ffi.Pointer<git_blob> )>()
external void git_blob_free(ffi.Pointer<git_blob> blob,
);

/// Get the id of a blob.
/// 
/// @param blob a previously loaded blob.
/// @return SHA1 hash for this blob.
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_blob> )>()
external ffi.Pointer<git_oid> git_blob_id(ffi.Pointer<git_blob> blob,
);

/// Get the repository that contains the blob.
/// 
/// @param blob A previously loaded blob.
/// @return Repository that contains this blob.
@ffi.Native<ffi.Pointer<git_repository> Function(ffi.Pointer<git_blob> )>()
external ffi.Pointer<git_repository> git_blob_owner(ffi.Pointer<git_blob> blob,
);

/// Get a read-only buffer with the raw content of a blob.
/// 
/// A pointer to the raw content of a blob is returned;
/// this pointer is owned internally by the object and shall
/// not be free'd. The pointer may be invalidated at a later
/// time.
/// 
/// @param blob pointer to the blob
/// @return @type `unsigned char *` the pointer, or NULL on error
@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Pointer<git_blob> )>()
external ffi.Pointer<ffi.Void> git_blob_rawcontent(ffi.Pointer<git_blob> blob,
);

/// Get the size in bytes of the contents of a blob
/// 
/// @param blob pointer to the blob
/// @return size in bytes
@ffi.Native<ffi.Uint64 Function(ffi.Pointer<git_blob> )>()
external int git_blob_rawsize(ffi.Pointer<git_blob> blob,
);

/// Initialize git_blob_filter_options structure
/// 
/// Initializes a `git_blob_filter_options` with default values. Equivalent
/// to creating an instance with `GIT_BLOB_FILTER_OPTIONS_INIT`.
/// 
/// @param opts The `git_blob_filter_options` struct to initialize.
/// @param version The struct version; pass GIT_BLOB_FILTER_OPTIONS_VERSION
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_blob_filter_options> , ffi.UnsignedInt )>()
external int git_blob_filter_options_init(ffi.Pointer<git_blob_filter_options> opts,
int version,
);

/// Get a buffer with the filtered content of a blob.
/// 
/// This applies filters as if the blob was being checked out to the
/// working directory under the specified filename.  This may apply
/// CRLF filtering or other types of changes depending on the file
/// attributes set for the blob and the content detected in it.
/// 
/// The output is written into a `git_buf` which the caller must dispose
/// when done (via `git_buf_dispose`).
/// 
/// If no filters need to be applied, then the `out` buffer will just
/// be populated with a pointer to the raw content of the blob.  In
/// that case, be careful to *not* free the blob until done with the
/// buffer or copy it into memory you own.
/// 
/// @param out The git_buf to be filled in
/// @param blob Pointer to the blob
/// @param as_path Path used for file attribute lookups, etc.
/// @param opts Options to use for filtering the blob
/// @return @type[enum] git_error_code 0 on success or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_blob> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_blob_filter_options> )>()
external int git_blob_filter(ffi.Pointer<git_buf> out,
ffi.Pointer<git_blob> blob,
ffi.Pointer<ffi.Char> as_path,
ffi.Pointer<git_blob_filter_options> opts,
);

/// Read a file from the working folder of a repository and write it
/// to the object database.
/// 
/// @param[out] id return the id of the written blob
/// @param repo repository where the blob will be written.
/// this repository cannot be bare
/// @param relative_path file from which the blob will be created,
/// relative to the repository's working dir
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_blob_create_from_workdir(ffi.Pointer<git_oid> id,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> relative_path,
);

/// Read a file from the filesystem (not necessarily inside the
/// working folder of the repository) and write it to the object
/// database.
/// 
/// @param[out] id return the id of the written blob
/// @param repo repository where the blob will be written.
/// this repository can be bare or not
/// @param path file from which the blob will be created
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_blob_create_from_disk(ffi.Pointer<git_oid> id,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> path,
);

/// Create a stream to write a new blob into the object database.
/// 
/// This function may need to buffer the data on disk and will in
/// general not be the right choice if you know the size of the data
/// to write. If you have data in memory, use
/// `git_blob_create_from_buffer()`. If you do not, but know the size of
/// the contents (and don't want/need to perform filtering), use
/// `git_odb_open_wstream()`.
/// 
/// Don't close this stream yourself but pass it to
/// `git_blob_create_from_stream_commit()` to commit the write to the
/// object db and get the object id.
/// 
/// If the `hintpath` parameter is filled, it will be used to determine
/// what git filters should be applied to the object before it is written
/// to the object database.
/// 
/// @param[out] out the stream into which to write
/// @param repo Repository where the blob will be written.
/// This repository can be bare or not.
/// @param hintpath If not NULL, will be used to select data filters
/// to apply onto the content of the blob to be created.
/// @return 0 or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_writestream>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_blob_create_from_stream(ffi.Pointer<ffi.Pointer<git_writestream>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> hintpath,
);

/// Close the stream and finalize writing the blob to the object database.
/// 
/// The stream will be closed and freed.
/// 
/// @param[out] out the id of the new blob
/// @param stream the stream to close
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_writestream> )>()
external int git_blob_create_from_stream_commit(ffi.Pointer<git_oid> out,
ffi.Pointer<git_writestream> stream,
);

/// Write an in-memory buffer to the object database as a blob.
/// 
/// @param[out] id return the id of the written blob
/// @param repo repository where the blob will be written
/// @param buffer data to be written into the blob
/// @param len length of the data
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Void> , ffi.Size )>()
external int git_blob_create_from_buffer(ffi.Pointer<git_oid> id,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Void> buffer,
int len,
);

/// Determine if the blob content is most likely binary or not.
/// 
/// The heuristic used to guess if a file is binary is taken from core git:
/// Searching for NUL bytes and looking for a reasonable ratio of printable
/// to non-printable characters among the first 8000 bytes.
/// 
/// @param blob The blob which content should be analyzed
/// @return @type bool 1 if the content of the blob is detected
/// as binary; 0 otherwise.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_blob> )>()
external int git_blob_is_binary(ffi.Pointer<git_blob> blob,
);

/// Determine if the given content is most certainly binary or not;
/// this is the same mechanism used by `git_blob_is_binary` but only
/// looking at raw data.
/// 
/// @param data The blob data which content should be analyzed
/// @param len The length of the data
/// @return 1 if the content of the blob is detected
/// as binary; 0 otherwise.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char> , ffi.Size )>()
external int git_blob_data_is_binary(ffi.Pointer<ffi.Char> data,
int len,
);

/// Create an in-memory copy of a blob. The copy must be explicitly
/// free'd or it will leak.
/// 
/// @param[out] out Pointer to store the copy of the object
/// @param source Original object to copy
/// @return 0.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_blob>> , ffi.Pointer<git_blob> )>()
external int git_blob_dup(ffi.Pointer<ffi.Pointer<git_blob>> out,
ffi.Pointer<git_blob> source,
);

/// Initialize git_blame_options structure
/// 
/// Initializes a `git_blame_options` with default values. Equivalent to creating
/// an instance with GIT_BLAME_OPTIONS_INIT.
/// 
/// @param opts The `git_blame_options` struct to initialize.
/// @param version The struct version; pass `GIT_BLAME_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_blame_options> , ffi.UnsignedInt )>()
external int git_blame_options_init(ffi.Pointer<git_blame_options> opts,
int version,
);

/// Gets the number of lines that exist in the blame structure.
/// 
/// @param blame The blame structure to query.
/// @return The number of line.
@ffi.Native<ffi.Size Function(ffi.Pointer<git_blame> )>()
external int git_blame_linecount(ffi.Pointer<git_blame> blame,
);

/// Gets the number of hunks that exist in the blame structure.
/// 
/// @param blame The blame structure to query.
/// @return The number of hunks.
@ffi.Native<ffi.Size Function(ffi.Pointer<git_blame> )>()
external int git_blame_hunkcount(ffi.Pointer<git_blame> blame,
);

/// Gets the blame hunk at the given index.
/// 
/// @param blame the blame structure to query
/// @param index index of the hunk to retrieve
/// @return the hunk at the given index, or NULL on error
@ffi.Native<ffi.Pointer<git_blame_hunk> Function(ffi.Pointer<git_blame> , ffi.Size )>()
external ffi.Pointer<git_blame_hunk> git_blame_hunk_byindex(ffi.Pointer<git_blame> blame,
int index,
);

/// Gets the hunk that relates to the given line number in the newest
/// commit.
/// 
/// @param blame the blame structure to query
/// @param lineno the (1-based) line number to find a hunk for
/// @return the hunk that contains the given line, or NULL on error
@ffi.Native<ffi.Pointer<git_blame_hunk> Function(ffi.Pointer<git_blame> , ffi.Size )>()
external ffi.Pointer<git_blame_hunk> git_blame_hunk_byline(ffi.Pointer<git_blame> blame,
int lineno,
);

/// Gets the information about the line in the blame.
/// 
/// @param blame the blame structure to query
/// @param idx the (1-based) line number
/// @return the blamed line, or NULL on error
@ffi.Native<ffi.Pointer<git_blame_line> Function(ffi.Pointer<git_blame> , ffi.Size )>()
external ffi.Pointer<git_blame_line> git_blame_line_byindex(ffi.Pointer<git_blame> blame,
int idx,
);

/// Gets the number of hunks that exist in the blame structure.
/// 
/// @param blame The blame structure to query.
/// @return The number of hunks.
@ffi.Native<ffi.Uint32 Function(ffi.Pointer<git_blame> )>()
external int git_blame_get_hunk_count(ffi.Pointer<git_blame> blame,
);

/// Gets the blame hunk at the given index.
/// 
/// @param blame the blame structure to query
/// @param index index of the hunk to retrieve
/// @return the hunk at the given index, or NULL on error
@ffi.Native<ffi.Pointer<git_blame_hunk> Function(ffi.Pointer<git_blame> , ffi.Uint32 )>()
external ffi.Pointer<git_blame_hunk> git_blame_get_hunk_byindex(ffi.Pointer<git_blame> blame,
int index,
);

/// Gets the hunk that relates to the given line number in the newest commit.
/// 
/// @param blame the blame structure to query
/// @param lineno the (1-based) line number to find a hunk for
/// @return the hunk that contains the given line, or NULL on error
@ffi.Native<ffi.Pointer<git_blame_hunk> Function(ffi.Pointer<git_blame> , ffi.Size )>()
external ffi.Pointer<git_blame_hunk> git_blame_get_hunk_byline(ffi.Pointer<git_blame> blame,
int lineno,
);

/// Get the blame for a single file in the repository.
/// 
/// @param out pointer that will receive the blame object
/// @param repo repository whose history is to be walked
/// @param path path to file to consider
/// @param options options for the blame operation or NULL
/// @return 0 on success, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_blame>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_blame_options> )>()
external int git_blame_file(ffi.Pointer<ffi.Pointer<git_blame>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> path,
ffi.Pointer<git_blame_options> options,
);

/// Get the blame for a single file in the repository, using the specified
/// buffer contents as the uncommitted changes of the file (the working
/// directory contents).
/// 
/// @param out pointer that will receive the blame object
/// @param repo repository whose history is to be walked
/// @param path path to file to consider
/// @param contents the uncommitted changes
/// @param contents_len the length of the changes buffer
/// @param options options for the blame operation or NULL
/// @return 0 on success, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_blame>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Size , ffi.Pointer<git_blame_options> )>()
external int git_blame_file_from_buffer(ffi.Pointer<ffi.Pointer<git_blame>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> path,
ffi.Pointer<ffi.Char> contents,
int contents_len,
ffi.Pointer<git_blame_options> options,
);

/// Get blame data for a file that has been modified in memory. The `blame`
/// parameter is a pre-calculated blame for the in-odb history of the file.
/// This means that once a file blame is completed (which can be expensive),
/// updating the buffer blame is very fast.
/// 
/// Lines that differ between the buffer and the committed version are
/// marked as having a zero OID for their final_commit_id.
/// 
/// @param out pointer that will receive the resulting blame data
/// @param base cached blame from the history of the file (usually the output
/// from git_blame_file)
/// @param buffer the (possibly) modified contents of the file
/// @param buffer_len number of valid bytes in the buffer
/// @return 0 on success, or an error code. (use git_error_last for information
/// about the error)
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_blame>> , ffi.Pointer<git_blame> , ffi.Pointer<ffi.Char> , ffi.Size )>()
external int git_blame_buffer(ffi.Pointer<ffi.Pointer<git_blame>> out,
ffi.Pointer<git_blame> base,
ffi.Pointer<ffi.Char> buffer,
int buffer_len,
);

/// Free memory allocated by git_blame_file or git_blame_buffer.
/// 
/// @param blame the blame structure to free
@ffi.Native<ffi.Void Function(ffi.Pointer<git_blame> )>()
external void git_blame_free(ffi.Pointer<git_blame> blame,
);

/// Create a new branch pointing at a target commit
/// 
/// A new direct reference will be created pointing to
/// this target commit. If `force` is true and a reference
/// already exists with the given name, it'll be replaced.
/// 
/// The returned reference must be freed by the user.
/// 
/// The branch name will be checked for validity.
/// See `git_tag_create()` for rules about valid names.
/// 
/// @param out Pointer where to store the underlying reference.
/// @param repo the repository to create the branch in.
/// @param branch_name Name for the branch; this name is
/// validated for consistency. It should also not conflict with
/// an already existing branch name.
/// @param target Commit to which this branch should point. This object
/// must belong to the given `repo`.
/// @param force Overwrite existing branch.
/// @return 0, GIT_EINVALIDSPEC or an error code.
/// A proper reference is written in the refs/heads namespace
/// pointing to the provided target commit.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_commit> , ffi.Int )>()
external int git_branch_create(ffi.Pointer<ffi.Pointer<git_reference>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> branch_name,
ffi.Pointer<git_commit> target,
int force,
);

/// Create a new branch pointing at a target commit
/// 
/// This behaves like `git_branch_create()` but takes an annotated
/// commit, which lets you specify which extended sha syntax string was
/// specified by a user, allowing for more exact reflog messages.
/// 
/// @param ref_out Pointer where to store the underlying reference.
/// @param repo the repository to create the branch in.
/// @param branch_name Name for the branch; this name is
/// validated for consistency. It should also not conflict with
/// an already existing branch name.
/// @param target Annotated commit to which this branch should point. This
/// object must belong to the given `repo`.
/// @param force Overwrite existing branch.
/// @return 0, GIT_EINVALIDSPEC or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_annotated_commit> , ffi.Int )>()
external int git_branch_create_from_annotated(ffi.Pointer<ffi.Pointer<git_reference>> ref_out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> branch_name,
ffi.Pointer<git_annotated_commit> target,
int force,
);

/// Delete an existing branch reference.
/// 
/// Note that if the deletion succeeds, the reference object will not
/// be valid anymore, and should be freed immediately by the user using
/// `git_reference_free()`.
/// 
/// @param branch A valid reference representing a branch
/// @return 0 on success, or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_reference> )>()
external int git_branch_delete(ffi.Pointer<git_reference> branch,
);

/// Create an iterator which loops over the requested branches.
/// 
/// @param out the iterator
/// @param repo Repository where to find the branches.
/// @param list_flags Filtering flags for the branch
/// listing. Valid values are GIT_BRANCH_LOCAL, GIT_BRANCH_REMOTE
/// or GIT_BRANCH_ALL.
/// 
/// @return 0 on success  or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_branch_iterator>> , ffi.Pointer<git_repository> , ffi.UnsignedInt )>(symbol: 'git_branch_iterator_new')
external int _git_branch_iterator_new(ffi.Pointer<ffi.Pointer<git_branch_iterator>> out,
ffi.Pointer<git_repository> repo,
int list_flags,
);

int git_branch_iterator_new(ffi.Pointer<ffi.Pointer<git_branch_iterator>> out,
ffi.Pointer<git_repository> repo,
git_branch_t list_flags,
) => _git_branch_iterator_new(out,
repo,
list_flags.value,
);

/// Retrieve the next branch from the iterator
/// 
/// @param out the reference
/// @param out_type the type of branch (local or remote-tracking)
/// @param iter the branch iterator
/// @return 0 on success, GIT_ITEROVER if there are no more branches or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>> , ffi.Pointer<ffi.UnsignedInt> , ffi.Pointer<git_branch_iterator> )>()
external int git_branch_next(ffi.Pointer<ffi.Pointer<git_reference>> out,
ffi.Pointer<ffi.UnsignedInt> out_type,
ffi.Pointer<git_branch_iterator> iter,
);

/// Free a branch iterator
/// 
/// @param iter the iterator to free
@ffi.Native<ffi.Void Function(ffi.Pointer<git_branch_iterator> )>()
external void git_branch_iterator_free(ffi.Pointer<git_branch_iterator> iter,
);

/// Move/rename an existing local branch reference.
/// 
/// The new branch name will be checked for validity.
/// See `git_tag_create()` for rules about valid names.
/// 
/// Note that if the move succeeds, the old reference object will not
/// be valid anymore, and should be freed immediately by the user using
/// `git_reference_free()`.
/// 
/// @param out New reference object for the updated name.
/// 
/// @param branch Current underlying reference of the branch.
/// 
/// @param new_branch_name Target name of the branch once the move
/// is performed; this name is validated for consistency.
/// 
/// @param force Overwrite existing branch.
/// 
/// @return 0 on success, GIT_EINVALIDSPEC or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>> , ffi.Pointer<git_reference> , ffi.Pointer<ffi.Char> , ffi.Int )>()
external int git_branch_move(ffi.Pointer<ffi.Pointer<git_reference>> out,
ffi.Pointer<git_reference> branch,
ffi.Pointer<ffi.Char> new_branch_name,
int force,
);

/// Lookup a branch by its name in a repository.
/// 
/// The generated reference must be freed by the user.
/// The branch name will be checked for validity.
/// 
/// @see git_tag_create for rules about valid names.
/// 
/// @param out pointer to the looked-up branch reference
/// @param repo the repository to look up the branch
/// @param branch_name Name of the branch to be looked-up;
/// this name is validated for consistency.
/// @param branch_type Type of the considered branch. This should
/// be valued with either GIT_BRANCH_LOCAL or GIT_BRANCH_REMOTE.
/// 
/// @return 0 on success; GIT_ENOTFOUND when no matching branch
/// exists, GIT_EINVALIDSPEC, otherwise an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.UnsignedInt )>(symbol: 'git_branch_lookup')
external int _git_branch_lookup(ffi.Pointer<ffi.Pointer<git_reference>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> branch_name,
int branch_type,
);

int git_branch_lookup(ffi.Pointer<ffi.Pointer<git_reference>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> branch_name,
git_branch_t branch_type,
) => _git_branch_lookup(out,
repo,
branch_name,
branch_type.value,
);

/// Get the branch name
/// 
/// Given a reference object, this will check that it really is a branch (ie.
/// it lives under "refs/heads/" or "refs/remotes/"), and return the branch part
/// of it.
/// 
/// @param out Pointer to the abbreviated reference name.
/// Owned by ref, do not free.
/// 
/// @param ref A reference object, ideally pointing to a branch
/// 
/// @return 0 on success; GIT_EINVALID if the reference isn't either a local or
/// remote branch, otherwise an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>> , ffi.Pointer<git_reference> )>()
external int git_branch_name(ffi.Pointer<ffi.Pointer<ffi.Char>> out,
ffi.Pointer<git_reference> ref,
);

/// Get the upstream of a branch
/// 
/// Given a reference, this will return a new reference object corresponding
/// to its remote tracking branch. The reference must be a local branch.
/// 
/// @see git_branch_upstream_name for details on the resolution.
/// 
/// @param out Pointer where to store the retrieved reference.
/// @param branch Current underlying reference of the branch.
/// 
/// @return 0 on success; GIT_ENOTFOUND when no remote tracking
/// reference exists, otherwise an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>> , ffi.Pointer<git_reference> )>()
external int git_branch_upstream(ffi.Pointer<ffi.Pointer<git_reference>> out,
ffi.Pointer<git_reference> branch,
);

/// Set a branch's upstream branch
/// 
/// This will update the configuration to set the branch named `branch_name` as the upstream of `branch`.
/// Pass a NULL name to unset the upstream information.
/// 
/// @note the actual tracking reference must have been already created for the
/// operation to succeed.
/// 
/// @param branch the branch to configure
/// @param branch_name remote-tracking or local branch to set as upstream.
/// 
/// @return @type git_error_t 0 on success; GIT_ENOTFOUND if there's no branch named `branch_name`
/// or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_reference> , ffi.Pointer<ffi.Char> )>()
external int git_branch_set_upstream(ffi.Pointer<git_reference> branch,
ffi.Pointer<ffi.Char> branch_name,
);

/// Get the upstream name of a branch
/// 
/// Given a local branch, this will return its remote-tracking branch information,
/// as a full reference name, ie. "feature/nice" would become
/// "refs/remote/origin/feature/nice", depending on that branch's configuration.
/// 
/// @param out the buffer into which the name will be written.
/// @param repo the repository where the branches live.
/// @param refname reference name of the local branch.
/// 
/// @return 0 on success, GIT_ENOTFOUND when no remote tracking reference exists,
/// or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_branch_upstream_name(ffi.Pointer<git_buf> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> refname,
);

/// Determine if HEAD points to the given branch
/// 
/// @param branch A reference to a local branch.
/// 
/// @return 1 if HEAD points at the branch, 0 if it isn't, or a negative value
/// as an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_reference> )>()
external int git_branch_is_head(ffi.Pointer<git_reference> branch,
);

/// Determine if any HEAD points to the current branch
/// 
/// This will iterate over all known linked repositories (usually in the form of
/// worktrees) and report whether any HEAD is pointing at the current branch.
/// 
/// @param branch A reference to a local branch.
/// 
/// @return 1 if branch is checked out, 0 if it isn't, an error code otherwise.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_reference> )>()
external int git_branch_is_checked_out(ffi.Pointer<git_reference> branch,
);

/// Find the remote name of a remote-tracking branch
/// 
/// This will return the name of the remote whose fetch refspec is matching
/// the given branch. E.g. given a branch "refs/remotes/test/master", it will
/// extract the "test" part. If refspecs from multiple remotes match,
/// the function will return GIT_EAMBIGUOUS.
/// 
/// @param out The buffer into which the name will be written.
/// @param repo The repository where the branch lives.
/// @param refname complete name of the remote tracking branch.
/// 
/// @return 0 on success, GIT_ENOTFOUND when no matching remote was found,
/// GIT_EAMBIGUOUS when the branch maps to several remotes,
/// otherwise an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_branch_remote_name(ffi.Pointer<git_buf> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> refname,
);

/// Retrieve the upstream remote of a local branch
/// 
/// This will return the currently configured "branch.*.remote" for a given
/// branch. This branch must be local.
/// 
/// @param buf the buffer into which to write the name
/// @param repo the repository in which to look
/// @param refname the full name of the branch
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_branch_upstream_remote(ffi.Pointer<git_buf> buf,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> refname,
);

/// Retrieve the upstream merge of a local branch
/// 
/// This will return the currently configured "branch.*.merge" for a given
/// branch. This branch must be local.
/// 
/// @param buf the buffer into which to write the name
/// @param repo the repository in which to look
/// @param refname the full name of the branch
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_branch_upstream_merge(ffi.Pointer<git_buf> buf,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> refname,
);

/// Determine whether a branch name is valid, meaning that (when prefixed
/// with `refs/heads/`) that it is a valid reference name, and that any
/// additional branch name restrictions are imposed (eg, it cannot start
/// with a `-`).
/// 
/// @param valid output pointer to set with validity of given branch name
/// @param name a branch name to test
/// @return 0 on success or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Int> , ffi.Pointer<ffi.Char> )>()
external int git_branch_name_is_valid(ffi.Pointer<ffi.Int> valid,
ffi.Pointer<ffi.Char> name,
);

/// Initialize git_checkout_options structure
/// 
/// Initializes a `git_checkout_options` with default values. Equivalent to creating
/// an instance with GIT_CHECKOUT_OPTIONS_INIT.
/// 
/// @param opts The `git_checkout_options` struct to initialize.
/// @param version The struct version; pass `GIT_CHECKOUT_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_checkout_options> , ffi.UnsignedInt )>()
external int git_checkout_options_init(ffi.Pointer<git_checkout_options> opts,
int version,
);

/// Updates files in the index and the working tree to match the content of
/// the commit pointed at by HEAD.
/// 
/// Note that this is _not_ the correct mechanism used to switch branches;
/// do not change your `HEAD` and then call this method, that would leave
/// you with checkout conflicts since your working directory would then
/// appear to be dirty.  Instead, checkout the target of the branch and
/// then update `HEAD` using `git_repository_set_head` to point to the
/// branch you checked out.
/// 
/// @param repo repository to check out (must be non-bare)
/// @param opts specifies checkout options (may be NULL)
/// @return 0 on success, GIT_EUNBORNBRANCH if HEAD points to a non
/// existing branch, non-zero value returned by `notify_cb`, or
/// other error code < 0 (use git_error_last for error details)
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<git_checkout_options> )>()
external int git_checkout_head(ffi.Pointer<git_repository> repo,
ffi.Pointer<git_checkout_options> opts,
);

/// Updates files in the working tree to match the content of the index.
/// 
/// @param repo repository into which to check out (must be non-bare)
/// @param index index to be checked out (or NULL to use repository index)
/// @param opts specifies checkout options (may be NULL)
/// @return 0 on success, non-zero return value from `notify_cb`, or error
/// code < 0 (use git_error_last for error details)
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<git_index> , ffi.Pointer<git_checkout_options> )>()
external int git_checkout_index(ffi.Pointer<git_repository> repo,
ffi.Pointer<git_index> index,
ffi.Pointer<git_checkout_options> opts,
);

/// Updates files in the index and working tree to match the content of the
/// tree pointed at by the treeish.
/// 
/// @param repo repository to check out (must be non-bare)
/// @param treeish a commit, tag or tree which content will be used to update
/// the working directory (or NULL to use HEAD)
/// @param opts specifies checkout options (may be NULL)
/// @return 0 on success, non-zero return value from `notify_cb`, or error
/// code < 0 (use git_error_last for error details)
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<git_object> , ffi.Pointer<git_checkout_options> )>()
external int git_checkout_tree(ffi.Pointer<git_repository> repo,
ffi.Pointer<git_object> treeish,
ffi.Pointer<git_checkout_options> opts,
);

/// Create a new bare Git index object as a memory representation
/// of the Git index file in 'index_path', without a repository
/// to back it.
/// 
/// Since there is no ODB or working directory behind this index,
/// any Index methods which rely on these (e.g. index_add_bypath)
/// will fail with the GIT_ERROR error code.
/// 
/// If you need to access the index of an actual repository,
/// use the `git_repository_index` wrapper.
/// 
/// The index must be freed once it's no longer in use.
/// 
/// @param index_out the pointer for the new index
/// @param index_path the path to the index file in disk
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index>> , ffi.Pointer<ffi.Char> )>()
external int git_index_open(ffi.Pointer<ffi.Pointer<git_index>> index_out,
ffi.Pointer<ffi.Char> index_path,
);

/// Create an in-memory index object.
/// 
/// This index object cannot be read/written to the filesystem,
/// but may be used to perform in-memory index operations.
/// 
/// The index must be freed once it's no longer in use.
/// 
/// @param index_out the pointer for the new index
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index>> )>()
external int git_index_new(ffi.Pointer<ffi.Pointer<git_index>> index_out,
);

/// Free an existing index object.
/// 
/// @param index an existing index object
@ffi.Native<ffi.Void Function(ffi.Pointer<git_index> )>()
external void git_index_free(ffi.Pointer<git_index> index,
);

/// Get the repository this index relates to
/// 
/// @param index The index
/// @return A pointer to the repository
@ffi.Native<ffi.Pointer<git_repository> Function(ffi.Pointer<git_index> )>()
external ffi.Pointer<git_repository> git_index_owner(ffi.Pointer<git_index> index,
);

/// Read index capabilities flags.
/// 
/// @param index An existing index object
/// @return A combination of GIT_INDEX_CAPABILITY values
@ffi.Native<ffi.Int Function(ffi.Pointer<git_index> )>()
external int git_index_caps(ffi.Pointer<git_index> index,
);

/// Set index capabilities flags.
/// 
/// If you pass `GIT_INDEX_CAPABILITY_FROM_OWNER` for the caps, then
/// capabilities will be read from the config of the owner object,
/// looking at `core.ignorecase`, `core.filemode`, `core.symlinks`.
/// 
/// @param index An existing index object
/// @param caps A combination of GIT_INDEX_CAPABILITY values
/// @return 0 on success, -1 on failure
@ffi.Native<ffi.Int Function(ffi.Pointer<git_index> , ffi.Int )>()
external int git_index_set_caps(ffi.Pointer<git_index> index,
int caps,
);

/// Get index on-disk version.
/// 
/// Valid return values are 2, 3, or 4.  If 3 is returned, an index
/// with version 2 may be written instead, if the extension data in
/// version 3 is not necessary.
/// 
/// @param index An existing index object
/// @return the index version
@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<git_index> )>()
external int git_index_version(ffi.Pointer<git_index> index,
);

/// Set index on-disk version.
/// 
/// Valid values are 2, 3, or 4.  If 2 is given, git_index_write may
/// write an index with version 3 instead, if necessary to accurately
/// represent the index.
/// 
/// @param index An existing index object
/// @param version The new version number
/// @return 0 on success, -1 on failure
@ffi.Native<ffi.Int Function(ffi.Pointer<git_index> , ffi.UnsignedInt )>()
external int git_index_set_version(ffi.Pointer<git_index> index,
int version,
);

/// Update the contents of an existing index object in memory by reading
/// from the hard disk.
/// 
/// If `force` is true, this performs a "hard" read that discards in-memory
/// changes and always reloads the on-disk index data.  If there is no
/// on-disk version, the index will be cleared.
/// 
/// If `force` is false, this does a "soft" read that reloads the index
/// data from disk only if it has changed since the last time it was
/// loaded.  Purely in-memory index data will be untouched.  Be aware: if
/// there are changes on disk, unwritten in-memory changes are discarded.
/// 
/// @param index an existing index object
/// @param force if true, always reload, vs. only read if file has changed
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_index> , ffi.Int )>()
external int git_index_read(ffi.Pointer<git_index> index,
int force,
);

/// Write an existing index object from memory back to disk
/// using an atomic file lock.
/// 
/// @param index an existing index object
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_index> )>()
external int git_index_write(ffi.Pointer<git_index> index,
);

/// Get the full path to the index file on disk.
/// 
/// @param index an existing index object
/// @return path to index file or NULL for in-memory index
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_index> )>()
external ffi.Pointer<ffi.Char> git_index_path(ffi.Pointer<git_index> index,
);

/// Get the checksum of the index
/// 
/// This checksum is the SHA-1 hash over the index file (except the
/// last 20 bytes which are the checksum itself). In cases where the
/// index does not exist on-disk, it will be zeroed out.
/// 
/// @deprecated this function is deprecated with no replacement
/// @param index an existing index object
/// @return a pointer to the checksum of the index
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_index> )>()
external ffi.Pointer<git_oid> git_index_checksum(ffi.Pointer<git_index> index,
);

/// Read a tree into the index file with stats
/// 
/// The current index contents will be replaced by the specified tree.
/// 
/// @param index an existing index object
/// @param tree tree to read
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_index> , ffi.Pointer<git_tree> )>()
external int git_index_read_tree(ffi.Pointer<git_index> index,
ffi.Pointer<git_tree> tree,
);

/// Write the index as a tree
/// 
/// This method will scan the index and write a representation
/// of its current state back to disk; it recursively creates
/// tree objects for each of the subtrees stored in the index,
/// but only returns the OID of the root tree. This is the OID
/// that can be used e.g. to create a commit.
/// 
/// The index instance cannot be bare, and needs to be associated
/// to an existing repository.
/// 
/// The index must not contain any file in conflict.
/// 
/// @param out Pointer where to store the OID of the written tree
/// @param index Index to write
/// @return 0 on success, GIT_EUNMERGED when the index is not clean
/// or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_index> )>()
external int git_index_write_tree(ffi.Pointer<git_oid> out,
ffi.Pointer<git_index> index,
);

/// Write the index as a tree to the given repository
/// 
/// This method will do the same as `git_index_write_tree`, but
/// letting the user choose the repository where the tree will
/// be written.
/// 
/// The index must not contain any file in conflict.
/// 
/// @param out Pointer where to store OID of the written tree
/// @param index Index to write
/// @param repo Repository where to write the tree
/// @return 0 on success, GIT_EUNMERGED when the index is not clean
/// or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_index> , ffi.Pointer<git_repository> )>()
external int git_index_write_tree_to(ffi.Pointer<git_oid> out,
ffi.Pointer<git_index> index,
ffi.Pointer<git_repository> repo,
);

/// Get the count of entries currently in the index
/// 
/// @param index an existing index object
/// @return integer of count of current entries
@ffi.Native<ffi.Size Function(ffi.Pointer<git_index> )>()
external int git_index_entrycount(ffi.Pointer<git_index> index,
);

/// Clear the contents (all the entries) of an index object.
/// 
/// This clears the index object in memory; changes must be explicitly
/// written to disk for them to take effect persistently.
/// 
/// @param index an existing index object
/// @return 0 on success, error code < 0 on failure
@ffi.Native<ffi.Int Function(ffi.Pointer<git_index> )>()
external int git_index_clear(ffi.Pointer<git_index> index,
);

/// Get a pointer to one of the entries in the index
/// 
/// The entry is not modifiable and should not be freed.  Because the
/// `git_index_entry` struct is a publicly defined struct, you should
/// be able to make your own permanent copy of the data if necessary.
/// 
/// @param index an existing index object
/// @param n the position of the entry
/// @return a pointer to the entry; NULL if out of bounds
@ffi.Native<ffi.Pointer<git_index_entry> Function(ffi.Pointer<git_index> , ffi.Size )>()
external ffi.Pointer<git_index_entry> git_index_get_byindex(ffi.Pointer<git_index> index,
int n,
);

/// Get a pointer to one of the entries in the index
/// 
/// The entry is not modifiable and should not be freed.  Because the
/// `git_index_entry` struct is a publicly defined struct, you should
/// be able to make your own permanent copy of the data if necessary.
/// 
/// @param index an existing index object
/// @param path path to search
/// @param stage stage to search
/// @return a pointer to the entry; NULL if it was not found
@ffi.Native<ffi.Pointer<git_index_entry> Function(ffi.Pointer<git_index> , ffi.Pointer<ffi.Char> , ffi.Int )>()
external ffi.Pointer<git_index_entry> git_index_get_bypath(ffi.Pointer<git_index> index,
ffi.Pointer<ffi.Char> path,
int stage,
);

/// Remove an entry from the index
/// 
/// @param index an existing index object
/// @param path path to search
/// @param stage stage to search
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_index> , ffi.Pointer<ffi.Char> , ffi.Int )>()
external int git_index_remove(ffi.Pointer<git_index> index,
ffi.Pointer<ffi.Char> path,
int stage,
);

/// Remove all entries from the index under a given directory
/// 
/// @param index an existing index object
/// @param dir container directory path
/// @param stage stage to search
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_index> , ffi.Pointer<ffi.Char> , ffi.Int )>()
external int git_index_remove_directory(ffi.Pointer<git_index> index,
ffi.Pointer<ffi.Char> dir,
int stage,
);

/// Add or update an index entry from an in-memory struct
/// 
/// If a previous index entry exists that has the same path and stage
/// as the given 'source_entry', it will be replaced.  Otherwise, the
/// 'source_entry' will be added.
/// 
/// A full copy (including the 'path' string) of the given
/// 'source_entry' will be inserted on the index.
/// 
/// @param index an existing index object
/// @param source_entry new entry object
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_index> , ffi.Pointer<git_index_entry> )>()
external int git_index_add(ffi.Pointer<git_index> index,
ffi.Pointer<git_index_entry> source_entry,
);

/// Return the stage number from a git index entry
/// 
/// This entry is calculated from the entry's flag attribute like this:
/// 
/// (entry->flags & GIT_INDEX_ENTRY_STAGEMASK) >> GIT_INDEX_ENTRY_STAGESHIFT
/// 
/// @param entry The entry
/// @return the stage number
@ffi.Native<ffi.Int Function(ffi.Pointer<git_index_entry> )>()
external int git_index_entry_stage(ffi.Pointer<git_index_entry> entry,
);

/// Return whether the given index entry is a conflict (has a high stage
/// entry).  This is simply shorthand for `git_index_entry_stage > 0`.
/// 
/// @param entry The entry
/// @return 1 if the entry is a conflict entry, 0 otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_index_entry> )>()
external int git_index_entry_is_conflict(ffi.Pointer<git_index_entry> entry,
);

/// Create an iterator that will return every entry contained in the
/// index at the time of creation.  Entries are returned in order,
/// sorted by path.  This iterator is backed by a snapshot that allows
/// callers to modify the index while iterating without affecting the
/// iterator.
/// 
/// @param iterator_out The newly created iterator
/// @param index The index to iterate
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index_iterator>> , ffi.Pointer<git_index> )>()
external int git_index_iterator_new(ffi.Pointer<ffi.Pointer<git_index_iterator>> iterator_out,
ffi.Pointer<git_index> index,
);

/// Return the next index entry in-order from the iterator.
/// 
/// @param out Pointer to store the index entry in
/// @param iterator The iterator
/// @return 0, GIT_ITEROVER on iteration completion or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index_entry>> , ffi.Pointer<git_index_iterator> )>()
external int git_index_iterator_next(ffi.Pointer<ffi.Pointer<git_index_entry>> out,
ffi.Pointer<git_index_iterator> iterator,
);

/// Free the index iterator
/// 
/// @param iterator The iterator to free
@ffi.Native<ffi.Void Function(ffi.Pointer<git_index_iterator> )>()
external void git_index_iterator_free(ffi.Pointer<git_index_iterator> iterator,
);

/// Add or update an index entry from a file on disk
/// 
/// The file `path` must be relative to the repository's
/// working folder and must be readable.
/// 
/// This method will fail in bare index instances.
/// 
/// This forces the file to be added to the index, not looking
/// at gitignore rules.  Those rules can be evaluated through
/// the git_status APIs (in status.h) before calling this.
/// 
/// If this file currently is the result of a merge conflict, this
/// file will no longer be marked as conflicting.  The data about
/// the conflict will be moved to the "resolve undo" (REUC) section.
/// 
/// @param index an existing index object
/// @param path filename to add
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_index> , ffi.Pointer<ffi.Char> )>()
external int git_index_add_bypath(ffi.Pointer<git_index> index,
ffi.Pointer<ffi.Char> path,
);

/// Add or update an index entry from a buffer in memory
/// 
/// This method will create a blob in the repository that owns the
/// index and then add the index entry to the index.  The `path` of the
/// entry represents the position of the blob relative to the
/// repository's root folder.
/// 
/// If a previous index entry exists that has the same path as the
/// given 'entry', it will be replaced.  Otherwise, the 'entry' will be
/// added.
/// 
/// This forces the file to be added to the index, not looking
/// at gitignore rules.  Those rules can be evaluated through
/// the git_status APIs (in status.h) before calling this.
/// 
/// If this file currently is the result of a merge conflict, this
/// file will no longer be marked as conflicting.  The data about
/// the conflict will be moved to the "resolve undo" (REUC) section.
/// 
/// @param index an existing index object
/// @param entry filename to add
/// @param buffer data to be written into the blob
/// @param len length of the data
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_index> , ffi.Pointer<git_index_entry> , ffi.Pointer<ffi.Void> , ffi.Size )>()
external int git_index_add_from_buffer(ffi.Pointer<git_index> index,
ffi.Pointer<git_index_entry> entry,
ffi.Pointer<ffi.Void> buffer,
int len,
);

/// Remove an index entry corresponding to a file on disk
/// 
/// The file `path` must be relative to the repository's
/// working folder.  It may exist.
/// 
/// If this file currently is the result of a merge conflict, this
/// file will no longer be marked as conflicting.  The data about
/// the conflict will be moved to the "resolve undo" (REUC) section.
/// 
/// @param index an existing index object
/// @param path filename to remove
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_index> , ffi.Pointer<ffi.Char> )>()
external int git_index_remove_bypath(ffi.Pointer<git_index> index,
ffi.Pointer<ffi.Char> path,
);

/// Add or update index entries matching files in the working directory.
/// 
/// This method will fail in bare index instances.
/// 
/// The `pathspec` is a list of file names or shell glob patterns that will
/// be matched against files in the repository's working directory.  Each
/// file that matches will be added to the index (either updating an
/// existing entry or adding a new entry).  You can disable glob expansion
/// and force exact matching with the `GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH`
/// flag.
/// 
/// Files that are ignored will be skipped (unlike `git_index_add_bypath`).
/// If a file is already tracked in the index, then it *will* be updated
/// even if it is ignored.  Pass the `GIT_INDEX_ADD_FORCE` flag to skip
/// the checking of ignore rules.
/// 
/// To emulate `git add -A` and generate an error if the pathspec contains
/// the exact path of an ignored file (when not using FORCE), add the
/// `GIT_INDEX_ADD_CHECK_PATHSPEC` flag.  This checks that each entry
/// in the `pathspec` that is an exact match to a filename on disk is
/// either not ignored or already in the index.  If this check fails, the
/// function will return GIT_EINVALIDSPEC.
/// 
/// To emulate `git add -A` with the "dry-run" option, just use a callback
/// function that always returns a positive value.  See below for details.
/// 
/// If any files are currently the result of a merge conflict, those files
/// will no longer be marked as conflicting.  The data about the conflicts
/// will be moved to the "resolve undo" (REUC) section.
/// 
/// If you provide a callback function, it will be invoked on each matching
/// item in the working directory immediately *before* it is added to /
/// updated in the index.  Returning zero will add the item to the index,
/// greater than zero will skip the item, and less than zero will abort the
/// scan and return that value to the caller.
/// 
/// @param index an existing index object
/// @param pathspec array of path patterns
/// @param flags combination of git_index_add_option_t flags
/// @param callback notification callback for each added/updated path (also
/// gets index of matching pathspec entry); can be NULL;
/// return 0 to add, >0 to skip, <0 to abort scan.
/// @param payload payload passed through to callback function
/// @return 0 on success, negative callback return value, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_index> , ffi.Pointer<git_strarray> , ffi.UnsignedInt , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> path, ffi.Pointer<ffi.Char> matched_pathspec, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_index_add_all(ffi.Pointer<git_index> index,
ffi.Pointer<git_strarray> pathspec,
int flags,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> path, ffi.Pointer<ffi.Char> matched_pathspec, ffi.Pointer<ffi.Void> payload)>> callback,
ffi.Pointer<ffi.Void> payload,
);

/// Remove all matching index entries.
/// 
/// If you provide a callback function, it will be invoked on each matching
/// item in the index immediately *before* it is removed.  Return 0 to
/// remove the item, > 0 to skip the item, and < 0 to abort the scan.
/// 
/// @param index An existing index object
/// @param pathspec array of path patterns
/// @param callback notification callback for each removed path (also
/// gets index of matching pathspec entry); can be NULL;
/// return 0 to add, >0 to skip, <0 to abort scan.
/// @param payload payload passed through to callback function
/// @return 0 on success, negative callback return value, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_index> , ffi.Pointer<git_strarray> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> path, ffi.Pointer<ffi.Char> matched_pathspec, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_index_remove_all(ffi.Pointer<git_index> index,
ffi.Pointer<git_strarray> pathspec,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> path, ffi.Pointer<ffi.Char> matched_pathspec, ffi.Pointer<ffi.Void> payload)>> callback,
ffi.Pointer<ffi.Void> payload,
);

/// Update all index entries to match the working directory
/// 
/// This method will fail in bare index instances.
/// 
/// This scans the existing index entries and synchronizes them with the
/// working directory, deleting them if the corresponding working directory
/// file no longer exists otherwise updating the information (including
/// adding the latest version of file to the ODB if needed).
/// 
/// If you provide a callback function, it will be invoked on each matching
/// item in the index immediately *before* it is updated (either refreshed
/// or removed depending on working directory state).  Return 0 to proceed
/// with updating the item, > 0 to skip the item, and < 0 to abort the scan.
/// 
/// @param index An existing index object
/// @param pathspec array of path patterns
/// @param callback notification callback for each updated path (also
/// gets index of matching pathspec entry); can be NULL;
/// return 0 to add, >0 to skip, <0 to abort scan.
/// @param payload payload passed through to callback function
/// @return 0 on success, negative callback return value, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_index> , ffi.Pointer<git_strarray> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> path, ffi.Pointer<ffi.Char> matched_pathspec, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_index_update_all(ffi.Pointer<git_index> index,
ffi.Pointer<git_strarray> pathspec,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> path, ffi.Pointer<ffi.Char> matched_pathspec, ffi.Pointer<ffi.Void> payload)>> callback,
ffi.Pointer<ffi.Void> payload,
);

/// Find the first position of any entries which point to given
/// path in the Git index.
/// 
/// @param at_pos the address to which the position of the index entry is written (optional)
/// @param index an existing index object
/// @param path path to search
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Size> , ffi.Pointer<git_index> , ffi.Pointer<ffi.Char> )>()
external int git_index_find(ffi.Pointer<ffi.Size> at_pos,
ffi.Pointer<git_index> index,
ffi.Pointer<ffi.Char> path,
);

/// Find the first position of any entries matching a prefix. To find the first position
/// of a path inside a given folder, suffix the prefix with a '/'.
/// 
/// @param at_pos the address to which the position of the index entry is written (optional)
/// @param index an existing index object
/// @param prefix the prefix to search for
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Size> , ffi.Pointer<git_index> , ffi.Pointer<ffi.Char> )>()
external int git_index_find_prefix(ffi.Pointer<ffi.Size> at_pos,
ffi.Pointer<git_index> index,
ffi.Pointer<ffi.Char> prefix,
);

/// Add or update index entries to represent a conflict.  Any staged
/// entries that exist at the given paths will be removed.
/// 
/// The entries are the entries from the tree included in the merge.  Any
/// entry may be null to indicate that that file was not present in the
/// trees during the merge.  For example, ancestor_entry may be NULL to
/// indicate that a file was added in both branches and must be resolved.
/// 
/// @param index an existing index object
/// @param ancestor_entry the entry data for the ancestor of the conflict
/// @param our_entry the entry data for our side of the merge conflict
/// @param their_entry the entry data for their side of the merge conflict
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_index> , ffi.Pointer<git_index_entry> , ffi.Pointer<git_index_entry> , ffi.Pointer<git_index_entry> )>()
external int git_index_conflict_add(ffi.Pointer<git_index> index,
ffi.Pointer<git_index_entry> ancestor_entry,
ffi.Pointer<git_index_entry> our_entry,
ffi.Pointer<git_index_entry> their_entry,
);

/// Get the index entries that represent a conflict of a single file.
/// 
/// The entries are not modifiable and should not be freed.  Because the
/// `git_index_entry` struct is a publicly defined struct, you should
/// be able to make your own permanent copy of the data if necessary.
/// 
/// @param ancestor_out Pointer to store the ancestor entry
/// @param our_out Pointer to store the our entry
/// @param their_out Pointer to store the their entry
/// @param index an existing index object
/// @param path path to search
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index_entry>> , ffi.Pointer<ffi.Pointer<git_index_entry>> , ffi.Pointer<ffi.Pointer<git_index_entry>> , ffi.Pointer<git_index> , ffi.Pointer<ffi.Char> )>()
external int git_index_conflict_get(ffi.Pointer<ffi.Pointer<git_index_entry>> ancestor_out,
ffi.Pointer<ffi.Pointer<git_index_entry>> our_out,
ffi.Pointer<ffi.Pointer<git_index_entry>> their_out,
ffi.Pointer<git_index> index,
ffi.Pointer<ffi.Char> path,
);

/// Removes the index entries that represent a conflict of a single file.
/// 
/// @param index an existing index object
/// @param path path to remove conflicts for
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_index> , ffi.Pointer<ffi.Char> )>()
external int git_index_conflict_remove(ffi.Pointer<git_index> index,
ffi.Pointer<ffi.Char> path,
);

/// Remove all conflicts in the index (entries with a stage greater than 0).
/// 
/// @param index an existing index object
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_index> )>()
external int git_index_conflict_cleanup(ffi.Pointer<git_index> index,
);

/// Determine if the index contains entries representing file conflicts.
/// 
/// @param index An existing index object.
/// @return 1 if at least one conflict is found, 0 otherwise.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_index> )>()
external int git_index_has_conflicts(ffi.Pointer<git_index> index,
);

/// Create an iterator for the conflicts in the index.
/// 
/// The index must not be modified while iterating; the results are undefined.
/// 
/// @param iterator_out The newly created conflict iterator
/// @param index The index to scan
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index_conflict_iterator>> , ffi.Pointer<git_index> )>()
external int git_index_conflict_iterator_new(ffi.Pointer<ffi.Pointer<git_index_conflict_iterator>> iterator_out,
ffi.Pointer<git_index> index,
);

/// Returns the current conflict (ancestor, ours and theirs entry) and
/// advance the iterator internally to the next value.
/// 
/// @param ancestor_out Pointer to store the ancestor side of the conflict
/// @param our_out Pointer to store our side of the conflict
/// @param their_out Pointer to store their side of the conflict
/// @param iterator The conflict iterator.
/// @return 0 (no error), GIT_ITEROVER (iteration is done) or an error code
/// (negative value)
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index_entry>> , ffi.Pointer<ffi.Pointer<git_index_entry>> , ffi.Pointer<ffi.Pointer<git_index_entry>> , ffi.Pointer<git_index_conflict_iterator> )>()
external int git_index_conflict_next(ffi.Pointer<ffi.Pointer<git_index_entry>> ancestor_out,
ffi.Pointer<ffi.Pointer<git_index_entry>> our_out,
ffi.Pointer<ffi.Pointer<git_index_entry>> their_out,
ffi.Pointer<git_index_conflict_iterator> iterator,
);

/// Frees a `git_index_conflict_iterator`.
/// 
/// @param iterator pointer to the iterator
@ffi.Native<ffi.Void Function(ffi.Pointer<git_index_conflict_iterator> )>()
external void git_index_conflict_iterator_free(ffi.Pointer<git_index_conflict_iterator> iterator,
);

/// Initializes a `git_merge_file_input` with default values. Equivalent to
/// creating an instance with GIT_MERGE_FILE_INPUT_INIT.
/// 
/// @param opts the `git_merge_file_input` instance to initialize.
/// @param version the version of the struct; you should pass
/// `GIT_MERGE_FILE_INPUT_VERSION` here.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_merge_file_input> , ffi.UnsignedInt )>()
external int git_merge_file_input_init(ffi.Pointer<git_merge_file_input> opts,
int version,
);

/// Initialize git_merge_file_options structure
/// 
/// Initializes a `git_merge_file_options` with default values. Equivalent to
/// creating an instance with `GIT_MERGE_FILE_OPTIONS_INIT`.
/// 
/// @param opts The `git_merge_file_options` struct to initialize.
/// @param version The struct version; pass `GIT_MERGE_FILE_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_merge_file_options> , ffi.UnsignedInt )>()
external int git_merge_file_options_init(ffi.Pointer<git_merge_file_options> opts,
int version,
);

/// Initialize git_merge_options structure
/// 
/// Initializes a `git_merge_options` with default values. Equivalent to
/// creating an instance with `GIT_MERGE_OPTIONS_INIT`.
/// 
/// @param opts The `git_merge_options` struct to initialize.
/// @param version The struct version; pass `GIT_MERGE_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_merge_options> , ffi.UnsignedInt )>()
external int git_merge_options_init(ffi.Pointer<git_merge_options> opts,
int version,
);

/// Analyzes the given branch(es) and determines the opportunities for
/// merging them into the HEAD of the repository.
/// 
/// @param analysis_out analysis enumeration that the result is written into
/// @param preference_out One of the `git_merge_preference_t` flag.
/// @param repo the repository to merge
/// @param their_heads the heads to merge into
/// @param their_heads_len the number of heads to merge
/// @return 0 on success or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.UnsignedInt> , ffi.Pointer<ffi.UnsignedInt> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Pointer<git_annotated_commit>> , ffi.Size )>()
external int git_merge_analysis(ffi.Pointer<ffi.UnsignedInt> analysis_out,
ffi.Pointer<ffi.UnsignedInt> preference_out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
int their_heads_len,
);

/// Analyzes the given branch(es) and determines the opportunities for
/// merging them into a reference.
/// 
/// @param analysis_out analysis enumeration that the result is written into
/// @param preference_out One of the `git_merge_preference_t` flag.
/// @param repo the repository to merge
/// @param our_ref the reference to perform the analysis from
/// @param their_heads the heads to merge into
/// @param their_heads_len the number of heads to merge
/// @return 0 on success or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.UnsignedInt> , ffi.Pointer<ffi.UnsignedInt> , ffi.Pointer<git_repository> , ffi.Pointer<git_reference> , ffi.Pointer<ffi.Pointer<git_annotated_commit>> , ffi.Size )>()
external int git_merge_analysis_for_ref(ffi.Pointer<ffi.UnsignedInt> analysis_out,
ffi.Pointer<ffi.UnsignedInt> preference_out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_reference> our_ref,
ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
int their_heads_len,
);

/// Find a merge base between two commits
/// 
/// @param out the OID of a merge base between 'one' and 'two'
/// @param repo the repository where the commits exist
/// @param one one of the commits
/// @param two the other commit
/// @return 0 on success, GIT_ENOTFOUND if not found or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<git_oid> , ffi.Pointer<git_oid> )>()
external int git_merge_base(ffi.Pointer<git_oid> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_oid> one,
ffi.Pointer<git_oid> two,
);

/// Find merge bases between two commits
/// 
/// @param out array in which to store the resulting ids
/// @param repo the repository where the commits exist
/// @param one one of the commits
/// @param two the other commit
/// @return 0 on success, GIT_ENOTFOUND if not found or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oidarray> , ffi.Pointer<git_repository> , ffi.Pointer<git_oid> , ffi.Pointer<git_oid> )>()
external int git_merge_bases(ffi.Pointer<git_oidarray> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_oid> one,
ffi.Pointer<git_oid> two,
);

/// Find a merge base given a list of commits
/// 
/// @param out the OID of a merge base considering all the commits
/// @param repo the repository where the commits exist
/// @param length The number of commits in the provided `input_array`
/// @param input_array oids of the commits
/// @return Zero on success; GIT_ENOTFOUND or -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Size , ffi.Pointer<git_oid> )>()
external int git_merge_base_many(ffi.Pointer<git_oid> out,
ffi.Pointer<git_repository> repo,
int length,
ffi.Pointer<git_oid> input_array,
);

/// Find all merge bases given a list of commits
/// 
/// This behaves similar to [`git merge-base`](https://git-scm.com/docs/git-merge-base#_discussion).
/// 
/// Given three commits `a`, `b`, and `c`, `merge_base_many`
/// will compute a hypothetical commit `m`, which is a merge between `b`
/// and `c`.
/// 
/// For example, with the following topology:
/// ```text
/// o---o---o---o---C
/// /
/// /   o---o---o---B
/// /   /
/// ---2---1---o---o---o---A
/// ```
/// 
/// the result of `merge_base_many` given `a`, `b`, and `c` is 1. This is
/// because the equivalent topology with the imaginary merge commit `m`
/// between `b` and `c` is:
/// ```text
/// o---o---o---o---o
/// /                 \
/// /   o---o---o---o---M
/// /   /
/// ---2---1---o---o---o---A
/// ```
/// 
/// and the result of `merge_base_many` given `a` and `m` is 1.
/// 
/// If you're looking to recieve the common ancestor between all the
/// given commits, use `merge_base_octopus`.
/// 
/// @param out array in which to store the resulting ids
/// @param repo the repository where the commits exist
/// @param length The number of commits in the provided `input_array`
/// @param input_array oids of the commits
/// @return Zero on success; GIT_ENOTFOUND or -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oidarray> , ffi.Pointer<git_repository> , ffi.Size , ffi.Pointer<git_oid> )>()
external int git_merge_bases_many(ffi.Pointer<git_oidarray> out,
ffi.Pointer<git_repository> repo,
int length,
ffi.Pointer<git_oid> input_array,
);

/// Find a merge base in preparation for an octopus merge
/// 
/// @param out the OID of a merge base considering all the commits
/// @param repo the repository where the commits exist
/// @param length The number of commits in the provided `input_array`
/// @param input_array oids of the commits
/// @return Zero on success; GIT_ENOTFOUND or -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Size , ffi.Pointer<git_oid> )>()
external int git_merge_base_octopus(ffi.Pointer<git_oid> out,
ffi.Pointer<git_repository> repo,
int length,
ffi.Pointer<git_oid> input_array,
);

/// Merge two files as they exist in the in-memory data structures, using
/// the given common ancestor as the baseline, producing a
/// `git_merge_file_result` that reflects the merge result.  The
/// `git_merge_file_result` must be freed with `git_merge_file_result_free`.
/// 
/// Note that this function does not reference a repository and any
/// configuration must be passed as `git_merge_file_options`.
/// 
/// @param out The git_merge_file_result to be filled in
/// @param ancestor The contents of the ancestor file
/// @param ours The contents of the file in "our" side
/// @param theirs The contents of the file in "their" side
/// @param opts The merge file options or `NULL` for defaults
/// @return 0 on success or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_merge_file_result> , ffi.Pointer<git_merge_file_input> , ffi.Pointer<git_merge_file_input> , ffi.Pointer<git_merge_file_input> , ffi.Pointer<git_merge_file_options> )>()
external int git_merge_file(ffi.Pointer<git_merge_file_result> out,
ffi.Pointer<git_merge_file_input> ancestor,
ffi.Pointer<git_merge_file_input> ours,
ffi.Pointer<git_merge_file_input> theirs,
ffi.Pointer<git_merge_file_options> opts,
);

/// Merge two files as they exist in the index, using the given common
/// ancestor as the baseline, producing a `git_merge_file_result` that
/// reflects the merge result.  The `git_merge_file_result` must be freed with
/// `git_merge_file_result_free`.
/// 
/// @param out The git_merge_file_result to be filled in
/// @param repo The repository
/// @param ancestor The index entry for the ancestor file (stage level 1)
/// @param ours The index entry for our file (stage level 2)
/// @param theirs The index entry for their file (stage level 3)
/// @param opts The merge file options or NULL
/// @return 0 on success or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_merge_file_result> , ffi.Pointer<git_repository> , ffi.Pointer<git_index_entry> , ffi.Pointer<git_index_entry> , ffi.Pointer<git_index_entry> , ffi.Pointer<git_merge_file_options> )>()
external int git_merge_file_from_index(ffi.Pointer<git_merge_file_result> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_index_entry> ancestor,
ffi.Pointer<git_index_entry> ours,
ffi.Pointer<git_index_entry> theirs,
ffi.Pointer<git_merge_file_options> opts,
);

/// Frees a `git_merge_file_result`.
/// 
/// @param result The result to free or `NULL`
@ffi.Native<ffi.Void Function(ffi.Pointer<git_merge_file_result> )>()
external void git_merge_file_result_free(ffi.Pointer<git_merge_file_result> result,
);

/// Merge two trees, producing a `git_index` that reflects the result of
/// the merge.  The index may be written as-is to the working directory
/// or checked out.  If the index is to be converted to a tree, the caller
/// should resolve any conflicts that arose as part of the merge.
/// 
/// The returned index must be freed explicitly with `git_index_free`.
/// 
/// @param out pointer to store the index result in
/// @param repo repository that contains the given trees
/// @param ancestor_tree the common ancestor between the trees (or null if none)
/// @param our_tree the tree that reflects the destination tree
/// @param their_tree the tree to merge in to `our_tree`
/// @param opts the merge tree options (or null for defaults)
/// @return 0 on success or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index>> , ffi.Pointer<git_repository> , ffi.Pointer<git_tree> , ffi.Pointer<git_tree> , ffi.Pointer<git_tree> , ffi.Pointer<git_merge_options> )>()
external int git_merge_trees(ffi.Pointer<ffi.Pointer<git_index>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_tree> ancestor_tree,
ffi.Pointer<git_tree> our_tree,
ffi.Pointer<git_tree> their_tree,
ffi.Pointer<git_merge_options> opts,
);

/// Merge two commits, producing a `git_index` that reflects the result of
/// the merge.  The index may be written as-is to the working directory
/// or checked out.  If the index is to be converted to a tree, the caller
/// should resolve any conflicts that arose as part of the merge.
/// 
/// The returned index must be freed explicitly with `git_index_free`.
/// 
/// @param out pointer to store the index result in
/// @param repo repository that contains the given trees
/// @param our_commit the commit that reflects the destination tree
/// @param their_commit the commit to merge in to `our_commit`
/// @param opts the merge tree options (or null for defaults)
/// @return 0 on success or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index>> , ffi.Pointer<git_repository> , ffi.Pointer<git_commit> , ffi.Pointer<git_commit> , ffi.Pointer<git_merge_options> )>()
external int git_merge_commits(ffi.Pointer<ffi.Pointer<git_index>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_commit> our_commit,
ffi.Pointer<git_commit> their_commit,
ffi.Pointer<git_merge_options> opts,
);

/// Merges the given commit(s) into HEAD, writing the results into the working
/// directory.  Any changes are staged for commit and any conflicts are written
/// to the index.  Callers should inspect the repository's index after this
/// completes, resolve any conflicts and prepare a commit.
/// 
/// For compatibility with git, the repository is put into a merging
/// state. Once the commit is done (or if the user wishes to abort),
/// you should clear this state by calling
/// `git_repository_state_cleanup()`.
/// 
/// @param repo the repository to merge
/// @param their_heads the heads to merge into
/// @param their_heads_len the number of heads to merge
/// @param merge_opts merge options
/// @param checkout_opts checkout options
/// @return 0 on success or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Pointer<git_annotated_commit>> , ffi.Size , ffi.Pointer<git_merge_options> , ffi.Pointer<git_checkout_options> )>()
external int git_merge(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
int their_heads_len,
ffi.Pointer<git_merge_options> merge_opts,
ffi.Pointer<git_checkout_options> checkout_opts,
);

/// Initialize git_cherrypick_options structure
/// 
/// Initializes a `git_cherrypick_options` with default values. Equivalent to creating
/// an instance with GIT_CHERRYPICK_OPTIONS_INIT.
/// 
/// @param opts The `git_cherrypick_options` struct to initialize.
/// @param version The struct version; pass `GIT_CHERRYPICK_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_cherrypick_options> , ffi.UnsignedInt )>()
external int git_cherrypick_options_init(ffi.Pointer<git_cherrypick_options> opts,
int version,
);

/// Cherry-picks the given commit against the given "our" commit, producing an
/// index that reflects the result of the cherry-pick.
/// 
/// The returned index must be freed explicitly with `git_index_free`.
/// 
/// @param out pointer to store the index result in
/// @param repo the repository that contains the given commits
/// @param cherrypick_commit the commit to cherry-pick
/// @param our_commit the commit to cherry-pick against (eg, HEAD)
/// @param mainline the parent of the `cherrypick_commit`, if it is a merge
/// @param merge_options the merge options (or null for defaults)
/// @return zero on success, -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index>> , ffi.Pointer<git_repository> , ffi.Pointer<git_commit> , ffi.Pointer<git_commit> , ffi.UnsignedInt , ffi.Pointer<git_merge_options> )>()
external int git_cherrypick_commit(ffi.Pointer<ffi.Pointer<git_index>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_commit> cherrypick_commit,
ffi.Pointer<git_commit> our_commit,
int mainline,
ffi.Pointer<git_merge_options> merge_options,
);

/// Cherry-pick the given commit, producing changes in the index and working directory.
/// 
/// @param repo the repository to cherry-pick
/// @param commit the commit to cherry-pick
/// @param cherrypick_options the cherry-pick options (or null for defaults)
/// @return zero on success, -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<git_commit> , ffi.Pointer<git_cherrypick_options> )>()
external int git_cherrypick(ffi.Pointer<git_repository> repo,
ffi.Pointer<git_commit> commit,
ffi.Pointer<git_cherrypick_options> cherrypick_options,
);

/// Parse a given refspec string
/// 
/// @param refspec a pointer to hold the refspec handle
/// @param input the refspec string
/// @param is_fetch is this a refspec for a fetch
/// @return 0 if the refspec string could be parsed, -1 otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_refspec>> , ffi.Pointer<ffi.Char> , ffi.Int )>()
external int git_refspec_parse(ffi.Pointer<ffi.Pointer<git_refspec>> refspec,
ffi.Pointer<ffi.Char> input,
int is_fetch,
);

/// Free a refspec object which has been created by git_refspec_parse
/// 
/// @param refspec the refspec object
@ffi.Native<ffi.Void Function(ffi.Pointer<git_refspec> )>()
external void git_refspec_free(ffi.Pointer<git_refspec> refspec,
);

/// Get the source specifier
/// 
/// @param refspec the refspec
/// @return the refspec's source specifier
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_refspec> )>()
external ffi.Pointer<ffi.Char> git_refspec_src(ffi.Pointer<git_refspec> refspec,
);

/// Get the destination specifier
/// 
/// @param refspec the refspec
/// @return the refspec's destination specifier
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_refspec> )>()
external ffi.Pointer<ffi.Char> git_refspec_dst(ffi.Pointer<git_refspec> refspec,
);

/// Get the refspec's string
/// 
/// @param refspec the refspec
/// @return the refspec's original string
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_refspec> )>()
external ffi.Pointer<ffi.Char> git_refspec_string(ffi.Pointer<git_refspec> refspec,
);

/// Get the force update setting
/// 
/// @param refspec the refspec
/// @return 1 if force update has been set, 0 otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_refspec> )>()
external int git_refspec_force(ffi.Pointer<git_refspec> refspec,
);

/// Get the refspec's direction.
/// 
/// @param spec refspec
/// @return GIT_DIRECTION_FETCH or GIT_DIRECTION_PUSH
@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<git_refspec> )>(symbol: 'git_refspec_direction')
external int _git_refspec_direction(ffi.Pointer<git_refspec> spec,
);

git_direction git_refspec_direction(ffi.Pointer<git_refspec> spec,
) => git_direction.fromValue(_git_refspec_direction(spec,
));

/// Check if a refspec's source descriptor matches a negative reference
/// 
/// @param refspec the refspec
/// @param refname the name of the reference to check
/// @return 1 if the refspec matches, 0 otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_refspec> , ffi.Pointer<ffi.Char> )>()
external int git_refspec_src_matches_negative(ffi.Pointer<git_refspec> refspec,
ffi.Pointer<ffi.Char> refname,
);

/// Check if a refspec's source descriptor matches a reference
/// 
/// @param refspec the refspec
/// @param refname the name of the reference to check
/// @return 1 if the refspec matches, 0 otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_refspec> , ffi.Pointer<ffi.Char> )>()
external int git_refspec_src_matches(ffi.Pointer<git_refspec> refspec,
ffi.Pointer<ffi.Char> refname,
);

/// Check if a refspec's destination descriptor matches a reference
/// 
/// @param refspec the refspec
/// @param refname the name of the reference to check
/// @return 1 if the refspec matches, 0 otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_refspec> , ffi.Pointer<ffi.Char> )>()
external int git_refspec_dst_matches(ffi.Pointer<git_refspec> refspec,
ffi.Pointer<ffi.Char> refname,
);

/// Transform a reference to its target following the refspec's rules
/// 
/// @param out where to store the target name
/// @param spec the refspec
/// @param name the name of the reference to transform
/// @return 0, GIT_EBUFS or another error
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_refspec> , ffi.Pointer<ffi.Char> )>()
external int git_refspec_transform(ffi.Pointer<git_buf> out,
ffi.Pointer<git_refspec> spec,
ffi.Pointer<ffi.Char> name,
);

/// Transform a target reference to its source reference following the refspec's rules
/// 
/// @param out where to store the source reference name
/// @param spec the refspec
/// @param name the name of the reference to transform
/// @return 0, GIT_EBUFS or another error
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_refspec> , ffi.Pointer<ffi.Char> )>()
external int git_refspec_rtransform(ffi.Pointer<git_buf> out,
ffi.Pointer<git_refspec> spec,
ffi.Pointer<ffi.Char> name,
);

/// Free a credential.
/// 
/// This is only necessary if you own the object; that is, if you are a
/// transport.
/// 
/// @param cred the object to free
@ffi.Native<ffi.Void Function(ffi.Pointer<git_credential> )>()
external void git_credential_free(ffi.Pointer<git_credential> cred,
);

/// Check whether a credential object contains username information.
/// 
/// @param cred object to check
/// @return 1 if the credential object has non-NULL username, 0 otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_credential> )>()
external int git_credential_has_username(ffi.Pointer<git_credential> cred,
);

/// Return the username associated with a credential object.
/// 
/// @param cred object to check
/// @return the credential username, or NULL if not applicable
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_credential> )>()
external ffi.Pointer<ffi.Char> git_credential_get_username(ffi.Pointer<git_credential> cred,
);

/// Create a new plain-text username and password credential object.
/// The supplied credential parameter will be internally duplicated.
/// 
/// @param out The newly created credential object.
/// @param username The username of the credential.
/// @param password The password of the credential.
/// @return 0 for success or an error code for failure
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_credential_userpass_plaintext_new(ffi.Pointer<ffi.Pointer<git_credential>> out,
ffi.Pointer<ffi.Char> username,
ffi.Pointer<ffi.Char> password,
);

/// Create a "default" credential usable for Negotiate mechanisms like NTLM
/// or Kerberos authentication.
/// 
/// @param out The newly created credential object.
/// @return 0 for success or an error code for failure
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>> )>()
external int git_credential_default_new(ffi.Pointer<ffi.Pointer<git_credential>> out,
);

/// Create a credential to specify a username.
/// 
/// This is used with ssh authentication to query for the username if
/// none is specified in the url.
/// 
/// @param out The newly created credential object.
/// @param username The username to authenticate with
/// @return 0 for success or an error code for failure
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>> , ffi.Pointer<ffi.Char> )>()
external int git_credential_username_new(ffi.Pointer<ffi.Pointer<git_credential>> out,
ffi.Pointer<ffi.Char> username,
);

/// Create a new passphrase-protected ssh key credential object.
/// The supplied credential parameter will be internally duplicated.
/// 
/// @param out The newly created credential object.
/// @param username username to use to authenticate
/// @param publickey The path to the public key of the credential.
/// @param privatekey The path to the private key of the credential.
/// @param passphrase The passphrase of the credential.
/// @return 0 for success or an error code for failure
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_credential_ssh_key_new(ffi.Pointer<ffi.Pointer<git_credential>> out,
ffi.Pointer<ffi.Char> username,
ffi.Pointer<ffi.Char> publickey,
ffi.Pointer<ffi.Char> privatekey,
ffi.Pointer<ffi.Char> passphrase,
);

/// Create a new ssh key credential object reading the keys from memory.
/// 
/// @param out The newly created credential object.
/// @param username username to use to authenticate.
/// @param publickey The public key of the credential.
/// @param privatekey The private key of the credential.
/// @param passphrase The passphrase of the credential.
/// @return 0 for success or an error code for failure
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_credential_ssh_key_memory_new(ffi.Pointer<ffi.Pointer<git_credential>> out,
ffi.Pointer<ffi.Char> username,
ffi.Pointer<ffi.Char> publickey,
ffi.Pointer<ffi.Char> privatekey,
ffi.Pointer<ffi.Char> passphrase,
);

/// Create a new ssh keyboard-interactive based credential object.
/// The supplied credential parameter will be internally duplicated.
/// 
/// @param out The newly created credential object.
/// @param username Username to use to authenticate.
/// @param prompt_callback The callback method used for prompts.
/// @param payload Additional data to pass to the callback.
/// @return 0 for success or an error code for failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char> name, ffi.Int name_len, ffi.Pointer<ffi.Char> instruction, ffi.Int instruction_len, ffi.Int num_prompts, ffi.Pointer<_LIBSSH2_USERAUTH_KBDINT_PROMPT> prompts, ffi.Pointer<_LIBSSH2_USERAUTH_KBDINT_RESPONSE> responses, ffi.Pointer<ffi.Pointer<ffi.Void>> abstract)>> , ffi.Pointer<ffi.Void> )>()
external int git_credential_ssh_interactive_new(ffi.Pointer<ffi.Pointer<git_credential>> out,
ffi.Pointer<ffi.Char> username,
ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char> name, ffi.Int name_len, ffi.Pointer<ffi.Char> instruction, ffi.Int instruction_len, ffi.Int num_prompts, ffi.Pointer<_LIBSSH2_USERAUTH_KBDINT_PROMPT> prompts, ffi.Pointer<_LIBSSH2_USERAUTH_KBDINT_RESPONSE> responses, ffi.Pointer<ffi.Pointer<ffi.Void>> abstract)>> prompt_callback,
ffi.Pointer<ffi.Void> payload,
);

/// Create a new ssh key credential object used for querying an ssh-agent.
/// The supplied credential parameter will be internally duplicated.
/// 
/// @param out The newly created credential object.
/// @param username username to use to authenticate
/// @return 0 for success or an error code for failure
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>> , ffi.Pointer<ffi.Char> )>()
external int git_credential_ssh_key_from_agent(ffi.Pointer<ffi.Pointer<git_credential>> out,
ffi.Pointer<ffi.Char> username,
);

/// Create an ssh key credential with a custom signing function.
/// 
/// This lets you use your own function to sign the challenge.
/// 
/// This function and its credential type is provided for completeness
/// and wraps `libssh2_userauth_publickey()`, which is undocumented.
/// 
/// The supplied credential parameter will be internally duplicated.
/// 
/// @param out The newly created credential object.
/// @param username username to use to authenticate
/// @param publickey The bytes of the public key.
/// @param publickey_len The length of the public key in bytes.
/// @param sign_callback The callback method to sign the data during the challenge.
/// @param payload Additional data to pass to the callback.
/// @return 0 for success or an error code for failure
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Size , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<_LIBSSH2_SESSION> session, ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> sig, ffi.Pointer<ffi.Size> sig_len, ffi.Pointer<ffi.UnsignedChar> data, ffi.Size data_len, ffi.Pointer<ffi.Pointer<ffi.Void>> abstract)>> , ffi.Pointer<ffi.Void> )>()
external int git_credential_ssh_custom_new(ffi.Pointer<ffi.Pointer<git_credential>> out,
ffi.Pointer<ffi.Char> username,
ffi.Pointer<ffi.Char> publickey,
int publickey_len,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<_LIBSSH2_SESSION> session, ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> sig, ffi.Pointer<ffi.Size> sig_len, ffi.Pointer<ffi.UnsignedChar> data, ffi.Size data_len, ffi.Pointer<ffi.Pointer<ffi.Void>> abstract)>> sign_callback,
ffi.Pointer<ffi.Void> payload,
);

/// Initialize a new packbuilder
/// 
/// @param out The new packbuilder object
/// @param repo The repository
/// 
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_packbuilder>> , ffi.Pointer<git_repository> )>()
external int git_packbuilder_new(ffi.Pointer<ffi.Pointer<git_packbuilder>> out,
ffi.Pointer<git_repository> repo,
);

/// Set number of threads to spawn
/// 
/// By default, libgit2 won't spawn any threads at all;
/// when set to 0, libgit2 will autodetect the number of
/// CPUs.
/// 
/// @param pb The packbuilder
/// @param n Number of threads to spawn
/// @return number of actual threads to be used
@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<git_packbuilder> , ffi.UnsignedInt )>()
external int git_packbuilder_set_threads(ffi.Pointer<git_packbuilder> pb,
int n,
);

/// Insert a single object
/// 
/// For an optimal pack it's mandatory to insert objects in recency order,
/// commits followed by trees and blobs.
/// 
/// @param pb The packbuilder
/// @param id The oid of the commit
/// @param name The name; might be NULL
/// 
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_packbuilder> , ffi.Pointer<git_oid> , ffi.Pointer<ffi.Char> )>()
external int git_packbuilder_insert(ffi.Pointer<git_packbuilder> pb,
ffi.Pointer<git_oid> id,
ffi.Pointer<ffi.Char> name,
);

/// Insert a root tree object
/// 
/// This will add the tree as well as all referenced trees and blobs.
/// 
/// @param pb The packbuilder
/// @param id The oid of the root tree
/// 
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_packbuilder> , ffi.Pointer<git_oid> )>()
external int git_packbuilder_insert_tree(ffi.Pointer<git_packbuilder> pb,
ffi.Pointer<git_oid> id,
);

/// Insert a commit object
/// 
/// This will add a commit as well as the completed referenced tree.
/// 
/// @param pb The packbuilder
/// @param id The oid of the commit
/// 
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_packbuilder> , ffi.Pointer<git_oid> )>()
external int git_packbuilder_insert_commit(ffi.Pointer<git_packbuilder> pb,
ffi.Pointer<git_oid> id,
);

/// Insert objects as given by the walk
/// 
/// Those commits and all objects they reference will be inserted into
/// the packbuilder.
/// 
/// @param pb the packbuilder
/// @param walk the revwalk to use to fill the packbuilder
/// 
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_packbuilder> , ffi.Pointer<git_revwalk> )>()
external int git_packbuilder_insert_walk(ffi.Pointer<git_packbuilder> pb,
ffi.Pointer<git_revwalk> walk,
);

/// Recursively insert an object and its referenced objects
/// 
/// Insert the object as well as any object it references.
/// 
/// @param pb the packbuilder
/// @param id the id of the root object to insert
/// @param name optional name for the object
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_packbuilder> , ffi.Pointer<git_oid> , ffi.Pointer<ffi.Char> )>()
external int git_packbuilder_insert_recur(ffi.Pointer<git_packbuilder> pb,
ffi.Pointer<git_oid> id,
ffi.Pointer<ffi.Char> name,
);

/// Write the contents of the packfile to an in-memory buffer
/// 
/// The contents of the buffer will become a valid packfile, even though there
/// will be no attached index
/// 
/// @param buf Buffer where to write the packfile
/// @param pb The packbuilder
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_packbuilder> )>()
external int git_packbuilder_write_buf(ffi.Pointer<git_buf> buf,
ffi.Pointer<git_packbuilder> pb,
);

/// Write the new pack and corresponding index file to path.
/// 
/// @param pb The packbuilder
/// @param path Path to the directory where the packfile and index should be stored, or NULL for default location
/// @param mode permissions to use creating a packfile or 0 for defaults
/// @param progress_cb function to call with progress information from the indexer (optional)
/// @param progress_cb_payload payload for the progress callback (optional)
/// 
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_packbuilder> , ffi.Pointer<ffi.Char> , ffi.UnsignedInt , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_indexer_progress> stats, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_packbuilder_write(ffi.Pointer<git_packbuilder> pb,
ffi.Pointer<ffi.Char> path,
int mode,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_indexer_progress> stats, ffi.Pointer<ffi.Void> payload)>> progress_cb,
ffi.Pointer<ffi.Void> progress_cb_payload,
);

/// Get the packfile's hash
/// 
/// A packfile's name is derived from the sorted hashing of all object
/// names. This is only correct after the packfile has been written.
/// 
/// @deprecated use git_packbuilder_name
/// @param pb The packbuilder object
/// @return 0 or an error code
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_packbuilder> )>()
external ffi.Pointer<git_oid> git_packbuilder_hash(ffi.Pointer<git_packbuilder> pb,
);

/// Get the unique name for the resulting packfile.
/// 
/// The packfile's name is derived from the packfile's content.
/// This is only correct after the packfile has been written.
/// 
/// @param pb the packbuilder instance
/// @return a NUL terminated string for the packfile name
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_packbuilder> )>()
external ffi.Pointer<ffi.Char> git_packbuilder_name(ffi.Pointer<git_packbuilder> pb,
);

/// Create the new pack and pass each object to the callback
/// 
/// @param pb the packbuilder
/// @param cb the callback to call with each packed object's buffer
/// @param payload the callback's data
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_packbuilder> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void> buf, ffi.Size size, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_packbuilder_foreach(ffi.Pointer<git_packbuilder> pb,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void> buf, ffi.Size size, ffi.Pointer<ffi.Void> payload)>> cb,
ffi.Pointer<ffi.Void> payload,
);

/// Get the total number of objects the packbuilder will write out
/// 
/// @param pb the packbuilder
/// @return the number of objects in the packfile
@ffi.Native<ffi.Size Function(ffi.Pointer<git_packbuilder> )>()
external int git_packbuilder_object_count(ffi.Pointer<git_packbuilder> pb,
);

/// Get the number of objects the packbuilder has already written out
/// 
/// @param pb the packbuilder
/// @return the number of objects which have already been written
@ffi.Native<ffi.Size Function(ffi.Pointer<git_packbuilder> )>()
external int git_packbuilder_written(ffi.Pointer<git_packbuilder> pb,
);

/// Set the callbacks for a packbuilder
/// 
/// @param pb The packbuilder object
/// @param progress_cb Function to call with progress information during
/// pack building. Be aware that this is called inline with pack building
/// operations, so performance may be affected.
/// When progress_cb returns an error, the pack building process will be
/// aborted and the error will be returned from the invoked function.
/// `pb` must then be freed.
/// @param progress_cb_payload Payload for progress callback.
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_packbuilder> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Int stage, ffi.Uint32 current, ffi.Uint32 total, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_packbuilder_set_callbacks(ffi.Pointer<git_packbuilder> pb,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Int stage, ffi.Uint32 current, ffi.Uint32 total, ffi.Pointer<ffi.Void> payload)>> progress_cb,
ffi.Pointer<ffi.Void> progress_cb_payload,
);

/// Free the packbuilder and all associated data
/// 
/// @param pb The packbuilder
@ffi.Native<ffi.Void Function(ffi.Pointer<git_packbuilder> )>()
external void git_packbuilder_free(ffi.Pointer<git_packbuilder> pb,
);

/// Initialize git_proxy_options structure
/// 
/// Initializes a `git_proxy_options` with default values. Equivalent to
/// creating an instance with `GIT_PROXY_OPTIONS_INIT`.
/// 
/// @param opts The `git_proxy_options` struct to initialize.
/// @param version The struct version; pass `GIT_PROXY_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_proxy_options> , ffi.UnsignedInt )>()
external int git_proxy_options_init(ffi.Pointer<git_proxy_options> opts,
int version,
);

/// Add a remote with the default fetch refspec to the repository's configuration.
/// 
/// @param out the resulting remote
/// @param repo the repository in which to create the remote
/// @param name the remote's name
/// @param url the remote's url
/// @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_remote>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_remote_create(ffi.Pointer<ffi.Pointer<git_remote>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
ffi.Pointer<ffi.Char> url,
);

/// Initialize git_remote_create_options structure
/// 
/// Initializes a `git_remote_create_options` with default values. Equivalent to
/// creating an instance with `GIT_REMOTE_CREATE_OPTIONS_INIT`.
/// 
/// @param opts The `git_remote_create_options` struct to initialize.
/// @param version The struct version; pass `GIT_REMOTE_CREATE_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_remote_create_options> , ffi.UnsignedInt )>()
external int git_remote_create_options_init(ffi.Pointer<git_remote_create_options> opts,
int version,
);

/// Create a remote, with options.
/// 
/// This function allows more fine-grained control over the remote creation.
/// 
/// Passing NULL as the opts argument will result in a detached remote.
/// 
/// @param out the resulting remote
/// @param url the remote's url
/// @param opts the remote creation options
/// @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_remote>> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_remote_create_options> )>()
external int git_remote_create_with_opts(ffi.Pointer<ffi.Pointer<git_remote>> out,
ffi.Pointer<ffi.Char> url,
ffi.Pointer<git_remote_create_options> opts,
);

/// Add a remote with the provided fetch refspec (or default if NULL) to the repository's
/// configuration.
/// 
/// @param out the resulting remote
/// @param repo the repository in which to create the remote
/// @param name the remote's name
/// @param url the remote's url
/// @param fetch the remote fetch value
/// @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_remote>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_remote_create_with_fetchspec(ffi.Pointer<ffi.Pointer<git_remote>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
ffi.Pointer<ffi.Char> url,
ffi.Pointer<ffi.Char> fetch,
);

/// Create an anonymous remote
/// 
/// Create a remote with the given url in-memory. You can use this when
/// you have a URL instead of a remote's name.
/// 
/// @param out pointer to the new remote objects
/// @param repo the associated repository
/// @param url the remote repository's URL
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_remote>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_remote_create_anonymous(ffi.Pointer<ffi.Pointer<git_remote>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> url,
);

/// Create a remote without a connected local repo
/// 
/// Create a remote with the given url in-memory. You can use this when
/// you have a URL instead of a remote's name.
/// 
/// Contrasted with git_remote_create_anonymous, a detached remote
/// will not consider any repo configuration values (such as insteadof url
/// substitutions).
/// 
/// @param out pointer to the new remote objects
/// @param url the remote repository's URL
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_remote>> , ffi.Pointer<ffi.Char> )>()
external int git_remote_create_detached(ffi.Pointer<ffi.Pointer<git_remote>> out,
ffi.Pointer<ffi.Char> url,
);

/// Get the information for a particular remote
/// 
/// The name will be checked for validity.
/// See `git_tag_create()` for rules about valid names.
/// 
/// @param out pointer to the new remote object
/// @param repo the associated repository
/// @param name the remote's name
/// @return 0, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_remote>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_remote_lookup(ffi.Pointer<ffi.Pointer<git_remote>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
);

/// Create a copy of an existing remote.  All internal strings are also
/// duplicated. Callbacks are not duplicated.
/// 
/// Call `git_remote_free` to free the data.
/// 
/// @param dest pointer where to store the copy
/// @param source object to copy
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_remote>> , ffi.Pointer<git_remote> )>()
external int git_remote_dup(ffi.Pointer<ffi.Pointer<git_remote>> dest,
ffi.Pointer<git_remote> source,
);

/// Get the remote's repository
/// 
/// @param remote the remote
/// @return a pointer to the repository
@ffi.Native<ffi.Pointer<git_repository> Function(ffi.Pointer<git_remote> )>()
external ffi.Pointer<git_repository> git_remote_owner(ffi.Pointer<git_remote> remote,
);

/// Get the remote's name
/// 
/// @param remote the remote
/// @return a pointer to the name or NULL for in-memory remotes
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_remote> )>()
external ffi.Pointer<ffi.Char> git_remote_name(ffi.Pointer<git_remote> remote,
);

/// Get the remote's url
/// 
/// If url.*.insteadOf has been configured for this URL, it will return
/// the modified URL. This function does not consider if a push url has
/// been configured for this remote (use `git_remote_pushurl` if needed).
/// 
/// @param remote the remote
/// @return a pointer to the url
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_remote> )>()
external ffi.Pointer<ffi.Char> git_remote_url(ffi.Pointer<git_remote> remote,
);

/// Get the remote's url for pushing.
/// 
/// If url.*.pushInsteadOf has been configured for this URL, it
/// will return the modified URL.  If `git_remote_set_instance_pushurl`
/// has been called for this remote, then that URL will be returned.
/// 
/// @param remote the remote
/// @return a pointer to the url or NULL if no special url for pushing is set
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_remote> )>()
external ffi.Pointer<ffi.Char> git_remote_pushurl(ffi.Pointer<git_remote> remote,
);

/// Set the remote's url in the configuration
/// 
/// Remote objects already in memory will not be affected. This assumes
/// the common case of a single-url remote and will otherwise return an error.
/// 
/// @param repo the repository in which to perform the change
/// @param remote the remote's name
/// @param url the url to set
/// @return 0 or an error value
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_remote_set_url(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> remote,
ffi.Pointer<ffi.Char> url,
);

/// Set the remote's url for pushing in the configuration.
/// 
/// Remote objects already in memory will not be affected. This assumes
/// the common case of a single-url remote and will otherwise return an error.
/// 
/// 
/// @param repo the repository in which to perform the change
/// @param remote the remote's name
/// @param url the url to set
/// @return 0, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_remote_set_pushurl(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> remote,
ffi.Pointer<ffi.Char> url,
);

/// Set the url for this particular url instance.  The URL in the
/// configuration will be ignored, and will not be changed.
/// 
/// @param remote the remote's name
/// @param url the url to set
/// @return 0 or an error value
@ffi.Native<ffi.Int Function(ffi.Pointer<git_remote> , ffi.Pointer<ffi.Char> )>()
external int git_remote_set_instance_url(ffi.Pointer<git_remote> remote,
ffi.Pointer<ffi.Char> url,
);

/// Set the push url for this particular url instance.  The URL in the
/// configuration will be ignored, and will not be changed.
/// 
/// @param remote the remote's name
/// @param url the url to set
/// @return 0 or an error value
@ffi.Native<ffi.Int Function(ffi.Pointer<git_remote> , ffi.Pointer<ffi.Char> )>()
external int git_remote_set_instance_pushurl(ffi.Pointer<git_remote> remote,
ffi.Pointer<ffi.Char> url,
);

/// Add a fetch refspec to the remote's configuration
/// 
/// Add the given refspec to the fetch list in the configuration. No
/// loaded remote instances will be affected.
/// 
/// @param repo the repository in which to change the configuration
/// @param remote the name of the remote to change
/// @param refspec the new fetch refspec
/// @return 0, GIT_EINVALIDSPEC if refspec is invalid or an error value
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_remote_add_fetch(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> remote,
ffi.Pointer<ffi.Char> refspec,
);

/// Get the remote's list of fetch refspecs
/// 
/// The memory is owned by the user and should be freed with
/// `git_strarray_free`.
/// 
/// @param array pointer to the array in which to store the strings
/// @param remote the remote to query
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_strarray> , ffi.Pointer<git_remote> )>()
external int git_remote_get_fetch_refspecs(ffi.Pointer<git_strarray> array,
ffi.Pointer<git_remote> remote,
);

/// Add a push refspec to the remote's configuration
/// 
/// Add the given refspec to the push list in the configuration. No
/// loaded remote instances will be affected.
/// 
/// @param repo the repository in which to change the configuration
/// @param remote the name of the remote to change
/// @param refspec the new push refspec
/// @return 0, GIT_EINVALIDSPEC if refspec is invalid or an error value
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_remote_add_push(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> remote,
ffi.Pointer<ffi.Char> refspec,
);

/// Get the remote's list of push refspecs
/// 
/// The memory is owned by the user and should be freed with
/// `git_strarray_free`.
/// 
/// @param array pointer to the array in which to store the strings
/// @param remote the remote to query
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_strarray> , ffi.Pointer<git_remote> )>()
external int git_remote_get_push_refspecs(ffi.Pointer<git_strarray> array,
ffi.Pointer<git_remote> remote,
);

/// Get the number of refspecs for a remote
/// 
/// @param remote the remote
/// @return the amount of refspecs configured in this remote
@ffi.Native<ffi.Size Function(ffi.Pointer<git_remote> )>()
external int git_remote_refspec_count(ffi.Pointer<git_remote> remote,
);

/// Get a refspec from the remote
/// 
/// @param remote the remote to query
/// @param n the refspec to get
/// @return the nth refspec
@ffi.Native<ffi.Pointer<git_refspec> Function(ffi.Pointer<git_remote> , ffi.Size )>()
external ffi.Pointer<git_refspec> git_remote_get_refspec(ffi.Pointer<git_remote> remote,
int n,
);

/// Get the remote repository's reference advertisement list
/// 
/// Get the list of references with which the server responds to a new
/// connection.
/// 
/// The remote (or more exactly its transport) must have connected to
/// the remote repository. This list is available as soon as the
/// connection to the remote is initiated and it remains available
/// after disconnecting.
/// 
/// The memory belongs to the remote. The pointer will be valid as long
/// as a new connection is not initiated, but it is recommended that
/// you make a copy in order to make use of the data.
/// 
/// @param out pointer to the array
/// @param size the number of remote heads
/// @param remote the remote
/// @return 0 on success, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Pointer<git_remote_head>>> , ffi.Pointer<ffi.Size> , ffi.Pointer<git_remote> )>()
external int git_remote_ls(ffi.Pointer<ffi.Pointer<ffi.Pointer<git_remote_head>>> out,
ffi.Pointer<ffi.Size> size,
ffi.Pointer<git_remote> remote,
);

/// Check whether the remote is connected
/// 
/// Check whether the remote's underlying transport is connected to the
/// remote host.
/// 
/// @param remote the remote
/// @return 1 if it's connected, 0 otherwise.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_remote> )>()
external int git_remote_connected(ffi.Pointer<git_remote> remote,
);

/// Cancel the operation
/// 
/// At certain points in its operation, the network code checks whether
/// the operation has been cancelled and if so stops the operation.
/// 
/// @param remote the remote
/// @return 0 on success, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_remote> )>()
external int git_remote_stop(ffi.Pointer<git_remote> remote,
);

/// Disconnect from the remote
/// 
/// Close the connection to the remote.
/// 
/// @param remote the remote to disconnect from
/// @return 0 on success, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_remote> )>()
external int git_remote_disconnect(ffi.Pointer<git_remote> remote,
);

/// Free the memory associated with a remote
/// 
/// This also disconnects from the remote, if the connection
/// has not been closed yet (using git_remote_disconnect).
/// 
/// @param remote the remote to free
@ffi.Native<ffi.Void Function(ffi.Pointer<git_remote> )>()
external void git_remote_free(ffi.Pointer<git_remote> remote,
);

/// Get a list of the configured remotes for a repo
/// 
/// The string array must be freed by the user.
/// 
/// @param out a string array which receives the names of the remotes
/// @param repo the repository to query
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_strarray> , ffi.Pointer<git_repository> )>()
external int git_remote_list(ffi.Pointer<git_strarray> out,
ffi.Pointer<git_repository> repo,
);

/// Initializes a `git_remote_callbacks` with default values. Equivalent to
/// creating an instance with GIT_REMOTE_CALLBACKS_INIT.
/// 
/// @param opts the `git_remote_callbacks` struct to initialize
/// @param version Version of struct; pass `GIT_REMOTE_CALLBACKS_VERSION`
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_remote_callbacks> , ffi.UnsignedInt )>()
external int git_remote_init_callbacks(ffi.Pointer<git_remote_callbacks> opts,
int version,
);

/// Initialize git_fetch_options structure
/// 
/// Initializes a `git_fetch_options` with default values. Equivalent to
/// creating an instance with `GIT_FETCH_OPTIONS_INIT`.
/// 
/// @param opts The `git_fetch_options` struct to initialize.
/// @param version The struct version; pass `GIT_FETCH_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_fetch_options> , ffi.UnsignedInt )>()
external int git_fetch_options_init(ffi.Pointer<git_fetch_options> opts,
int version,
);

/// Initialize git_push_options structure
/// 
/// Initializes a `git_push_options` with default values. Equivalent to
/// creating an instance with `GIT_PUSH_OPTIONS_INIT`.
/// 
/// @param opts The `git_push_options` struct to initialize.
/// @param version The struct version; pass `GIT_PUSH_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_push_options> , ffi.UnsignedInt )>()
external int git_push_options_init(ffi.Pointer<git_push_options> opts,
int version,
);

/// Initialize git_remote_connect_options structure.
/// 
/// Initializes a `git_remote_connect_options` with default values.
/// Equivalent to creating an instance with
/// `GIT_REMOTE_CONNECT_OPTIONS_INIT`.
/// 
/// @param opts The `git_remote_connect_options` struct to initialize.
/// @param version The struct version; pass `GIT_REMOTE_CONNECT_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_remote_connect_options> , ffi.UnsignedInt )>()
external int git_remote_connect_options_init(ffi.Pointer<git_remote_connect_options> opts,
int version,
);

/// Open a connection to a remote.
/// 
/// The transport is selected based on the URL; the direction argument
/// is due to a limitation of the git protocol which starts up a
/// specific binary which can only do the one or the other.
/// 
/// @param remote the remote to connect to
/// @param direction GIT_DIRECTION_FETCH if you want to fetch or
/// GIT_DIRECTION_PUSH if you want to push
/// @param callbacks the callbacks to use for this connection
/// @param proxy_opts proxy settings
/// @param custom_headers extra HTTP headers to use in this connection
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_remote> , ffi.UnsignedInt , ffi.Pointer<git_remote_callbacks> , ffi.Pointer<git_proxy_options> , ffi.Pointer<git_strarray> )>(symbol: 'git_remote_connect')
external int _git_remote_connect(ffi.Pointer<git_remote> remote,
int direction,
ffi.Pointer<git_remote_callbacks> callbacks,
ffi.Pointer<git_proxy_options> proxy_opts,
ffi.Pointer<git_strarray> custom_headers,
);

int git_remote_connect(ffi.Pointer<git_remote> remote,
git_direction direction,
ffi.Pointer<git_remote_callbacks> callbacks,
ffi.Pointer<git_proxy_options> proxy_opts,
ffi.Pointer<git_strarray> custom_headers,
) => _git_remote_connect(remote,
direction.value,
callbacks,
proxy_opts,
custom_headers,
);

/// Open a connection to a remote with extended options.
/// 
/// The transport is selected based on the URL; the direction argument
/// is due to a limitation of the git protocol which starts up a
/// specific binary which can only do the one or the other.
/// 
/// The given options structure will form the defaults for connection
/// options and callback setup.  Callers may override these defaults
/// by specifying `git_fetch_options` or `git_push_options` in
/// subsequent calls.
/// 
/// @param remote the remote to connect to
/// @param direction GIT_DIRECTION_FETCH if you want to fetch or
/// GIT_DIRECTION_PUSH if you want to push
/// @param opts the remote connection options
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_remote> , ffi.UnsignedInt , ffi.Pointer<git_remote_connect_options> )>(symbol: 'git_remote_connect_ext')
external int _git_remote_connect_ext(ffi.Pointer<git_remote> remote,
int direction,
ffi.Pointer<git_remote_connect_options> opts,
);

int git_remote_connect_ext(ffi.Pointer<git_remote> remote,
git_direction direction,
ffi.Pointer<git_remote_connect_options> opts,
) => _git_remote_connect_ext(remote,
direction.value,
opts,
);

/// Download and index the packfile.
/// 
/// Connect to the remote if it hasn't been done yet, negotiate with
/// the remote git which objects are missing, download and index the
/// packfile.
/// 
/// The .idx file will be created and both it and the packfile with be
/// renamed to their final name.
/// 
/// If options are specified and this remote is already connected then
/// the existing remote connection options will be discarded and the
/// remote will now use the new options.
/// 
/// @param remote the remote
/// @param refspecs the refspecs to use for this negotiation and
/// download. Use NULL or an empty array to use the base refspecs
/// @param opts the options to use for this fetch or NULL
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_remote> , ffi.Pointer<git_strarray> , ffi.Pointer<git_fetch_options> )>()
external int git_remote_download(ffi.Pointer<git_remote> remote,
ffi.Pointer<git_strarray> refspecs,
ffi.Pointer<git_fetch_options> opts,
);

/// Create a packfile and send it to the server
/// 
/// Connect to the remote if it hasn't been done yet, negotiate with
/// the remote git which objects are missing, create a packfile with
/// the missing objects and send it.
/// 
/// If options are specified and this remote is already connected then
/// the existing remote connection options will be discarded and the
/// remote will now use the new options.
/// 
/// @param remote the remote
/// @param refspecs the refspecs to use for this negotiation and
/// upload. Use NULL or an empty array to use the base refspecs
/// @param opts the options to use for this push
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_remote> , ffi.Pointer<git_strarray> , ffi.Pointer<git_push_options> )>()
external int git_remote_upload(ffi.Pointer<git_remote> remote,
ffi.Pointer<git_strarray> refspecs,
ffi.Pointer<git_push_options> opts,
);

/// Update the tips to the new state.
/// 
/// If callbacks are not specified then the callbacks specified to
/// `git_remote_connect` will be used (if it was called).
/// 
/// @param remote the remote to update
/// @param callbacks  pointer to the callback structure to use or NULL
/// @param update_flags the git_remote_update_flags for these tips.
/// @param download_tags what the behaviour for downloading tags is for this fetch. This is
/// ignored for push. This must be the same value passed to `git_remote_download()`.
/// @param reflog_message The message to insert into the reflogs. If
/// NULL and fetching, the default is "fetch <name>", where <name> is
/// the name of the remote (or its url, for in-memory remotes). This
/// parameter is ignored when pushing.
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_remote> , ffi.Pointer<git_remote_callbacks> , ffi.UnsignedInt , ffi.UnsignedInt , ffi.Pointer<ffi.Char> )>(symbol: 'git_remote_update_tips')
external int _git_remote_update_tips(ffi.Pointer<git_remote> remote,
ffi.Pointer<git_remote_callbacks> callbacks,
int update_flags,
int download_tags,
ffi.Pointer<ffi.Char> reflog_message,
);

int git_remote_update_tips(ffi.Pointer<git_remote> remote,
ffi.Pointer<git_remote_callbacks> callbacks,
int update_flags,
git_remote_autotag_option_t download_tags,
ffi.Pointer<ffi.Char> reflog_message,
) => _git_remote_update_tips(remote,
callbacks,
update_flags,
download_tags.value,
reflog_message,
);

/// Download new data and update tips.
/// 
/// Convenience function to connect to a remote, download the data,
/// disconnect and update the remote-tracking branches.
/// 
/// If options are specified and this remote is already connected then
/// the existing remote connection options will be discarded and the
/// remote will now use the new options.
/// 
/// @param remote the remote to fetch from
/// @param refspecs the refspecs to use for this fetch. Pass NULL or an
/// empty array to use the base refspecs.
/// @param opts options to use for this fetch or NULL
/// @param reflog_message The message to insert into the reflogs. If NULL, the
/// default is "fetch"
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_remote> , ffi.Pointer<git_strarray> , ffi.Pointer<git_fetch_options> , ffi.Pointer<ffi.Char> )>()
external int git_remote_fetch(ffi.Pointer<git_remote> remote,
ffi.Pointer<git_strarray> refspecs,
ffi.Pointer<git_fetch_options> opts,
ffi.Pointer<ffi.Char> reflog_message,
);

/// Prune tracking refs that are no longer present on remote.
/// 
/// If callbacks are not specified then the callbacks specified to
/// `git_remote_connect` will be used (if it was called).
/// 
/// @param remote the remote to prune
/// @param callbacks callbacks to use for this prune
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_remote> , ffi.Pointer<git_remote_callbacks> )>()
external int git_remote_prune(ffi.Pointer<git_remote> remote,
ffi.Pointer<git_remote_callbacks> callbacks,
);

/// Perform a push.
/// 
/// If options are specified and this remote is already connected then
/// the existing remote connection options will be discarded and the
/// remote will now use the new options.
/// 
/// @param remote the remote to push to
/// @param refspecs the refspecs to use for pushing. If NULL or an empty
/// array, the configured refspecs will be used
/// @param opts options to use for this push
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_remote> , ffi.Pointer<git_strarray> , ffi.Pointer<git_push_options> )>()
external int git_remote_push(ffi.Pointer<git_remote> remote,
ffi.Pointer<git_strarray> refspecs,
ffi.Pointer<git_push_options> opts,
);

/// Get the statistics structure that is filled in by the fetch operation.
/// 
/// @param remote the remote to get statistics for
/// @return the git_indexer_progress for the remote
@ffi.Native<ffi.Pointer<git_indexer_progress> Function(ffi.Pointer<git_remote> )>()
external ffi.Pointer<git_indexer_progress> git_remote_stats(ffi.Pointer<git_remote> remote,
);

/// Retrieve the tag auto-follow setting
/// 
/// @param remote the remote to query
/// @return the auto-follow setting
@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<git_remote> )>(symbol: 'git_remote_autotag')
external int _git_remote_autotag(ffi.Pointer<git_remote> remote,
);

git_remote_autotag_option_t git_remote_autotag(ffi.Pointer<git_remote> remote,
) => git_remote_autotag_option_t.fromValue(_git_remote_autotag(remote,
));

/// Set the remote's tag following setting.
/// 
/// The change will be made in the configuration. No loaded remotes
/// will be affected.
/// 
/// @param repo the repository in which to make the change
/// @param remote the name of the remote
/// @param value the new value to take.
/// @return 0, or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.UnsignedInt )>(symbol: 'git_remote_set_autotag')
external int _git_remote_set_autotag(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> remote,
int value,
);

int git_remote_set_autotag(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> remote,
git_remote_autotag_option_t value,
) => _git_remote_set_autotag(repo,
remote,
value.value,
);

/// Retrieve the ref-prune setting
/// 
/// @param remote the remote to query
/// @return the ref-prune setting
@ffi.Native<ffi.Int Function(ffi.Pointer<git_remote> )>()
external int git_remote_prune_refs(ffi.Pointer<git_remote> remote,
);

/// Give the remote a new name
/// 
/// All remote-tracking branches and configuration settings
/// for the remote are updated.
/// 
/// The new name will be checked for validity.
/// See `git_tag_create()` for rules about valid names.
/// 
/// No loaded instances of a the remote with the old name will change
/// their name or their list of refspecs.
/// 
/// @param problems non-default refspecs cannot be renamed and will be
/// stored here for further processing by the caller. Always free this
/// strarray on successful return.
/// @param repo the repository in which to rename
/// @param name the current name of the remote
/// @param new_name the new name the remote should bear
/// @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_strarray> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_remote_rename(ffi.Pointer<git_strarray> problems,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
ffi.Pointer<ffi.Char> new_name,
);

/// Ensure the remote name is well-formed.
/// 
/// @param valid output pointer to set with validity of given remote name
/// @param remote_name name to be checked.
/// @return 0 on success or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Int> , ffi.Pointer<ffi.Char> )>()
external int git_remote_name_is_valid(ffi.Pointer<ffi.Int> valid,
ffi.Pointer<ffi.Char> remote_name,
);

/// Delete an existing persisted remote.
/// 
/// All remote-tracking branches and configuration settings
/// for the remote will be removed.
/// 
/// @param repo the repository in which to act
/// @param name the name of the remote to delete
/// @return 0 on success, or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_remote_delete(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
);

/// Retrieve the name of the remote's default branch
/// 
/// The default branch of a repository is the branch which HEAD points
/// to. If the remote does not support reporting this information
/// directly, it performs the guess as git does; that is, if there are
/// multiple branches which point to the same commit, the first one is
/// chosen. If the master branch is a candidate, it wins.
/// 
/// This function must only be called after connecting.
/// 
/// @param out the buffer in which to store the reference name
/// @param remote the remote
/// @return 0, GIT_ENOTFOUND if the remote does not have any references
/// or none of them point to HEAD's commit, or an error message.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_remote> )>()
external int git_remote_default_branch(ffi.Pointer<git_buf> out,
ffi.Pointer<git_remote> remote,
);

/// Initialize git_clone_options structure
/// 
/// Initializes a `git_clone_options` with default values. Equivalent to creating
/// an instance with GIT_CLONE_OPTIONS_INIT.
/// 
/// @param opts The `git_clone_options` struct to initialize.
/// @param version The struct version; pass `GIT_CLONE_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_clone_options> , ffi.UnsignedInt )>()
external int git_clone_options_init(ffi.Pointer<git_clone_options> opts,
int version,
);

/// Clone a remote repository.
/// 
/// By default this creates its repository and initial remote to match
/// git's defaults. You can use the options in the callback to
/// customize how these are created.
/// 
/// Note that the libgit2 library _must_ be initialized using
/// `git_libgit2_init` before any APIs can be called, including
/// this one.
/// 
/// @param[out] out pointer that will receive the resulting repository object
/// @param url the remote repository to clone
/// @param local_path local directory to clone to
/// @param options configuration options for the clone.  If NULL, the
/// function works as though GIT_OPTIONS_INIT were passed.
/// @return 0 on success, any non-zero return value from a callback
/// function, or a negative value to indicate an error (use
/// `git_error_last` for a detailed error message)
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_clone_options> )>()
external int git_clone(ffi.Pointer<ffi.Pointer<git_repository>> out,
ffi.Pointer<ffi.Char> url,
ffi.Pointer<ffi.Char> local_path,
ffi.Pointer<git_clone_options> options,
);

/// Free a config entry.
/// 
/// @param entry The entry to free.
@ffi.Native<ffi.Void Function(ffi.Pointer<git_config_entry> )>()
external void git_config_entry_free(ffi.Pointer<git_config_entry> entry,
);

/// Locate the path to the global configuration file
/// 
/// The user or global configuration file is usually
/// located in `$HOME/.gitconfig`.
/// 
/// This method will try to guess the full path to that
/// file, if the file exists. The returned path
/// may be used on any `git_config` call to load the
/// global configuration file.
/// 
/// This method will not guess the path to the xdg compatible
/// config file (`.config/git/config`).
/// 
/// @param out Pointer to a user-allocated git_buf in which to store the path
/// @return 0 if a global configuration file has been found. Its path will be stored in `out`.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> )>()
external int git_config_find_global(ffi.Pointer<git_buf> out,
);

/// Locate the path to the global xdg compatible configuration file
/// 
/// The xdg compatible configuration file is usually
/// located in `$HOME/.config/git/config`.
/// 
/// This method will try to guess the full path to that
/// file, if the file exists. The returned path
/// may be used on any `git_config` call to load the
/// xdg compatible configuration file.
/// 
/// @param out Pointer to a user-allocated git_buf in which to store the path
/// @return 0 if a xdg compatible configuration file has been
/// found. Its path will be stored in `out`.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> )>()
external int git_config_find_xdg(ffi.Pointer<git_buf> out,
);

/// Locate the path to the system configuration file
/// 
/// If `/etc/gitconfig` doesn't exist, it will look for
/// `%PROGRAMFILES%\Git\etc\gitconfig`.
/// 
/// @param out Pointer to a user-allocated git_buf in which to store the path
/// @return 0 if a system configuration file has been
/// found. Its path will be stored in `out`.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> )>()
external int git_config_find_system(ffi.Pointer<git_buf> out,
);

/// Locate the path to the configuration file in ProgramData
/// 
/// Look for the file in `%PROGRAMDATA%\Git\config` used by portable git.
/// 
/// @param out Pointer to a user-allocated git_buf in which to store the path
/// @return 0 if a ProgramData configuration file has been
/// found. Its path will be stored in `out`.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> )>()
external int git_config_find_programdata(ffi.Pointer<git_buf> out,
);

/// Open the global, XDG and system configuration files
/// 
/// Utility wrapper that finds the global, XDG and system configuration files
/// and opens them into a single prioritized config object that can be
/// used when accessing default config data outside a repository.
/// 
/// @param out Pointer to store the config instance
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config>> )>()
external int git_config_open_default(ffi.Pointer<ffi.Pointer<git_config>> out,
);

/// Allocate a new configuration object
/// 
/// This object is empty, so you have to add a file to it before you
/// can do anything with it.
/// 
/// @param out pointer to the new configuration
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config>> )>()
external int git_config_new(ffi.Pointer<ffi.Pointer<git_config>> out,
);

/// Add an on-disk config file instance to an existing config
/// 
/// The on-disk file pointed at by `path` will be opened and
/// parsed; it's expected to be a native Git config file following
/// the default Git config syntax (see man git-config).
/// 
/// If the file does not exist, the file will still be added and it
/// will be created the first time we write to it.
/// 
/// Note that the configuration object will free the file
/// automatically.
/// 
/// Further queries on this config object will access each
/// of the config file instances in order (instances with
/// a higher priority level will be accessed first).
/// 
/// @param cfg the configuration to add the file to
/// @param path path to the configuration file to add
/// @param level the priority level of the backend
/// @param repo optional repository to allow parsing of
/// conditional includes
/// @param force replace config file at the given priority level
/// @return 0 on success, GIT_EEXISTS when adding more than one file
/// for a given priority level (and force_replace set to 0),
/// GIT_ENOTFOUND when the file doesn't exist or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_config> , ffi.Pointer<ffi.Char> , ffi.Int , ffi.Pointer<git_repository> , ffi.Int )>(symbol: 'git_config_add_file_ondisk')
external int _git_config_add_file_ondisk(ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.Char> path,
int level,
ffi.Pointer<git_repository> repo,
int force,
);

int git_config_add_file_ondisk(ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.Char> path,
git_config_level_t level,
ffi.Pointer<git_repository> repo,
int force,
) => _git_config_add_file_ondisk(cfg,
path,
level.value,
repo,
force,
);

/// Create a new config instance containing a single on-disk file
/// 
/// This method is a simple utility wrapper for the following sequence
/// of calls:
/// - git_config_new
/// - git_config_add_file_ondisk
/// 
/// @param out The configuration instance to create
/// @param path Path to the on-disk file to open
/// @return 0 on success, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config>> , ffi.Pointer<ffi.Char> )>()
external int git_config_open_ondisk(ffi.Pointer<ffi.Pointer<git_config>> out,
ffi.Pointer<ffi.Char> path,
);

/// Build a single-level focused config object from a multi-level one.
/// 
/// The returned config object can be used to perform get/set/delete operations
/// on a single specific level.
/// 
/// Getting several times the same level from the same parent multi-level config
/// will return different config instances, but containing the same config_file
/// instance.
/// 
/// @param out The configuration instance to create
/// @param parent Multi-level config to search for the given level
/// @param level Configuration level to search for
/// @return 0, GIT_ENOTFOUND if the passed level cannot be found in the
/// multi-level parent config, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config>> , ffi.Pointer<git_config> , ffi.Int )>(symbol: 'git_config_open_level')
external int _git_config_open_level(ffi.Pointer<ffi.Pointer<git_config>> out,
ffi.Pointer<git_config> parent,
int level,
);

int git_config_open_level(ffi.Pointer<ffi.Pointer<git_config>> out,
ffi.Pointer<git_config> parent,
git_config_level_t level,
) => _git_config_open_level(out,
parent,
level.value,
);

/// Open the global/XDG configuration file according to git's rules
/// 
/// Git allows you to store your global configuration at
/// `$HOME/.gitconfig` or `$XDG_CONFIG_HOME/git/config`. For backwards
/// compatibility, the XDG file shouldn't be used unless the use has
/// created it explicitly. With this function you'll open the correct
/// one to write to.
/// 
/// @param out pointer in which to store the config object
/// @param config the config object in which to look
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config>> , ffi.Pointer<git_config> )>()
external int git_config_open_global(ffi.Pointer<ffi.Pointer<git_config>> out,
ffi.Pointer<git_config> config,
);

/// Set the write order for configuration backends. By default, the
/// write ordering does not match the read ordering; for example, the
/// worktree configuration is a high-priority for reading, but is not
/// written to unless explicitly chosen.
/// 
/// @param cfg the configuration to change write order of
/// @param levels the ordering of levels for writing
/// @param len the length of the levels array
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_config> , ffi.Pointer<ffi.Int> , ffi.Size )>()
external int git_config_set_writeorder(ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.Int> levels,
int len,
);

/// Create a snapshot of the configuration
/// 
/// Create a snapshot of the current state of a configuration, which
/// allows you to look into a consistent view of the configuration for
/// looking up complex values (e.g. a remote, submodule).
/// 
/// The string returned when querying such a config object is valid
/// until it is freed.
/// 
/// @param out pointer in which to store the snapshot config object
/// @param config configuration to snapshot
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config>> , ffi.Pointer<git_config> )>()
external int git_config_snapshot(ffi.Pointer<ffi.Pointer<git_config>> out,
ffi.Pointer<git_config> config,
);

/// Free the configuration and its associated memory and files
/// 
/// @param cfg the configuration to free
@ffi.Native<ffi.Void Function(ffi.Pointer<git_config> )>()
external void git_config_free(ffi.Pointer<git_config> cfg,
);

/// Get the git_config_entry of a config variable.
/// 
/// Free the git_config_entry after use with `git_config_entry_free()`.
/// 
/// @param out pointer to the variable git_config_entry
/// @param cfg where to look for the variable
/// @param name the variable's name
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config_entry>> , ffi.Pointer<git_config> , ffi.Pointer<ffi.Char> )>()
external int git_config_get_entry(ffi.Pointer<ffi.Pointer<git_config_entry>> out,
ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.Char> name,
);

/// Get the value of an integer config variable.
/// 
/// All config files will be looked into, in the order of their
/// defined level. A higher level means a higher priority. The
/// first occurrence of the variable will be returned here.
/// 
/// @param out pointer to the variable where the value should be stored
/// @param cfg where to look for the variable
/// @param name the variable's name
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Int32> , ffi.Pointer<git_config> , ffi.Pointer<ffi.Char> )>()
external int git_config_get_int32(ffi.Pointer<ffi.Int32> out,
ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.Char> name,
);

/// Get the value of a long integer config variable.
/// 
/// All config files will be looked into, in the order of their
/// defined level. A higher level means a higher priority. The
/// first occurrence of the variable will be returned here.
/// 
/// @param out pointer to the variable where the value should be stored
/// @param cfg where to look for the variable
/// @param name the variable's name
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Int64> , ffi.Pointer<git_config> , ffi.Pointer<ffi.Char> )>()
external int git_config_get_int64(ffi.Pointer<ffi.Int64> out,
ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.Char> name,
);

/// Get the value of a boolean config variable.
/// 
/// This function uses the usual C convention of 0 being false and
/// anything else true.
/// 
/// All config files will be looked into, in the order of their
/// defined level. A higher level means a higher priority. The
/// first occurrence of the variable will be returned here.
/// 
/// @param out pointer to the variable where the value should be stored
/// @param cfg where to look for the variable
/// @param name the variable's name
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Int> , ffi.Pointer<git_config> , ffi.Pointer<ffi.Char> )>()
external int git_config_get_bool(ffi.Pointer<ffi.Int> out,
ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.Char> name,
);

/// Get the value of a path config variable.
/// 
/// A leading '~' will be expanded to the global search path (which
/// defaults to the user's home directory but can be overridden via
/// `git_libgit2_opts()`.
/// 
/// All config files will be looked into, in the order of their
/// defined level. A higher level means a higher priority. The
/// first occurrence of the variable will be returned here.
/// 
/// @param out the buffer in which to store the result
/// @param cfg where to look for the variable
/// @param name the variable's name
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_config> , ffi.Pointer<ffi.Char> )>()
external int git_config_get_path(ffi.Pointer<git_buf> out,
ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.Char> name,
);

/// Get the value of a string config variable.
/// 
/// This function can only be used on snapshot config objects. The
/// string is owned by the config and should not be freed by the
/// user. The pointer will be valid until the config is freed.
/// 
/// All config files will be looked into, in the order of their
/// defined level. A higher level means a higher priority. The
/// first occurrence of the variable will be returned here.
/// 
/// @param out pointer to the string
/// @param cfg where to look for the variable
/// @param name the variable's name
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>> , ffi.Pointer<git_config> , ffi.Pointer<ffi.Char> )>()
external int git_config_get_string(ffi.Pointer<ffi.Pointer<ffi.Char>> out,
ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.Char> name,
);

/// Get the value of a string config variable.
/// 
/// The value of the config will be copied into the buffer.
/// 
/// All config files will be looked into, in the order of their
/// defined level. A higher level means a higher priority. The
/// first occurrence of the variable will be returned here.
/// 
/// @param out buffer in which to store the string
/// @param cfg where to look for the variable
/// @param name the variable's name
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_config> , ffi.Pointer<ffi.Char> )>()
external int git_config_get_string_buf(ffi.Pointer<git_buf> out,
ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.Char> name,
);

/// Get each value of a multivar in a foreach callback
/// 
/// The callback will be called on each variable found
/// 
/// The regular expression is applied case-sensitively on the normalized form of
/// the variable name: the section and variable parts are lower-cased. The
/// subsection is left unchanged.
/// 
/// @param cfg where to look for the variable
/// @param name the variable's name
/// @param regexp regular expression to filter which variables we're
/// interested in. Use NULL to indicate all
/// @param callback the function to be called on each value of the variable
/// @param payload opaque pointer to pass to the callback
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_config> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_config_entry> entry, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_config_get_multivar_foreach(ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.Char> name,
ffi.Pointer<ffi.Char> regexp,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_config_entry> entry, ffi.Pointer<ffi.Void> payload)>> callback,
ffi.Pointer<ffi.Void> payload,
);

/// Get each value of a multivar
/// 
/// The regular expression is applied case-sensitively on the normalized form of
/// the variable name: the section and variable parts are lower-cased. The
/// subsection is left unchanged.
/// 
/// @param out pointer to store the iterator
/// @param cfg where to look for the variable
/// @param name the variable's name
/// @param regexp regular expression to filter which variables we're
/// interested in. Use NULL to indicate all
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config_iterator>> , ffi.Pointer<git_config> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_config_multivar_iterator_new(ffi.Pointer<ffi.Pointer<git_config_iterator>> out,
ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.Char> name,
ffi.Pointer<ffi.Char> regexp,
);

/// Return the current entry and advance the iterator
/// 
/// The pointers returned by this function are valid until the next call
/// to `git_config_next` or until the iterator is freed.
/// 
/// @param entry pointer to store the entry
/// @param iter the iterator
/// @return 0 or an error code. GIT_ITEROVER if the iteration has completed
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config_entry>> , ffi.Pointer<git_config_iterator> )>()
external int git_config_next(ffi.Pointer<ffi.Pointer<git_config_entry>> entry,
ffi.Pointer<git_config_iterator> iter,
);

/// Free a config iterator
/// 
/// @param iter the iterator to free
@ffi.Native<ffi.Void Function(ffi.Pointer<git_config_iterator> )>()
external void git_config_iterator_free(ffi.Pointer<git_config_iterator> iter,
);

/// Set the value of an integer config variable in the config file
/// with the highest level (usually the local one).
/// 
/// @param cfg where to look for the variable
/// @param name the variable's name
/// @param value Integer value for the variable
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_config> , ffi.Pointer<ffi.Char> , ffi.Int32 )>()
external int git_config_set_int32(ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.Char> name,
int value,
);

/// Set the value of a long integer config variable in the config file
/// with the highest level (usually the local one).
/// 
/// @param cfg where to look for the variable
/// @param name the variable's name
/// @param value Long integer value for the variable
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_config> , ffi.Pointer<ffi.Char> , ffi.Int64 )>()
external int git_config_set_int64(ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.Char> name,
int value,
);

/// Set the value of a boolean config variable in the config file
/// with the highest level (usually the local one).
/// 
/// @param cfg where to look for the variable
/// @param name the variable's name
/// @param value the value to store
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_config> , ffi.Pointer<ffi.Char> , ffi.Int )>()
external int git_config_set_bool(ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.Char> name,
int value,
);

/// Set the value of a string config variable in the config file
/// with the highest level (usually the local one).
/// 
/// A copy of the string is made and the user is free to use it
/// afterwards.
/// 
/// @param cfg where to look for the variable
/// @param name the variable's name
/// @param value the string to store.
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_config> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_config_set_string(ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.Char> name,
ffi.Pointer<ffi.Char> value,
);

/// Set a multivar in the local config file.
/// 
/// The regular expression is applied case-sensitively on the value.
/// 
/// @param cfg where to look for the variable
/// @param name the variable's name
/// @param regexp a regular expression to indicate which values to replace
/// @param value the new value.
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_config> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_config_set_multivar(ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.Char> name,
ffi.Pointer<ffi.Char> regexp,
ffi.Pointer<ffi.Char> value,
);

/// Delete a config variable from the config file
/// with the highest level (usually the local one).
/// 
/// @param cfg the configuration
/// @param name the variable to delete
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_config> , ffi.Pointer<ffi.Char> )>()
external int git_config_delete_entry(ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.Char> name,
);

/// Deletes one or several entries from a multivar in the local config file.
/// 
/// The regular expression is applied case-sensitively on the value.
/// 
/// @param cfg where to look for the variables
/// @param name the variable's name
/// @param regexp a regular expression to indicate which values to delete
/// 
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_config> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_config_delete_multivar(ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.Char> name,
ffi.Pointer<ffi.Char> regexp,
);

/// Perform an operation on each config variable.
/// 
/// The callback receives the normalized name and value of each variable
/// in the config backend, and the data pointer passed to this function.
/// If the callback returns a non-zero value, the function stops iterating
/// and returns that value to the caller.
/// 
/// The pointers passed to the callback are only valid as long as the
/// iteration is ongoing.
/// 
/// @param cfg where to get the variables from
/// @param callback the function to call on each variable
/// @param payload the data to pass to the callback
/// @return 0 on success, non-zero callback return value, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_config> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_config_entry> entry, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_config_foreach(ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_config_entry> entry, ffi.Pointer<ffi.Void> payload)>> callback,
ffi.Pointer<ffi.Void> payload,
);

/// Iterate over all the config variables
/// 
/// Use `git_config_next` to advance the iteration and
/// `git_config_iterator_free` when done.
/// 
/// @param out pointer to store the iterator
/// @param cfg where to get the variables from
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config_iterator>> , ffi.Pointer<git_config> )>()
external int git_config_iterator_new(ffi.Pointer<ffi.Pointer<git_config_iterator>> out,
ffi.Pointer<git_config> cfg,
);

/// Iterate over all the config variables whose name matches a pattern
/// 
/// Use `git_config_next` to advance the iteration and
/// `git_config_iterator_free` when done.
/// 
/// The regular expression is applied case-sensitively on the normalized form of
/// the variable name: the section and variable parts are lower-cased. The
/// subsection is left unchanged.
/// 
/// @param out pointer to store the iterator
/// @param cfg where to ge the variables from
/// @param regexp regular expression to match the names
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config_iterator>> , ffi.Pointer<git_config> , ffi.Pointer<ffi.Char> )>()
external int git_config_iterator_glob_new(ffi.Pointer<ffi.Pointer<git_config_iterator>> out,
ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.Char> regexp,
);

/// Perform an operation on each config variable matching a regular expression.
/// 
/// This behaves like `git_config_foreach` with an additional filter of a
/// regular expression that filters which config keys are passed to the
/// callback.
/// 
/// The regular expression is applied case-sensitively on the normalized form of
/// the variable name: the section and variable parts are lower-cased. The
/// subsection is left unchanged.
/// 
/// The regular expression is applied case-sensitively on the normalized form of
/// the variable name: the case-insensitive parts are lower-case.
/// 
/// @param cfg where to get the variables from
/// @param regexp regular expression to match against config names
/// @param callback the function to call on each variable
/// @param payload the data to pass to the callback
/// @return 0 or the return value of the callback which didn't return 0
@ffi.Native<ffi.Int Function(ffi.Pointer<git_config> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_config_entry> entry, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_config_foreach_match(ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.Char> regexp,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_config_entry> entry, ffi.Pointer<ffi.Void> payload)>> callback,
ffi.Pointer<ffi.Void> payload,
);

/// Query the value of a config variable and return it mapped to
/// an integer constant.
/// 
/// This is a helper method to easily map different possible values
/// to a variable to integer constants that easily identify them.
/// 
/// A mapping array looks as follows:
/// 
/// git_configmap autocrlf_mapping[] = {
/// {GIT_CVAR_FALSE, NULL, GIT_AUTO_CRLF_FALSE},
/// {GIT_CVAR_TRUE, NULL, GIT_AUTO_CRLF_TRUE},
/// {GIT_CVAR_STRING, "input", GIT_AUTO_CRLF_INPUT},
/// {GIT_CVAR_STRING, "default", GIT_AUTO_CRLF_DEFAULT}};
/// 
/// On any "false" value for the variable (e.g. "false", "FALSE", "no"), the
/// mapping will store `GIT_AUTO_CRLF_FALSE` in the `out` parameter.
/// 
/// The same thing applies for any "true" value such as "true", "yes" or "1", storing
/// the `GIT_AUTO_CRLF_TRUE` variable.
/// 
/// Otherwise, if the value matches the string "input" (with case insensitive comparison),
/// the given constant will be stored in `out`, and likewise for "default".
/// 
/// If not a single match can be made to store in `out`, an error code will be
/// returned.
/// 
/// @param out place to store the result of the mapping
/// @param cfg config file to get the variables from
/// @param name name of the config variable to lookup
/// @param maps array of `git_configmap` objects specifying the possible mappings
/// @param map_n number of mapping objects in `maps`
/// @return 0 on success, error code otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Int> , ffi.Pointer<git_config> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_configmap> , ffi.Size )>()
external int git_config_get_mapped(ffi.Pointer<ffi.Int> out,
ffi.Pointer<git_config> cfg,
ffi.Pointer<ffi.Char> name,
ffi.Pointer<git_configmap> maps,
int map_n,
);

/// Maps a string value to an integer constant
/// 
/// @param out place to store the result of the parsing
/// @param maps array of `git_configmap` objects specifying the possible mappings
/// @param map_n number of mapping objects in `maps`
/// @param value value to parse
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Int> , ffi.Pointer<git_configmap> , ffi.Size , ffi.Pointer<ffi.Char> )>()
external int git_config_lookup_map_value(ffi.Pointer<ffi.Int> out,
ffi.Pointer<git_configmap> maps,
int map_n,
ffi.Pointer<ffi.Char> value,
);

/// Parse a string value as a bool.
/// 
/// Valid values for true are: 'true', 'yes', 'on', 1 or any
/// number different from 0
/// Valid values for false are: 'false', 'no', 'off', 0
/// 
/// @param out place to store the result of the parsing
/// @param value value to parse
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Int> , ffi.Pointer<ffi.Char> )>()
external int git_config_parse_bool(ffi.Pointer<ffi.Int> out,
ffi.Pointer<ffi.Char> value,
);

/// Parse a string value as an int32.
/// 
/// An optional value suffix of 'k', 'm', or 'g' will
/// cause the value to be multiplied by 1024, 1048576,
/// or 1073741824 prior to output.
/// 
/// @param out place to store the result of the parsing
/// @param value value to parse
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Int32> , ffi.Pointer<ffi.Char> )>()
external int git_config_parse_int32(ffi.Pointer<ffi.Int32> out,
ffi.Pointer<ffi.Char> value,
);

/// Parse a string value as an int64.
/// 
/// An optional value suffix of 'k', 'm', or 'g' will
/// cause the value to be multiplied by 1024, 1048576,
/// or 1073741824 prior to output.
/// 
/// @param out place to store the result of the parsing
/// @param value value to parse
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Int64> , ffi.Pointer<ffi.Char> )>()
external int git_config_parse_int64(ffi.Pointer<ffi.Int64> out,
ffi.Pointer<ffi.Char> value,
);

/// Parse a string value as a path.
/// 
/// A leading '~' will be expanded to the global search path (which
/// defaults to the user's home directory but can be overridden via
/// `git_libgit2_opts()`.
/// 
/// If the value does not begin with a tilde, the input will be
/// returned.
/// 
/// @param out placae to store the result of parsing
/// @param value the path to evaluate
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<ffi.Char> )>()
external int git_config_parse_path(ffi.Pointer<git_buf> out,
ffi.Pointer<ffi.Char> value,
);

/// Perform an operation on each config variable in a given config backend,
/// matching a regular expression.
/// 
/// This behaves like `git_config_foreach_match` except that only config
/// entries from the given backend entry are enumerated.
/// 
/// The regular expression is applied case-sensitively on the normalized form of
/// the variable name: the section and variable parts are lower-cased. The
/// subsection is left unchanged.
/// 
/// @param backend where to get the variables from
/// @param regexp regular expression to match against config names (can be NULL)
/// @param callback the function to call on each variable
/// @param payload the data to pass to the callback
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_config_backend> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_config_entry> entry, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_config_backend_foreach_match(ffi.Pointer<git_config_backend> backend,
ffi.Pointer<ffi.Char> regexp,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_config_entry> entry, ffi.Pointer<ffi.Void> payload)>> callback,
ffi.Pointer<ffi.Void> payload,
);

/// Lock the backend with the highest priority
/// 
/// Locking disallows anybody else from writing to that backend. Any
/// updates made after locking will not be visible to a reader until
/// the file is unlocked.
/// 
/// You can apply the changes by calling `git_transaction_commit()`
/// before freeing the transaction. Either of these actions will unlock
/// the config.
/// 
/// @param tx the resulting transaction, use this to commit or undo the
/// changes
/// @param cfg the configuration in which to lock
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_transaction>> , ffi.Pointer<git_config> )>()
external int git_config_lock(ffi.Pointer<ffi.Pointer<git_transaction>> tx,
ffi.Pointer<git_config> cfg,
);

/// Initialize git_describe_options structure
/// 
/// Initializes a `git_describe_options` with default values. Equivalent to creating
/// an instance with GIT_DESCRIBE_OPTIONS_INIT.
/// 
/// @param opts The `git_describe_options` struct to initialize.
/// @param version The struct version; pass `GIT_DESCRIBE_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_describe_options> , ffi.UnsignedInt )>()
external int git_describe_options_init(ffi.Pointer<git_describe_options> opts,
int version,
);

/// Initialize git_describe_format_options structure
/// 
/// Initializes a `git_describe_format_options` with default values. Equivalent to creating
/// an instance with GIT_DESCRIBE_FORMAT_OPTIONS_INIT.
/// 
/// @param opts The `git_describe_format_options` struct to initialize.
/// @param version The struct version; pass `GIT_DESCRIBE_FORMAT_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_describe_format_options> , ffi.UnsignedInt )>()
external int git_describe_format_options_init(ffi.Pointer<git_describe_format_options> opts,
int version,
);

/// Describe a commit
/// 
/// Perform the describe operation on the given committish object.
/// 
/// @param result pointer to store the result. You must free this once
/// you're done with it.
/// @param committish a committish to describe
/// @param opts the lookup options (or NULL for defaults)
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_describe_result>> , ffi.Pointer<git_object> , ffi.Pointer<git_describe_options> )>()
external int git_describe_commit(ffi.Pointer<ffi.Pointer<git_describe_result>> result,
ffi.Pointer<git_object> committish,
ffi.Pointer<git_describe_options> opts,
);

/// Describe a commit
/// 
/// Perform the describe operation on the current commit and the
/// worktree. After performing describe on HEAD, a status is run and the
/// description is considered to be dirty if there are.
/// 
/// @param out pointer to store the result. You must free this once
/// you're done with it.
/// @param repo the repository in which to perform the describe
/// @param opts the lookup options (or NULL for defaults)
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_describe_result>> , ffi.Pointer<git_repository> , ffi.Pointer<git_describe_options> )>()
external int git_describe_workdir(ffi.Pointer<ffi.Pointer<git_describe_result>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_describe_options> opts,
);

/// Print the describe result to a buffer
/// 
/// @param out The buffer to store the result
/// @param result the result from `git_describe_commit()` or
/// `git_describe_workdir()`.
/// @param opts the formatting options (or NULL for defaults)
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_describe_result> , ffi.Pointer<git_describe_format_options> )>()
external int git_describe_format(ffi.Pointer<git_buf> out,
ffi.Pointer<git_describe_result> result,
ffi.Pointer<git_describe_format_options> opts,
);

/// Free the describe result.
/// 
/// @param result The result to free.
@ffi.Native<ffi.Void Function(ffi.Pointer<git_describe_result> )>()
external void git_describe_result_free(ffi.Pointer<git_describe_result> result,
);

/// Return the last `git_error` object that was generated for the
/// current thread.
/// 
/// This function will never return NULL.
/// 
/// Callers should not rely on this to determine whether an error has
/// occurred. For error checking, callers should examine the return
/// codes of libgit2 functions.
/// 
/// This call can only reliably report error messages when an error
/// has occurred. (It may contain stale information if it is called
/// after a different function that succeeds.)
/// 
/// The memory for this object is managed by libgit2. It should not
/// be freed.
/// 
/// @return A pointer to a `git_error` object that describes the error.
@ffi.Native<ffi.Pointer<git_error> Function()>()
external ffi.Pointer<git_error> git_error_last();

/// Load the filter list for a given path.
/// 
/// This will return 0 (success) but set the output git_filter_list to NULL
/// if no filters are requested for the given file.
/// 
/// @param filters Output newly created git_filter_list (or NULL)
/// @param repo Repository object that contains `path`
/// @param blob The blob to which the filter will be applied (if known)
/// @param path Relative path of the file to be filtered
/// @param mode Filtering direction (WT->ODB or ODB->WT)
/// @param flags Combination of `git_filter_flag_t` flags
/// @return 0 on success (which could still return NULL if no filters are
/// needed for the requested file), <0 on error
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_filter_list>> , ffi.Pointer<git_repository> , ffi.Pointer<git_blob> , ffi.Pointer<ffi.Char> , ffi.UnsignedInt , ffi.Uint32 )>(symbol: 'git_filter_list_load')
external int _git_filter_list_load(ffi.Pointer<ffi.Pointer<git_filter_list>> filters,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_blob> blob,
ffi.Pointer<ffi.Char> path,
int mode,
int flags,
);

int git_filter_list_load(ffi.Pointer<ffi.Pointer<git_filter_list>> filters,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_blob> blob,
ffi.Pointer<ffi.Char> path,
git_filter_mode_t mode,
int flags,
) => _git_filter_list_load(filters,
repo,
blob,
path,
mode.value,
flags,
);

/// Load the filter list for a given path.
/// 
/// This will return 0 (success) but set the output git_filter_list to NULL
/// if no filters are requested for the given file.
/// 
/// @param filters Output newly created git_filter_list (or NULL)
/// @param repo Repository object that contains `path`
/// @param blob The blob to which the filter will be applied (if known)
/// @param path Relative path of the file to be filtered
/// @param mode Filtering direction (WT->ODB or ODB->WT)
/// @param opts The `git_filter_options` to use when loading filters
/// @return 0 on success (which could still return NULL if no filters are
/// needed for the requested file), <0 on error
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_filter_list>> , ffi.Pointer<git_repository> , ffi.Pointer<git_blob> , ffi.Pointer<ffi.Char> , ffi.UnsignedInt , ffi.Pointer<git_filter_options> )>(symbol: 'git_filter_list_load_ext')
external int _git_filter_list_load_ext(ffi.Pointer<ffi.Pointer<git_filter_list>> filters,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_blob> blob,
ffi.Pointer<ffi.Char> path,
int mode,
ffi.Pointer<git_filter_options> opts,
);

int git_filter_list_load_ext(ffi.Pointer<ffi.Pointer<git_filter_list>> filters,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_blob> blob,
ffi.Pointer<ffi.Char> path,
git_filter_mode_t mode,
ffi.Pointer<git_filter_options> opts,
) => _git_filter_list_load_ext(filters,
repo,
blob,
path,
mode.value,
opts,
);

/// Query the filter list to see if a given filter (by name) will run.
/// The built-in filters "crlf" and "ident" can be queried, otherwise this
/// is the name of the filter specified by the filter attribute.
/// 
/// This will return 0 if the given filter is not in the list, or 1 if
/// the filter will be applied.
/// 
/// @param filters A loaded git_filter_list (or NULL)
/// @param name The name of the filter to query
/// @return 1 if the filter is in the list, 0 otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_filter_list> , ffi.Pointer<ffi.Char> )>()
external int git_filter_list_contains(ffi.Pointer<git_filter_list> filters,
ffi.Pointer<ffi.Char> name,
);

/// Apply filter list to a data buffer.
/// 
/// @param out Buffer to store the result of the filtering
/// @param filters A loaded git_filter_list (or NULL)
/// @param in Buffer containing the data to filter
/// @param in_len The length of the input buffer
/// @return 0 on success, an error code otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_filter_list> , ffi.Pointer<ffi.Char> , ffi.Size )>()
external int git_filter_list_apply_to_buffer(ffi.Pointer<git_buf> out,
ffi.Pointer<git_filter_list> filters,
ffi.Pointer<ffi.Char> in$,
int in_len,
);

/// Apply a filter list to the contents of a file on disk
/// 
/// @param out buffer into which to store the filtered file
/// @param filters the list of filters to apply
/// @param repo the repository in which to perform the filtering
/// @param path the path of the file to filter, a relative path will be
/// taken as relative to the workdir
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_filter_list> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_filter_list_apply_to_file(ffi.Pointer<git_buf> out,
ffi.Pointer<git_filter_list> filters,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> path,
);

/// Apply a filter list to the contents of a blob
/// 
/// @param out buffer into which to store the filtered file
/// @param filters the list of filters to apply
/// @param blob the blob to filter
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_filter_list> , ffi.Pointer<git_blob> )>()
external int git_filter_list_apply_to_blob(ffi.Pointer<git_buf> out,
ffi.Pointer<git_filter_list> filters,
ffi.Pointer<git_blob> blob,
);

/// Apply a filter list to an arbitrary buffer as a stream
/// 
/// @param filters the list of filters to apply
/// @param buffer the buffer to filter
/// @param len the size of the buffer
/// @param target the stream into which the data will be written
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_filter_list> , ffi.Pointer<ffi.Char> , ffi.Size , ffi.Pointer<git_writestream> )>()
external int git_filter_list_stream_buffer(ffi.Pointer<git_filter_list> filters,
ffi.Pointer<ffi.Char> buffer,
int len,
ffi.Pointer<git_writestream> target,
);

/// Apply a filter list to a file as a stream
/// 
/// @param filters the list of filters to apply
/// @param repo the repository in which to perform the filtering
/// @param path the path of the file to filter, a relative path will be
/// taken as relative to the workdir
/// @param target the stream into which the data will be written
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_filter_list> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_writestream> )>()
external int git_filter_list_stream_file(ffi.Pointer<git_filter_list> filters,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> path,
ffi.Pointer<git_writestream> target,
);

/// Apply a filter list to a blob as a stream
/// 
/// @param filters the list of filters to apply
/// @param blob the blob to filter
/// @param target the stream into which the data will be written
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_filter_list> , ffi.Pointer<git_blob> , ffi.Pointer<git_writestream> )>()
external int git_filter_list_stream_blob(ffi.Pointer<git_filter_list> filters,
ffi.Pointer<git_blob> blob,
ffi.Pointer<git_writestream> target,
);

/// Free a git_filter_list
/// 
/// @param filters A git_filter_list created by `git_filter_list_load`
@ffi.Native<ffi.Void Function(ffi.Pointer<git_filter_list> )>()
external void git_filter_list_free(ffi.Pointer<git_filter_list> filters,
);

/// Initialize git_rebase_options structure
/// 
/// Initializes a `git_rebase_options` with default values. Equivalent to
/// creating an instance with `GIT_REBASE_OPTIONS_INIT`.
/// 
/// @param opts The `git_rebase_options` struct to initialize.
/// @param version The struct version; pass `GIT_REBASE_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_rebase_options> , ffi.UnsignedInt )>()
external int git_rebase_options_init(ffi.Pointer<git_rebase_options> opts,
int version,
);

/// Initializes a rebase operation to rebase the changes in `branch`
/// relative to `upstream` onto another branch.  To begin the rebase
/// process, call `git_rebase_next`.  When you have finished with this
/// object, call `git_rebase_free`.
/// 
/// @param out Pointer to store the rebase object
/// @param repo The repository to perform the rebase
/// @param branch The terminal commit to rebase, or NULL to rebase the
/// current branch
/// @param upstream The commit to begin rebasing from, or NULL to rebase all
/// reachable commits
/// @param onto The branch to rebase onto, or NULL to rebase onto the given
/// upstream
/// @param opts Options to specify how rebase is performed, or NULL
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_rebase>> , ffi.Pointer<git_repository> , ffi.Pointer<git_annotated_commit> , ffi.Pointer<git_annotated_commit> , ffi.Pointer<git_annotated_commit> , ffi.Pointer<git_rebase_options> )>()
external int git_rebase_init(ffi.Pointer<ffi.Pointer<git_rebase>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_annotated_commit> branch,
ffi.Pointer<git_annotated_commit> upstream,
ffi.Pointer<git_annotated_commit> onto,
ffi.Pointer<git_rebase_options> opts,
);

/// Opens an existing rebase that was previously started by either an
/// invocation of `git_rebase_init` or by another client.
/// 
/// @param out Pointer to store the rebase object
/// @param repo The repository that has a rebase in-progress
/// @param opts Options to specify how rebase is performed
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_rebase>> , ffi.Pointer<git_repository> , ffi.Pointer<git_rebase_options> )>()
external int git_rebase_open(ffi.Pointer<ffi.Pointer<git_rebase>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_rebase_options> opts,
);

/// Gets the original `HEAD` ref name for merge rebases.
/// 
/// @param rebase The in-progress rebase.
/// @return The original `HEAD` ref name
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_rebase> )>()
external ffi.Pointer<ffi.Char> git_rebase_orig_head_name(ffi.Pointer<git_rebase> rebase,
);

/// Gets the original `HEAD` id for merge rebases.
/// 
/// @param rebase The in-progress rebase.
/// @return The original `HEAD` id
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_rebase> )>()
external ffi.Pointer<git_oid> git_rebase_orig_head_id(ffi.Pointer<git_rebase> rebase,
);

/// Gets the `onto` ref name for merge rebases.
/// 
/// @param rebase The in-progress rebase.
/// @return The `onto` ref name
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_rebase> )>()
external ffi.Pointer<ffi.Char> git_rebase_onto_name(ffi.Pointer<git_rebase> rebase,
);

/// Gets the `onto` id for merge rebases.
/// 
/// @param rebase The in-progress rebase.
/// @return The `onto` id
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_rebase> )>()
external ffi.Pointer<git_oid> git_rebase_onto_id(ffi.Pointer<git_rebase> rebase,
);

/// Gets the count of rebase operations that are to be applied.
/// 
/// @param rebase The in-progress rebase
/// @return The number of rebase operations in total
@ffi.Native<ffi.Size Function(ffi.Pointer<git_rebase> )>()
external int git_rebase_operation_entrycount(ffi.Pointer<git_rebase> rebase,
);

/// Gets the index of the rebase operation that is currently being applied.
/// If the first operation has not yet been applied (because you have
/// called `init` but not yet `next`) then this returns
/// `GIT_REBASE_NO_OPERATION`.
/// 
/// @param rebase The in-progress rebase
/// @return The index of the rebase operation currently being applied.
@ffi.Native<ffi.Size Function(ffi.Pointer<git_rebase> )>()
external int git_rebase_operation_current(ffi.Pointer<git_rebase> rebase,
);

/// Gets the rebase operation specified by the given index.
/// 
/// @param rebase The in-progress rebase
/// @param idx The index of the rebase operation to retrieve
/// @return The rebase operation or NULL if `idx` was out of bounds
@ffi.Native<ffi.Pointer<git_rebase_operation> Function(ffi.Pointer<git_rebase> , ffi.Size )>()
external ffi.Pointer<git_rebase_operation> git_rebase_operation_byindex(ffi.Pointer<git_rebase> rebase,
int idx,
);

/// Performs the next rebase operation and returns the information about it.
/// If the operation is one that applies a patch (which is any operation except
/// GIT_REBASE_OPERATION_EXEC) then the patch will be applied and the index and
/// working directory will be updated with the changes.  If there are conflicts,
/// you will need to address those before committing the changes.
/// 
/// @param operation Pointer to store the rebase operation that is to be performed next
/// @param rebase The rebase in progress
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_rebase_operation>> , ffi.Pointer<git_rebase> )>()
external int git_rebase_next(ffi.Pointer<ffi.Pointer<git_rebase_operation>> operation,
ffi.Pointer<git_rebase> rebase,
);

/// Gets the index produced by the last operation, which is the result
/// of `git_rebase_next` and which will be committed by the next
/// invocation of `git_rebase_commit`.  This is useful for resolving
/// conflicts in an in-memory rebase before committing them.  You must
/// call `git_index_free` when you are finished with this.
/// 
/// This is only applicable for in-memory rebases; for rebases within
/// a working directory, the changes were applied to the repository's
/// index.
/// 
/// @param index The result index of the last operation.
/// @param rebase The in-progress rebase.
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index>> , ffi.Pointer<git_rebase> )>()
external int git_rebase_inmemory_index(ffi.Pointer<ffi.Pointer<git_index>> index,
ffi.Pointer<git_rebase> rebase,
);

/// Commits the current patch.  You must have resolved any conflicts that
/// were introduced during the patch application from the `git_rebase_next`
/// invocation.
/// 
/// @param id Pointer in which to store the OID of the newly created commit
/// @param rebase The rebase that is in-progress
/// @param author The author of the updated commit, or NULL to keep the
/// author from the original commit
/// @param committer The committer of the rebase
/// @param message_encoding The encoding for the message in the commit,
/// represented with a standard encoding name.  If message is NULL,
/// this should also be NULL, and the encoding from the original
/// commit will be maintained.  If message is specified, this may be
/// NULL to indicate that "UTF-8" is to be used.
/// @param message The message for this commit, or NULL to use the message
/// from the original commit.
/// @return Zero on success, GIT_EUNMERGED if there are unmerged changes in
/// the index, GIT_EAPPLIED if the current commit has already
/// been applied to the upstream and there is nothing to commit,
/// -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_rebase> , ffi.Pointer<git_signature> , ffi.Pointer<git_signature> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_rebase_commit(ffi.Pointer<git_oid> id,
ffi.Pointer<git_rebase> rebase,
ffi.Pointer<git_signature> author,
ffi.Pointer<git_signature> committer,
ffi.Pointer<ffi.Char> message_encoding,
ffi.Pointer<ffi.Char> message,
);

/// Aborts a rebase that is currently in progress, resetting the repository
/// and working directory to their state before rebase began.
/// 
/// @param rebase The rebase that is in-progress
/// @return Zero on success; GIT_ENOTFOUND if a rebase is not in progress,
/// -1 on other errors.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_rebase> )>()
external int git_rebase_abort(ffi.Pointer<git_rebase> rebase,
);

/// Finishes a rebase that is currently in progress once all patches have
/// been applied.
/// 
/// @param rebase The rebase that is in-progress
/// @param signature The identity that is finishing the rebase (optional)
/// @return Zero on success; -1 on error
@ffi.Native<ffi.Int Function(ffi.Pointer<git_rebase> , ffi.Pointer<git_signature> )>()
external int git_rebase_finish(ffi.Pointer<git_rebase> rebase,
ffi.Pointer<git_signature> signature,
);

/// Frees the `git_rebase` object.
/// 
/// @param rebase The rebase object
@ffi.Native<ffi.Void Function(ffi.Pointer<git_rebase> )>()
external void git_rebase_free(ffi.Pointer<git_rebase> rebase,
);

/// Sets the system tracing configuration to the specified level with the
/// specified callback.  When system events occur at a level equal to, or
/// lower than, the given level they will be reported to the given callback.
/// 
/// @param level Level to set tracing to
/// @param cb Function to call with trace data
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.UnsignedInt , ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt level, ffi.Pointer<ffi.Char> msg)>> )>(symbol: 'git_trace_set')
external int _git_trace_set(int level,
ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt level, ffi.Pointer<ffi.Char> msg)>> cb,
);

int git_trace_set(git_trace_level_t level,
ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt level, ffi.Pointer<ffi.Char> msg)>> cb,
) => _git_trace_set(level.value,
cb,
);

/// Initialize git_revert_options structure
/// 
/// Initializes a `git_revert_options` with default values. Equivalent to
/// creating an instance with `GIT_REVERT_OPTIONS_INIT`.
/// 
/// @param opts The `git_revert_options` struct to initialize.
/// @param version The struct version; pass `GIT_REVERT_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_revert_options> , ffi.UnsignedInt )>()
external int git_revert_options_init(ffi.Pointer<git_revert_options> opts,
int version,
);

/// Reverts the given commit against the given "our" commit, producing an
/// index that reflects the result of the revert.
/// 
/// The returned index must be freed explicitly with `git_index_free`.
/// 
/// @param out pointer to store the index result in
/// @param repo the repository that contains the given commits
/// @param revert_commit the commit to revert
/// @param our_commit the commit to revert against (eg, HEAD)
/// @param mainline the parent of the revert commit, if it is a merge
/// @param merge_options the merge options (or null for defaults)
/// @return zero on success, -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index>> , ffi.Pointer<git_repository> , ffi.Pointer<git_commit> , ffi.Pointer<git_commit> , ffi.UnsignedInt , ffi.Pointer<git_merge_options> )>()
external int git_revert_commit(ffi.Pointer<ffi.Pointer<git_index>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_commit> revert_commit,
ffi.Pointer<git_commit> our_commit,
int mainline,
ffi.Pointer<git_merge_options> merge_options,
);

/// Reverts the given commit, producing changes in the index and working directory.
/// 
/// @param repo the repository to revert
/// @param commit the commit to revert
/// @param given_opts the revert options (or null for defaults)
/// @return zero on success, -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<git_commit> , ffi.Pointer<git_revert_options> )>()
external int git_revert(ffi.Pointer<git_repository> repo,
ffi.Pointer<git_commit> commit,
ffi.Pointer<git_revert_options> given_opts,
);

/// Find a single object, as specified by a revision string.
/// 
/// See `man gitrevisions`, or
/// http://git-scm.com/docs/git-rev-parse.html#_specifying_revisions for
/// information on the syntax accepted.
/// 
/// The returned object should be released with `git_object_free` when no
/// longer needed.
/// 
/// @param out pointer to output object
/// @param repo the repository to search in
/// @param spec the textual specification for an object
/// @return 0 on success, GIT_ENOTFOUND, GIT_EAMBIGUOUS, GIT_EINVALIDSPEC or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_object>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_revparse_single(ffi.Pointer<ffi.Pointer<git_object>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> spec,
);

/// Find a single object and intermediate reference by a revision string.
/// 
/// See `man gitrevisions`, or
/// http://git-scm.com/docs/git-rev-parse.html#_specifying_revisions for
/// information on the syntax accepted.
/// 
/// In some cases (`@{<-n>}` or `<branchname>@{upstream}`), the expression may
/// point to an intermediate reference. When such expressions are being passed
/// in, `reference_out` will be valued as well.
/// 
/// The returned object should be released with `git_object_free` and the
/// returned reference with `git_reference_free` when no longer needed.
/// 
/// @param object_out pointer to output object
/// @param reference_out pointer to output reference or NULL
/// @param repo the repository to search in
/// @param spec the textual specification for an object
/// @return 0 on success, GIT_ENOTFOUND, GIT_EAMBIGUOUS, GIT_EINVALIDSPEC
/// or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_object>> , ffi.Pointer<ffi.Pointer<git_reference>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_revparse_ext(ffi.Pointer<ffi.Pointer<git_object>> object_out,
ffi.Pointer<ffi.Pointer<git_reference>> reference_out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> spec,
);

/// Parse a revision string for `from`, `to`, and intent.
/// 
/// See `man gitrevisions` or
/// http://git-scm.com/docs/git-rev-parse.html#_specifying_revisions for
/// information on the syntax accepted.
/// 
/// @param revspec Pointer to an user-allocated git_revspec struct where
/// the result of the rev-parse will be stored
/// @param repo the repository to search in
/// @param spec the rev-parse spec to parse
/// @return 0 on success, GIT_INVALIDSPEC, GIT_ENOTFOUND, GIT_EAMBIGUOUS or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_revspec> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_revparse(ffi.Pointer<git_revspec> revspec,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> spec,
);

/// Save the local modifications to a new stash.
/// 
/// @param out Object id of the commit containing the stashed state.
/// This commit is also the target of the direct reference refs/stash.
/// @param repo The owning repository.
/// @param stasher The identity of the person performing the stashing.
/// @param message Optional description along with the stashed state.
/// @param flags Flags to control the stashing process. (see GIT_STASH_* above)
/// @return 0 on success, GIT_ENOTFOUND where there's nothing to stash,
/// or error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<git_signature> , ffi.Pointer<ffi.Char> , ffi.Uint32 )>()
external int git_stash_save(ffi.Pointer<git_oid> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_signature> stasher,
ffi.Pointer<ffi.Char> message,
int flags,
);

/// Initialize git_stash_save_options structure
/// 
/// Initializes a `git_stash_save_options` with default values. Equivalent to
/// creating an instance with `GIT_STASH_SAVE_OPTIONS_INIT`.
/// 
/// @param opts The `git_stash_save_options` struct to initialize.
/// @param version The struct version; pass `GIT_STASH_SAVE_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_stash_save_options> , ffi.UnsignedInt )>()
external int git_stash_save_options_init(ffi.Pointer<git_stash_save_options> opts,
int version,
);

/// Save the local modifications to a new stash, with options.
/// 
/// @param out Object id of the commit containing the stashed state.
/// This commit is also the target of the direct reference refs/stash.
/// @param repo The owning repository.
/// @param opts The stash options.
/// @return 0 on success, GIT_ENOTFOUND where there's nothing to stash,
/// or error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<git_stash_save_options> )>()
external int git_stash_save_with_opts(ffi.Pointer<git_oid> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_stash_save_options> opts,
);

/// Initialize git_stash_apply_options structure
/// 
/// Initializes a `git_stash_apply_options` with default values. Equivalent to
/// creating an instance with `GIT_STASH_APPLY_OPTIONS_INIT`.
/// 
/// @param opts The `git_stash_apply_options` struct to initialize.
/// @param version The struct version; pass `GIT_STASH_APPLY_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_stash_apply_options> , ffi.UnsignedInt )>()
external int git_stash_apply_options_init(ffi.Pointer<git_stash_apply_options> opts,
int version,
);

/// Apply a single stashed state from the stash list.
/// 
/// If local changes in the working directory conflict with changes in the
/// stash then GIT_EMERGECONFLICT will be returned.  In this case, the index
/// will always remain unmodified and all files in the working directory will
/// remain unmodified.  However, if you are restoring untracked files or
/// ignored files and there is a conflict when applying the modified files,
/// then those files will remain in the working directory.
/// 
/// If passing the GIT_STASH_APPLY_REINSTATE_INDEX flag and there would be
/// conflicts when reinstating the index, the function will return
/// GIT_EMERGECONFLICT and both the working directory and index will be left
/// unmodified.
/// 
/// @param repo The owning repository.
/// @param index The position within the stash list. 0 points to the
/// most recent stashed state.
/// @param options Optional options to control how stashes are applied.
/// 
/// @return 0 on success, GIT_ENOTFOUND if there's no stashed state for the
/// given index, GIT_EMERGECONFLICT if changes exist in the working
/// directory, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Size , ffi.Pointer<git_stash_apply_options> )>()
external int git_stash_apply(ffi.Pointer<git_repository> repo,
int index,
ffi.Pointer<git_stash_apply_options> options,
);

/// Loop over all the stashed states and issue a callback for each one.
/// 
/// If the callback returns a non-zero value, this will stop looping.
/// 
/// @param repo Repository where to find the stash.
/// 
/// @param callback Callback to invoke per found stashed state. The most
/// recent stash state will be enumerated first.
/// 
/// @param payload Extra parameter to callback function.
/// 
/// @return 0 on success, non-zero callback return value, or error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Size index, ffi.Pointer<ffi.Char> message, ffi.Pointer<git_oid> stash_id, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_stash_foreach(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Size index, ffi.Pointer<ffi.Char> message, ffi.Pointer<git_oid> stash_id, ffi.Pointer<ffi.Void> payload)>> callback,
ffi.Pointer<ffi.Void> payload,
);

/// Remove a single stashed state from the stash list.
/// 
/// @param repo The owning repository.
/// 
/// @param index The position within the stash list. 0 points to the
/// most recent stashed state.
/// 
/// @return 0 on success, GIT_ENOTFOUND if there's no stashed state for the given
/// index, or error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Size )>()
external int git_stash_drop(ffi.Pointer<git_repository> repo,
int index,
);

/// Apply a single stashed state from the stash list and remove it from the list
/// if successful.
/// 
/// @param repo The owning repository.
/// @param index The position within the stash list. 0 points to the
/// most recent stashed state.
/// @param options Optional options to control how stashes are applied.
/// 
/// @return 0 on success, GIT_ENOTFOUND if there's no stashed state for the given
/// index, or error code. (see git_stash_apply() above for details)
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Size , ffi.Pointer<git_stash_apply_options> )>()
external int git_stash_pop(ffi.Pointer<git_repository> repo,
int index,
ffi.Pointer<git_stash_apply_options> options,
);

/// Initialize git_status_options structure
/// 
/// Initializes a `git_status_options` with default values. Equivalent to
/// creating an instance with `GIT_STATUS_OPTIONS_INIT`.
/// 
/// @param opts The `git_status_options` struct to initialize.
/// @param version The struct version; pass `GIT_STATUS_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_status_options> , ffi.UnsignedInt )>()
external int git_status_options_init(ffi.Pointer<git_status_options> opts,
int version,
);

/// Gather file statuses and run a callback for each one.
/// 
/// The callback is passed the path of the file, the status (a combination of
/// the `git_status_t` values above) and the `payload` data pointer passed
/// into this function.
/// 
/// If the callback returns a non-zero value, this function will stop looping
/// and return that value to caller.
/// 
/// @param repo A repository object
/// @param callback The function to call on each file
/// @param payload Pointer to pass through to callback function
/// @return 0 on success, non-zero callback return value, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> path, ffi.UnsignedInt status_flags, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_status_foreach(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> path, ffi.UnsignedInt status_flags, ffi.Pointer<ffi.Void> payload)>> callback,
ffi.Pointer<ffi.Void> payload,
);

/// Gather file status information and run callbacks as requested.
/// 
/// This is an extended version of the `git_status_foreach()` API that
/// allows for more granular control over which paths will be processed and
/// in what order.  See the `git_status_options` structure for details
/// about the additional controls that this makes available.
/// 
/// Note that if a `pathspec` is given in the `git_status_options` to filter
/// the status, then the results from rename detection (if you enable it) may
/// not be accurate.  To do rename detection properly, this must be called
/// with no `pathspec` so that all files can be considered.
/// 
/// @param repo Repository object
/// @param opts Status options structure
/// @param callback The function to call on each file
/// @param payload Pointer to pass through to callback function
/// @return 0 on success, non-zero callback return value, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<git_status_options> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> path, ffi.UnsignedInt status_flags, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_status_foreach_ext(ffi.Pointer<git_repository> repo,
ffi.Pointer<git_status_options> opts,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> path, ffi.UnsignedInt status_flags, ffi.Pointer<ffi.Void> payload)>> callback,
ffi.Pointer<ffi.Void> payload,
);

/// Get file status for a single file.
/// 
/// This tries to get status for the filename that you give.  If no files
/// match that name (in either the HEAD, index, or working directory), this
/// returns GIT_ENOTFOUND.
/// 
/// If the name matches multiple files (for example, if the `path` names a
/// directory or if running on a case- insensitive filesystem and yet the
/// HEAD has two entries that both match the path), then this returns
/// GIT_EAMBIGUOUS because it cannot give correct results.
/// 
/// This does not do any sort of rename detection.  Renames require a set of
/// targets and because of the path filtering, there is not enough
/// information to check renames correctly.  To check file status with rename
/// detection, there is no choice but to do a full `git_status_list_new` and
/// scan through looking for the path that you are interested in.
/// 
/// @param status_flags Output combination of git_status_t values for file
/// @param repo A repository object
/// @param path The exact path to retrieve status for relative to the
/// repository working directory
/// @return 0 on success, GIT_ENOTFOUND if the file is not found in the HEAD,
/// index, and work tree, GIT_EAMBIGUOUS if `path` matches multiple files
/// or if it refers to a folder, and -1 on other errors.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.UnsignedInt> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_status_file(ffi.Pointer<ffi.UnsignedInt> status_flags,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> path,
);

/// Gather file status information and populate the `git_status_list`.
/// 
/// Note that if a `pathspec` is given in the `git_status_options` to filter
/// the status, then the results from rename detection (if you enable it) may
/// not be accurate.  To do rename detection properly, this must be called
/// with no `pathspec` so that all files can be considered.
/// 
/// @param out Pointer to store the status results in
/// @param repo Repository object
/// @param opts Status options structure
/// @return 0 on success or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_status_list>> , ffi.Pointer<git_repository> , ffi.Pointer<git_status_options> )>()
external int git_status_list_new(ffi.Pointer<ffi.Pointer<git_status_list>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_status_options> opts,
);

/// Gets the count of status entries in this list.
/// 
/// If there are no changes in status (at least according the options given
/// when the status list was created), this can return 0.
/// 
/// @param statuslist Existing status list object
/// @return the number of status entries
@ffi.Native<ffi.Size Function(ffi.Pointer<git_status_list> )>()
external int git_status_list_entrycount(ffi.Pointer<git_status_list> statuslist,
);

/// Get a pointer to one of the entries in the status list.
/// 
/// The entry is not modifiable and should not be freed.
/// 
/// @param statuslist Existing status list object
/// @param idx Position of the entry
/// @return Pointer to the entry; NULL if out of bounds
@ffi.Native<ffi.Pointer<git_status_entry> Function(ffi.Pointer<git_status_list> , ffi.Size )>()
external ffi.Pointer<git_status_entry> git_status_byindex(ffi.Pointer<git_status_list> statuslist,
int idx,
);

/// Free an existing status list
/// 
/// @param statuslist Existing status list object
@ffi.Native<ffi.Void Function(ffi.Pointer<git_status_list> )>()
external void git_status_list_free(ffi.Pointer<git_status_list> statuslist,
);

/// Test if the ignore rules apply to a given file.
/// 
/// This function checks the ignore rules to see if they would apply to the
/// given file.  This indicates if the file would be ignored regardless of
/// whether the file is already in the index or committed to the repository.
/// 
/// One way to think of this is if you were to do "git add ." on the
/// directory containing the file, would it be added or not?
/// 
/// @param ignored Boolean returning 0 if the file is not ignored, 1 if it is
/// @param repo A repository object
/// @param path The file to check ignores for, rooted at the repo's workdir.
/// @return 0 if ignore rules could be processed for the file (regardless
/// of whether it exists or not), or an error < 0 if they could not.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Int> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_status_should_ignore(ffi.Pointer<ffi.Int> ignored,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> path,
);

/// Initialize git_submodule_update_options structure
/// 
/// Initializes a `git_submodule_update_options` with default values. Equivalent to
/// creating an instance with `GIT_SUBMODULE_UPDATE_OPTIONS_INIT`.
/// 
/// @param opts The `git_submodule_update_options` struct to initialize.
/// @param version The struct version; pass `GIT_SUBMODULE_UPDATE_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_submodule_update_options> , ffi.UnsignedInt )>()
external int git_submodule_update_options_init(ffi.Pointer<git_submodule_update_options> opts,
int version,
);

/// Update a submodule. This will clone a missing submodule and
/// checkout the subrepository to the commit specified in the index of
/// the containing repository. If the submodule repository doesn't contain
/// the target commit (e.g. because fetchRecurseSubmodules isn't set), then
/// the submodule is fetched using the fetch options supplied in options.
/// 
/// @param submodule Submodule object
/// @param init If the submodule is not initialized, setting this flag to true
/// will initialize the submodule before updating. Otherwise, this will
/// return an error if attempting to update an uninitialized repository.
/// but setting this to true forces them to be updated.
/// @param options configuration options for the update.  If NULL, the
/// function works as though GIT_SUBMODULE_UPDATE_OPTIONS_INIT was passed.
/// @return 0 on success, any non-zero return value from a callback
/// function, or a negative value to indicate an error (use
/// `git_error_last` for a detailed error message).
@ffi.Native<ffi.Int Function(ffi.Pointer<git_submodule> , ffi.Int , ffi.Pointer<git_submodule_update_options> )>()
external int git_submodule_update(ffi.Pointer<git_submodule> submodule,
int init,
ffi.Pointer<git_submodule_update_options> options,
);

/// Lookup submodule information by name or path.
/// 
/// Given either the submodule name or path (they are usually the same), this
/// returns a structure describing the submodule.
/// 
/// There are two expected error scenarios:
/// 
/// - The submodule is not mentioned in the HEAD, the index, and the config,
/// but does "exist" in the working directory (i.e. there is a subdirectory
/// that appears to be a Git repository).  In this case, this function
/// returns GIT_EEXISTS to indicate a sub-repository exists but not in a
/// state where a git_submodule can be instantiated.
/// - The submodule is not mentioned in the HEAD, index, or config and the
/// working directory doesn't contain a value git repo at that path.
/// There may or may not be anything else at that path, but nothing that
/// looks like a submodule.  In this case, this returns GIT_ENOTFOUND.
/// 
/// You must call `git_submodule_free` when done with the submodule.
/// 
/// @param out Output ptr to submodule; pass NULL to just get return code
/// @param repo The parent repository
/// @param name The name of or path to the submodule; trailing slashes okay
/// @return 0 on success, GIT_ENOTFOUND if submodule does not exist,
/// GIT_EEXISTS if a repository is found in working directory only,
/// -1 on other errors.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_submodule>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_submodule_lookup(ffi.Pointer<ffi.Pointer<git_submodule>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
);

/// Create an in-memory copy of a submodule. The copy must be explicitly
/// free'd or it will leak.
/// 
/// @param out Pointer to store the copy of the submodule.
/// @param source Original submodule to copy.
/// @return 0
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_submodule>> , ffi.Pointer<git_submodule> )>()
external int git_submodule_dup(ffi.Pointer<ffi.Pointer<git_submodule>> out,
ffi.Pointer<git_submodule> source,
);

/// Release a submodule
/// 
/// @param submodule Submodule object
@ffi.Native<ffi.Void Function(ffi.Pointer<git_submodule> )>()
external void git_submodule_free(ffi.Pointer<git_submodule> submodule,
);

/// Iterate over all tracked submodules of a repository.
/// 
/// See the note on `git_submodule` above.  This iterates over the tracked
/// submodules as described therein.
/// 
/// If you are concerned about items in the working directory that look like
/// submodules but are not tracked, the diff API will generate a diff record
/// for workdir items that look like submodules but are not tracked, showing
/// them as added in the workdir.  Also, the status API will treat the entire
/// subdirectory of a contained git repo as a single GIT_STATUS_WT_NEW item.
/// 
/// @param repo The repository
/// @param callback Function to be called with the name of each submodule.
/// Return a non-zero value to terminate the iteration.
/// @param payload Extra data to pass to callback
/// @return 0 on success, -1 on error, or non-zero return value of callback
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_submodule> sm, ffi.Pointer<ffi.Char> name, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_submodule_foreach(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_submodule> sm, ffi.Pointer<ffi.Char> name, ffi.Pointer<ffi.Void> payload)>> callback,
ffi.Pointer<ffi.Void> payload,
);

/// Set up a new git submodule for checkout.
/// 
/// This does "git submodule add" up to the fetch and checkout of the
/// submodule contents.  It preps a new submodule, creates an entry in
/// .gitmodules and creates an empty initialized repository either at the
/// given path in the working directory or in .git/modules with a gitlink
/// from the working directory to the new repo.
/// 
/// To fully emulate "git submodule add" call this function, then open the
/// submodule repo and perform the clone step as needed (if you don't need
/// anything custom see `git_submodule_add_clone()`). Lastly, call
/// `git_submodule_add_finalize()` to wrap up adding the new submodule and
/// .gitmodules to the index to be ready to commit.
/// 
/// You must call `git_submodule_free` on the submodule object when done.
/// 
/// @param out The newly created submodule ready to open for clone
/// @param repo The repository in which you want to create the submodule
/// @param url URL for the submodule's remote
/// @param path Path at which the submodule should be created
/// @param use_gitlink Should workdir contain a gitlink to the repo in
/// .git/modules vs. repo directly in workdir.
/// @return 0 on success, GIT_EEXISTS if submodule already exists,
/// -1 on other errors.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_submodule>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Int )>()
external int git_submodule_add_setup(ffi.Pointer<ffi.Pointer<git_submodule>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> url,
ffi.Pointer<ffi.Char> path,
int use_gitlink,
);

/// Perform the clone step for a newly created submodule.
/// 
/// This performs the necessary `git_clone` to setup a newly-created submodule.
/// 
/// @param out The newly created repository object. Optional.
/// @param submodule The submodule currently waiting for its clone.
/// @param opts The options to use.
/// 
/// @return 0 on success, -1 on other errors (see git_clone).
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>> , ffi.Pointer<git_submodule> , ffi.Pointer<git_submodule_update_options> )>()
external int git_submodule_clone(ffi.Pointer<ffi.Pointer<git_repository>> out,
ffi.Pointer<git_submodule> submodule,
ffi.Pointer<git_submodule_update_options> opts,
);

/// Resolve the setup of a new git submodule.
/// 
/// This should be called on a submodule once you have called add setup
/// and done the clone of the submodule.  This adds the .gitmodules file
/// and the newly cloned submodule to the index to be ready to be committed
/// (but doesn't actually do the commit).
/// 
/// @param submodule The submodule to finish adding.
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_submodule> )>()
external int git_submodule_add_finalize(ffi.Pointer<git_submodule> submodule,
);

/// Add current submodule HEAD commit to index of superproject.
/// 
/// @param submodule The submodule to add to the index
/// @param write_index Boolean if this should immediately write the index
/// file.  If you pass this as false, you will have to get the
/// git_index and explicitly call `git_index_write()` on it to
/// save the change.
/// @return 0 on success, <0 on failure
@ffi.Native<ffi.Int Function(ffi.Pointer<git_submodule> , ffi.Int )>()
external int git_submodule_add_to_index(ffi.Pointer<git_submodule> submodule,
int write_index,
);

/// Get the containing repository for a submodule.
/// 
/// This returns a pointer to the repository that contains the submodule.
/// This is a just a reference to the repository that was passed to the
/// original `git_submodule_lookup()` call, so if that repository has been
/// freed, then this may be a dangling reference.
/// 
/// @param submodule Pointer to submodule object
/// @return Pointer to `git_repository`
@ffi.Native<ffi.Pointer<git_repository> Function(ffi.Pointer<git_submodule> )>()
external ffi.Pointer<git_repository> git_submodule_owner(ffi.Pointer<git_submodule> submodule,
);

/// Get the name of submodule.
/// 
/// @param submodule Pointer to submodule object
/// @return Pointer to the submodule name
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_submodule> )>()
external ffi.Pointer<ffi.Char> git_submodule_name(ffi.Pointer<git_submodule> submodule,
);

/// Get the path to the submodule.
/// 
/// The path is almost always the same as the submodule name, but the
/// two are actually not required to match.
/// 
/// @param submodule Pointer to submodule object
/// @return Pointer to the submodule path
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_submodule> )>()
external ffi.Pointer<ffi.Char> git_submodule_path(ffi.Pointer<git_submodule> submodule,
);

/// Get the URL for the submodule.
/// 
/// @param submodule Pointer to submodule object
/// @return Pointer to the submodule url
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_submodule> )>()
external ffi.Pointer<ffi.Char> git_submodule_url(ffi.Pointer<git_submodule> submodule,
);

/// Resolve a submodule url relative to the given repository.
/// 
/// @param out buffer to store the absolute submodule url in
/// @param repo Pointer to repository object
/// @param url Relative url
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_submodule_resolve_url(ffi.Pointer<git_buf> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> url,
);

/// Get the branch for the submodule.
/// 
/// @param submodule Pointer to submodule object
/// @return Pointer to the submodule branch
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_submodule> )>()
external ffi.Pointer<ffi.Char> git_submodule_branch(ffi.Pointer<git_submodule> submodule,
);

/// Set the branch for the submodule in the configuration
/// 
/// After calling this, you may wish to call `git_submodule_sync()` to
/// write the changes to the checked out submodule repository.
/// 
/// @param repo the repository to affect
/// @param name the name of the submodule to configure
/// @param branch Branch that should be used for the submodule
/// @return 0 on success, <0 on failure
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_submodule_set_branch(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
ffi.Pointer<ffi.Char> branch,
);

/// Set the URL for the submodule in the configuration
/// 
/// 
/// After calling this, you may wish to call `git_submodule_sync()` to
/// write the changes to the checked out submodule repository.
/// 
/// @param repo the repository to affect
/// @param name the name of the submodule to configure
/// @param url URL that should be used for the submodule
/// @return 0 on success, <0 on failure
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_submodule_set_url(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
ffi.Pointer<ffi.Char> url,
);

/// Get the OID for the submodule in the index.
/// 
/// @param submodule Pointer to submodule object
/// @return Pointer to git_oid or NULL if submodule is not in index.
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_submodule> )>()
external ffi.Pointer<git_oid> git_submodule_index_id(ffi.Pointer<git_submodule> submodule,
);

/// Get the OID for the submodule in the current HEAD tree.
/// 
/// @param submodule Pointer to submodule object
/// @return Pointer to git_oid or NULL if submodule is not in the HEAD.
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_submodule> )>()
external ffi.Pointer<git_oid> git_submodule_head_id(ffi.Pointer<git_submodule> submodule,
);

/// Get the OID for the submodule in the current working directory.
/// 
/// This returns the OID that corresponds to looking up 'HEAD' in the checked
/// out submodule.  If there are pending changes in the index or anything
/// else, this won't notice that.  You should call `git_submodule_status()`
/// for a more complete picture about the state of the working directory.
/// 
/// @param submodule Pointer to submodule object
/// @return Pointer to git_oid or NULL if submodule is not checked out.
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_submodule> )>()
external ffi.Pointer<git_oid> git_submodule_wd_id(ffi.Pointer<git_submodule> submodule,
);

/// Get the ignore rule that will be used for the submodule.
/// 
/// These values control the behavior of `git_submodule_status()` for this
/// submodule.  There are four ignore values:
/// 
/// - **GIT_SUBMODULE_IGNORE_NONE** will consider any change to the contents
/// of the submodule from a clean checkout to be dirty, including the
/// addition of untracked files.  This is the default if unspecified.
/// - **GIT_SUBMODULE_IGNORE_UNTRACKED** examines the contents of the
/// working tree (i.e. call `git_status_foreach()` on the submodule) but
/// UNTRACKED files will not count as making the submodule dirty.
/// - **GIT_SUBMODULE_IGNORE_DIRTY** means to only check if the HEAD of the
/// submodule has moved for status.  This is fast since it does not need to
/// scan the working tree of the submodule at all.
/// - **GIT_SUBMODULE_IGNORE_ALL** means not to open the submodule repo.
/// The working directory will be consider clean so long as there is a
/// checked out version present.
/// 
/// @param submodule The submodule to check
/// @return The current git_submodule_ignore_t valyue what will be used for
/// this submodule.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_submodule> )>(symbol: 'git_submodule_ignore')
external int _git_submodule_ignore(ffi.Pointer<git_submodule> submodule,
);

git_submodule_ignore_t git_submodule_ignore(ffi.Pointer<git_submodule> submodule,
) => git_submodule_ignore_t.fromValue(_git_submodule_ignore(submodule,
));

/// Set the ignore rule for the submodule in the configuration
/// 
/// This does not affect any currently-loaded instances.
/// 
/// @param repo the repository to affect
/// @param name the name of the submdule
/// @param ignore The new value for the ignore rule
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Int )>(symbol: 'git_submodule_set_ignore')
external int _git_submodule_set_ignore(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
int ignore,
);

int git_submodule_set_ignore(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
git_submodule_ignore_t ignore,
) => _git_submodule_set_ignore(repo,
name,
ignore.value,
);

/// Get the update rule that will be used for the submodule.
/// 
/// This value controls the behavior of the `git submodule update` command.
/// There are four useful values documented with `git_submodule_update_t`.
/// 
/// @param submodule The submodule to check
/// @return The current git_submodule_update_t value that will be used
/// for this submodule.
@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<git_submodule> )>(symbol: 'git_submodule_update_strategy')
external int _git_submodule_update_strategy(ffi.Pointer<git_submodule> submodule,
);

git_submodule_update_t git_submodule_update_strategy(ffi.Pointer<git_submodule> submodule,
) => git_submodule_update_t.fromValue(_git_submodule_update_strategy(submodule,
));

/// Set the update rule for the submodule in the configuration
/// 
/// This setting won't affect any existing instances.
/// 
/// @param repo the repository to affect
/// @param name the name of the submodule to configure
/// @param update The new value to use
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.UnsignedInt )>(symbol: 'git_submodule_set_update')
external int _git_submodule_set_update(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
int update,
);

int git_submodule_set_update(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
git_submodule_update_t update,
) => _git_submodule_set_update(repo,
name,
update.value,
);

/// Read the fetchRecurseSubmodules rule for a submodule.
/// 
/// This accesses the submodule.<name>.fetchRecurseSubmodules value for
/// the submodule that controls fetching behavior for the submodule.
/// 
/// Note that at this time, libgit2 does not honor this setting and the
/// fetch functionality current ignores submodules.
/// 
/// @param submodule the submodule to examine
/// @return the submodule recursion configuration
@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<git_submodule> )>(symbol: 'git_submodule_fetch_recurse_submodules')
external int _git_submodule_fetch_recurse_submodules(ffi.Pointer<git_submodule> submodule,
);

git_submodule_recurse_t git_submodule_fetch_recurse_submodules(ffi.Pointer<git_submodule> submodule,
) => git_submodule_recurse_t.fromValue(_git_submodule_fetch_recurse_submodules(submodule,
));

/// Set the fetchRecurseSubmodules rule for a submodule in the configuration
/// 
/// This setting won't affect any existing instances.
/// 
/// @param repo the repository to affect
/// @param name the submodule to configure
/// @param fetch_recurse_submodules the submodule recursion configuration
/// @return old value for fetchRecurseSubmodules
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.UnsignedInt )>(symbol: 'git_submodule_set_fetch_recurse_submodules')
external int _git_submodule_set_fetch_recurse_submodules(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
int fetch_recurse_submodules,
);

int git_submodule_set_fetch_recurse_submodules(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
git_submodule_recurse_t fetch_recurse_submodules,
) => _git_submodule_set_fetch_recurse_submodules(repo,
name,
fetch_recurse_submodules.value,
);

/// Copy submodule info into ".git/config" file.
/// 
/// Just like "git submodule init", this copies information about the
/// submodule into ".git/config".  You can use the accessor functions
/// above to alter the in-memory git_submodule object and control what
/// is written to the config, overriding what is in .gitmodules.
/// 
/// @param submodule The submodule to write into the superproject config
/// @param overwrite By default, existing entries will not be overwritten,
/// but setting this to true forces them to be updated.
/// @return 0 on success, <0 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_submodule> , ffi.Int )>()
external int git_submodule_init(ffi.Pointer<git_submodule> submodule,
int overwrite,
);

/// Set up the subrepository for a submodule in preparation for clone.
/// 
/// This function can be called to init and set up a submodule
/// repository from a submodule in preparation to clone it from
/// its remote.
/// 
/// @param out Output pointer to the created git repository.
/// @param sm The submodule to create a new subrepository from.
/// @param use_gitlink Should the workdir contain a gitlink to
/// the repo in .git/modules vs. repo directly in workdir.
/// @return 0 on success, <0 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>> , ffi.Pointer<git_submodule> , ffi.Int )>()
external int git_submodule_repo_init(ffi.Pointer<ffi.Pointer<git_repository>> out,
ffi.Pointer<git_submodule> sm,
int use_gitlink,
);

/// Copy submodule remote info into submodule repo.
/// 
/// This copies the information about the submodules URL into the checked out
/// submodule config, acting like "git submodule sync".  This is useful if
/// you have altered the URL for the submodule (or it has been altered by a
/// fetch of upstream changes) and you need to update your local repo.
/// 
/// @param submodule The submodule to copy.
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_submodule> )>()
external int git_submodule_sync(ffi.Pointer<git_submodule> submodule,
);

/// Open the repository for a submodule.
/// 
/// This is a newly opened repository object.  The caller is responsible for
/// calling `git_repository_free()` on it when done.  Multiple calls to this
/// function will return distinct `git_repository` objects.  This will only
/// work if the submodule is checked out into the working directory.
/// 
/// @param repo Pointer to the submodule repo which was opened
/// @param submodule Submodule to be opened
/// @return 0 on success, <0 if submodule repo could not be opened.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>> , ffi.Pointer<git_submodule> )>()
external int git_submodule_open(ffi.Pointer<ffi.Pointer<git_repository>> repo,
ffi.Pointer<git_submodule> submodule,
);

/// Reread submodule info from config, index, and HEAD.
/// 
/// Call this to reread cached submodule information for this submodule if
/// you have reason to believe that it has changed.
/// 
/// @param submodule The submodule to reload
/// @param force Force reload even if the data doesn't seem out of date
/// @return 0 on success, <0 on error
@ffi.Native<ffi.Int Function(ffi.Pointer<git_submodule> , ffi.Int )>()
external int git_submodule_reload(ffi.Pointer<git_submodule> submodule,
int force,
);

/// Get the status for a submodule.
/// 
/// This looks at a submodule and tries to determine the status.  It
/// will return a combination of the `GIT_SUBMODULE_STATUS` values above.
/// How deeply it examines the working directory to do this will depend
/// on the `git_submodule_ignore_t` value for the submodule.
/// 
/// @param status Combination of `GIT_SUBMODULE_STATUS` flags
/// @param repo the repository in which to look
/// @param name name of the submodule
/// @param ignore the ignore rules to follow
/// @return 0 on success, <0 on error
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.UnsignedInt> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Int )>(symbol: 'git_submodule_status')
external int _git_submodule_status(ffi.Pointer<ffi.UnsignedInt> status,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
int ignore,
);

int git_submodule_status(ffi.Pointer<ffi.UnsignedInt> status,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
git_submodule_ignore_t ignore,
) => _git_submodule_status(status,
repo,
name,
ignore.value,
);

/// Get the locations of submodule information.
/// 
/// This is a bit like a very lightweight version of `git_submodule_status`.
/// It just returns a made of the first four submodule status values (i.e.
/// the ones like GIT_SUBMODULE_STATUS_IN_HEAD, etc) that tell you where the
/// submodule data comes from (i.e. the HEAD commit, gitmodules file, etc.).
/// This can be useful if you want to know if the submodule is present in the
/// working directory at this point in time, etc.
/// 
/// @param location_status Combination of first four `GIT_SUBMODULE_STATUS` flags
/// @param submodule Submodule for which to get status
/// @return 0 on success, <0 on error
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.UnsignedInt> , ffi.Pointer<git_submodule> )>()
external int git_submodule_location(ffi.Pointer<ffi.UnsignedInt> location_status,
ffi.Pointer<git_submodule> submodule,
);

/// List names of linked working trees
/// 
/// The returned list should be released with `git_strarray_free`
/// when no longer needed.
/// 
/// @param out pointer to the array of working tree names
/// @param repo the repo to use when listing working trees
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_strarray> , ffi.Pointer<git_repository> )>()
external int git_worktree_list(ffi.Pointer<git_strarray> out,
ffi.Pointer<git_repository> repo,
);

/// Lookup a working tree by its name for a given repository
/// 
/// @param out Output pointer to looked up worktree or `NULL`
/// @param repo The repository containing worktrees
/// @param name Name of the working tree to look up
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_worktree>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_worktree_lookup(ffi.Pointer<ffi.Pointer<git_worktree>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
);

/// Open a worktree of a given repository
/// 
/// If a repository is not the main tree but a worktree, this
/// function will look up the worktree inside the parent
/// repository and create a new `git_worktree` structure.
/// 
/// @param out Out-pointer for the newly allocated worktree
/// @param repo Repository to look up worktree for
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_worktree>> , ffi.Pointer<git_repository> )>()
external int git_worktree_open_from_repository(ffi.Pointer<ffi.Pointer<git_worktree>> out,
ffi.Pointer<git_repository> repo,
);

/// Free a previously allocated worktree
/// 
/// @param wt worktree handle to close. If NULL nothing occurs.
@ffi.Native<ffi.Void Function(ffi.Pointer<git_worktree> )>()
external void git_worktree_free(ffi.Pointer<git_worktree> wt,
);

/// Check if worktree is valid
/// 
/// A valid worktree requires both the git data structures inside
/// the linked parent repository and the linked working copy to be
/// present.
/// 
/// @param wt Worktree to check
/// @return 0 when worktree is valid, error-code otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_worktree> )>()
external int git_worktree_validate(ffi.Pointer<git_worktree> wt,
);

/// Initialize git_worktree_add_options structure
/// 
/// Initializes a `git_worktree_add_options` with default values. Equivalent to
/// creating an instance with `GIT_WORKTREE_ADD_OPTIONS_INIT`.
/// 
/// @param opts The `git_worktree_add_options` struct to initialize.
/// @param version The struct version; pass `GIT_WORKTREE_ADD_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_worktree_add_options> , ffi.UnsignedInt )>()
external int git_worktree_add_options_init(ffi.Pointer<git_worktree_add_options> opts,
int version,
);

/// Add a new working tree
/// 
/// Add a new working tree for the repository, that is create the
/// required data structures inside the repository and check out
/// the current HEAD at `path`
/// 
/// @param out Output pointer containing new working tree
/// @param repo Repository to create working tree for
/// @param name Name of the working tree
/// @param path Path to create working tree at
/// @param opts Options to modify default behavior. May be NULL
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_worktree>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_worktree_add_options> )>()
external int git_worktree_add(ffi.Pointer<ffi.Pointer<git_worktree>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
ffi.Pointer<ffi.Char> path,
ffi.Pointer<git_worktree_add_options> opts,
);

/// Lock worktree if not already locked
/// 
/// Lock a worktree, optionally specifying a reason why the linked
/// working tree is being locked.
/// 
/// @param wt Worktree to lock
/// @param reason Reason why the working tree is being locked
/// @return 0 on success, non-zero otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_worktree> , ffi.Pointer<ffi.Char> )>()
external int git_worktree_lock(ffi.Pointer<git_worktree> wt,
ffi.Pointer<ffi.Char> reason,
);

/// Unlock a locked worktree
/// 
/// @param wt Worktree to unlock
/// @return 0 on success, 1 if worktree was not locked, error-code
/// otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_worktree> )>()
external int git_worktree_unlock(ffi.Pointer<git_worktree> wt,
);

/// Check if worktree is locked
/// 
/// A worktree may be locked if the linked working tree is stored
/// on a portable device which is not available.
/// 
/// @param reason Buffer to store reason in. If NULL no reason is stored.
/// @param wt Worktree to check
/// @return 0 when the working tree not locked, a value greater
/// than zero if it is locked, less than zero if there was an
/// error
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_worktree> )>()
external int git_worktree_is_locked(ffi.Pointer<git_buf> reason,
ffi.Pointer<git_worktree> wt,
);

/// Retrieve the name of the worktree
/// 
/// @param wt Worktree to get the name for
/// @return The worktree's name. The pointer returned is valid for the
/// lifetime of the git_worktree
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_worktree> )>()
external ffi.Pointer<ffi.Char> git_worktree_name(ffi.Pointer<git_worktree> wt,
);

/// Retrieve the filesystem path for the worktree
/// 
/// @param wt Worktree to get the path for
/// @return The worktree's filesystem path. The pointer returned
/// is valid for the lifetime of the git_worktree.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_worktree> )>()
external ffi.Pointer<ffi.Char> git_worktree_path(ffi.Pointer<git_worktree> wt,
);

/// Initialize git_worktree_prune_options structure
/// 
/// Initializes a `git_worktree_prune_options` with default values. Equivalent to
/// creating an instance with `GIT_WORKTREE_PRUNE_OPTIONS_INIT`.
/// 
/// @param opts The `git_worktree_prune_options` struct to initialize.
/// @param version The struct version; pass `GIT_WORKTREE_PRUNE_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_worktree_prune_options> , ffi.UnsignedInt )>()
external int git_worktree_prune_options_init(ffi.Pointer<git_worktree_prune_options> opts,
int version,
);

/// Is the worktree prunable with the given options?
/// 
/// A worktree is not prunable in the following scenarios:
/// 
/// - the worktree is linking to a valid on-disk worktree. The
/// `valid` member will cause this check to be ignored.
/// - the worktree is locked. The `locked` flag will cause this
/// check to be ignored.
/// 
/// If the worktree is not valid and not locked or if the above
/// flags have been passed in, this function will return a
/// positive value. If the worktree is not prunable, an error
/// message will be set (visible in `giterr_last`) with details about
/// why.
/// 
/// @param wt Worktree to check.
/// @param opts The prunable options.
/// @return 1 if the worktree is prunable, 0 otherwise, or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_worktree> , ffi.Pointer<git_worktree_prune_options> )>()
external int git_worktree_is_prunable(ffi.Pointer<git_worktree> wt,
ffi.Pointer<git_worktree_prune_options> opts,
);

/// Prune working tree
/// 
/// Prune the working tree, that is remove the git data
/// structures on disk. The repository will only be pruned of
/// `git_worktree_is_prunable` succeeds.
/// 
/// @param wt Worktree to prune
/// @param opts Specifies which checks to override. See
/// `git_worktree_is_prunable`. May be NULL
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_worktree> , ffi.Pointer<git_worktree_prune_options> )>()
external int git_worktree_prune(ffi.Pointer<git_worktree> wt,
ffi.Pointer<git_worktree_prune_options> opts,
);

/// Stock callback usable as a git_credential_acquire_cb.  This calls
/// git_cred_userpass_plaintext_new unless the protocol has not specified
/// `GIT_CREDENTIAL_USERPASS_PLAINTEXT` as an allowed type.
/// 
/// @param out The newly created credential object.
/// @param url The resource for which we are demanding a credential.
/// @param user_from_url The username that was embedded in a "user\@host"
/// remote url, or NULL if not included.
/// @param allowed_types A bitmask stating which credential types are OK to return.
/// @param payload The payload provided when specifying this callback.  (This is
/// interpreted as a `git_credential_userpass_payload*`.)
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.UnsignedInt , ffi.Pointer<ffi.Void> )>()
external int git_credential_userpass(ffi.Pointer<ffi.Pointer<git_credential>> out,
ffi.Pointer<ffi.Char> url,
ffi.Pointer<ffi.Char> user_from_url,
int allowed_types,
ffi.Pointer<ffi.Void> payload,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_blob_create_fromworkdir(ffi.Pointer<git_oid> id,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> relative_path,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_blob_create_fromdisk(ffi.Pointer<git_oid> id,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> path,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_writestream>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_blob_create_fromstream(ffi.Pointer<ffi.Pointer<git_writestream>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> hintpath,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_writestream> )>()
external int git_blob_create_fromstream_commit(ffi.Pointer<git_oid> out,
ffi.Pointer<git_writestream> stream,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Void> , ffi.Size )>()
external int git_blob_create_frombuffer(ffi.Pointer<git_oid> id,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Void> buffer,
int len,
);

/// Deprecated in favor of `git_blob_filter`.
/// 
/// @deprecated Use git_blob_filter
/// @see git_blob_filter
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_blob> , ffi.Pointer<ffi.Char> , ffi.Int )>()
external int git_blob_filtered_content(ffi.Pointer<git_buf> out,
ffi.Pointer<git_blob> blob,
ffi.Pointer<ffi.Char> as_path,
int check_for_binary_data,
);

/// Deprecated in favor of `git_filter_list_stream_buffer`.
/// 
/// @deprecated Use git_filter_list_stream_buffer
/// @see Use git_filter_list_stream_buffer
@ffi.Native<ffi.Int Function(ffi.Pointer<git_filter_list> , ffi.Pointer<git_buf> , ffi.Pointer<git_writestream> )>()
external int git_filter_list_stream_data(ffi.Pointer<git_filter_list> filters,
ffi.Pointer<git_buf> data,
ffi.Pointer<git_writestream> target,
);

/// Deprecated in favor of `git_filter_list_apply_to_buffer`.
/// 
/// @deprecated Use git_filter_list_apply_to_buffer
/// @see Use git_filter_list_apply_to_buffer
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_filter_list> , ffi.Pointer<git_buf> )>()
external int git_filter_list_apply_to_data(ffi.Pointer<git_buf> out,
ffi.Pointer<git_filter_list> filters,
ffi.Pointer<git_buf> in$,
);

/// Write the contents of the tree builder as a tree object.
/// This is an alias of `git_treebuilder_write` and is preserved
/// for backward compatibility.
/// 
/// This function is deprecated, but there is no plan to remove this
/// function at this time.
/// 
/// @deprecated Use git_treebuilder_write
/// @see git_treebuilder_write
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_treebuilder> , ffi.Pointer<git_buf> )>()
external int git_treebuilder_write_with_buffer(ffi.Pointer<git_oid> oid,
ffi.Pointer<git_treebuilder> bld,
ffi.Pointer<git_buf> tree,
);

/// Resize the buffer allocation to make more space.
/// 
/// This will attempt to grow the buffer to accommodate the target size.
/// 
/// If the buffer refers to memory that was not allocated by libgit2 (i.e.
/// the `asize` field is zero), then `ptr` will be replaced with a newly
/// allocated block of data.  Be careful so that memory allocated by the
/// caller is not lost.  As a special variant, if you pass `target_size` as
/// 0 and the memory is not allocated by libgit2, this will allocate a new
/// buffer of size `size` and copy the external data into it.
/// 
/// Currently, this will never shrink a buffer, only expand it.
/// 
/// If the allocation fails, this will return an error and the buffer will be
/// marked as invalid for future operations, invaliding the contents.
/// 
/// @param buffer The buffer to be resized; may or may not be allocated yet
/// @param target_size The desired available size
/// @return 0 on success, -1 on allocation failure
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Size )>()
external int git_buf_grow(ffi.Pointer<git_buf> buffer,
int target_size,
);

/// Set buffer to a copy of some raw data.
/// 
/// @param buffer The buffer to set
/// @param data The data to copy into the buffer
/// @param datalen The length of the data to copy into the buffer
/// @return 0 on success, -1 on allocation failure
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<ffi.Void> , ffi.Size )>()
external int git_buf_set(ffi.Pointer<git_buf> buffer,
ffi.Pointer<ffi.Void> data,
int datalen,
);

/// Check quickly if buffer looks like it contains binary data
/// 
/// @param buf Buffer to check
/// @return 1 if buffer looks like non-text data
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> )>()
external int git_buf_is_binary(ffi.Pointer<git_buf> buf,
);

/// Check quickly if buffer contains a NUL byte
/// 
/// @param buf Buffer to check
/// @return 1 if buffer contains a NUL byte
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> )>()
external int git_buf_contains_nul(ffi.Pointer<git_buf> buf,
);

/// Free the memory referred to by the git_buf.  This is an alias of
/// `git_buf_dispose` and is preserved for backward compatibility.
/// 
/// This function is deprecated, but there is no plan to remove this
/// function at this time.
/// 
/// @deprecated Use git_buf_dispose
/// @see git_buf_dispose
@ffi.Native<ffi.Void Function(ffi.Pointer<git_buf> )>()
external void git_buf_free(ffi.Pointer<git_buf> buffer,
);

/// Create an e-mail ready patch from a diff.
/// 
/// @deprecated git_email_create_from_diff
/// @see git_email_create_from_diff
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_diff> , ffi.Pointer<git_diff_format_email_options> )>()
external int git_diff_format_email(ffi.Pointer<git_buf> out,
ffi.Pointer<git_diff> diff,
ffi.Pointer<git_diff_format_email_options> opts,
);

/// Create an e-mail ready patch for a commit.
/// 
/// @deprecated git_email_create_from_commit
/// @see git_email_create_from_commit
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_repository> , ffi.Pointer<git_commit> , ffi.Size , ffi.Size , ffi.Uint32 , ffi.Pointer<git_diff_options> )>()
external int git_diff_commit_as_email(ffi.Pointer<git_buf> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_commit> commit,
int patch_no,
int total_patches,
int flags,
ffi.Pointer<git_diff_options> diff_opts,
);

/// Initialize git_diff_format_email_options structure
/// 
/// Initializes a `git_diff_format_email_options` with default values. Equivalent
/// to creating an instance with GIT_DIFF_FORMAT_EMAIL_OPTIONS_INIT.
/// 
/// @param opts The `git_blame_options` struct to initialize.
/// @param version The struct version; pass `GIT_DIFF_FORMAT_EMAIL_OPTIONS_VERSION`.
/// @return Zero on success; -1 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_diff_format_email_options> , ffi.UnsignedInt )>()
external int git_diff_format_email_options_init(ffi.Pointer<git_diff_format_email_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_index> , ffi.Pointer<git_index_entry> , ffi.Pointer<ffi.Void> , ffi.Size )>()
external int git_index_add_frombuffer(ffi.Pointer<git_index> index,
ffi.Pointer<git_index_entry> entry,
ffi.Pointer<ffi.Void> buffer,
int len,
);

/// Get the size in bytes for the structure which
/// acts as an in-memory representation of any given
/// object type.
/// 
/// For all the core types, this would the equivalent
/// of calling `sizeof(git_commit)` if the core types
/// were not opaque on the external API.
/// 
/// @param type object type to get its size
/// @return size in bytes of the object
@ffi.Native<ffi.Size Function(ffi.Int )>(symbol: 'git_object__size')
external int _git_object__size(int type,
);

int git_object__size(git_object_t type,
) => _git_object__size(type.value,
);

/// Ensure the remote name is well-formed.
/// 
/// @deprecated Use git_remote_name_is_valid
/// @param remote_name name to be checked.
/// @return 1 if the reference name is acceptable; 0 if it isn't
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char> )>()
external int git_remote_is_valid_name(ffi.Pointer<ffi.Char> remote_name,
);

/// Ensure the reference name is well-formed.
/// 
/// Valid reference names must follow one of two patterns:
/// 
/// 1. Top-level names must contain only capital letters and underscores,
/// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
/// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
/// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
/// sequences ".." and "@{" which have special meaning to revparse.
/// 
/// @deprecated Use git_reference_name_is_valid
/// @param refname name to be checked.
/// @return 1 if the reference name is acceptable; 0 if it isn't
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char> )>()
external int git_reference_is_valid_name(ffi.Pointer<ffi.Char> refname,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Int )>()
external int git_tag_create_frombuffer(ffi.Pointer<git_oid> oid,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> buffer,
int force,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<git_credential> )>()
external void git_cred_free(ffi.Pointer<git_credential> cred,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_credential> )>()
external int git_cred_has_username(ffi.Pointer<git_credential> cred,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_credential> )>()
external ffi.Pointer<ffi.Char> git_cred_get_username(ffi.Pointer<git_credential> cred,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_cred_userpass_plaintext_new(ffi.Pointer<ffi.Pointer<git_credential>> out,
ffi.Pointer<ffi.Char> username,
ffi.Pointer<ffi.Char> password,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>> )>()
external int git_cred_default_new(ffi.Pointer<ffi.Pointer<git_credential>> out,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>> , ffi.Pointer<ffi.Char> )>()
external int git_cred_username_new(ffi.Pointer<ffi.Pointer<git_credential>> out,
ffi.Pointer<ffi.Char> username,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_cred_ssh_key_new(ffi.Pointer<ffi.Pointer<git_credential>> out,
ffi.Pointer<ffi.Char> username,
ffi.Pointer<ffi.Char> publickey,
ffi.Pointer<ffi.Char> privatekey,
ffi.Pointer<ffi.Char> passphrase,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_cred_ssh_key_memory_new(ffi.Pointer<ffi.Pointer<git_credential>> out,
ffi.Pointer<ffi.Char> username,
ffi.Pointer<ffi.Char> publickey,
ffi.Pointer<ffi.Char> privatekey,
ffi.Pointer<ffi.Char> passphrase,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char> name, ffi.Int name_len, ffi.Pointer<ffi.Char> instruction, ffi.Int instruction_len, ffi.Int num_prompts, ffi.Pointer<_LIBSSH2_USERAUTH_KBDINT_PROMPT> prompts, ffi.Pointer<_LIBSSH2_USERAUTH_KBDINT_RESPONSE> responses, ffi.Pointer<ffi.Pointer<ffi.Void>> abstract)>> , ffi.Pointer<ffi.Void> )>()
external int git_cred_ssh_interactive_new(ffi.Pointer<ffi.Pointer<git_credential>> out,
ffi.Pointer<ffi.Char> username,
ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char> name, ffi.Int name_len, ffi.Pointer<ffi.Char> instruction, ffi.Int instruction_len, ffi.Int num_prompts, ffi.Pointer<_LIBSSH2_USERAUTH_KBDINT_PROMPT> prompts, ffi.Pointer<_LIBSSH2_USERAUTH_KBDINT_RESPONSE> responses, ffi.Pointer<ffi.Pointer<ffi.Void>> abstract)>> prompt_callback,
ffi.Pointer<ffi.Void> payload,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>> , ffi.Pointer<ffi.Char> )>()
external int git_cred_ssh_key_from_agent(ffi.Pointer<ffi.Pointer<git_credential>> out,
ffi.Pointer<ffi.Char> username,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Size , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<_LIBSSH2_SESSION> session, ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> sig, ffi.Pointer<ffi.Size> sig_len, ffi.Pointer<ffi.UnsignedChar> data, ffi.Size data_len, ffi.Pointer<ffi.Pointer<ffi.Void>> abstract)>> , ffi.Pointer<ffi.Void> )>()
external int git_cred_ssh_custom_new(ffi.Pointer<ffi.Pointer<git_credential>> out,
ffi.Pointer<ffi.Char> username,
ffi.Pointer<ffi.Char> publickey,
int publickey_len,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<_LIBSSH2_SESSION> session, ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> sig, ffi.Pointer<ffi.Size> sig_len, ffi.Pointer<ffi.UnsignedChar> data, ffi.Size data_len, ffi.Pointer<ffi.Pointer<ffi.Void>> abstract)>> sign_callback,
ffi.Pointer<ffi.Void> payload,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.UnsignedInt , ffi.Pointer<ffi.Void> )>()
external int git_cred_userpass(ffi.Pointer<ffi.Pointer<git_credential>> out,
ffi.Pointer<ffi.Char> url,
ffi.Pointer<ffi.Char> user_from_url,
int allowed_types,
ffi.Pointer<ffi.Void> payload,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> )>()
external int git_oid_iszero(ffi.Pointer<git_oid> id,
);

/// Free the memory referred to by the git_oidarray.  This is an alias of
/// `git_oidarray_dispose` and is preserved for backward compatibility.
/// 
/// This function is deprecated, but there is no plan to remove this
/// function at this time.
/// 
/// @deprecated Use git_oidarray_dispose
/// @see git_oidarray_dispose
@ffi.Native<ffi.Void Function(ffi.Pointer<git_oidarray> )>()
external void git_oidarray_free(ffi.Pointer<git_oidarray> array,
);

/// Copy a string array object from source to target.
/// 
/// This function is deprecated, but there is no plan to remove this
/// function at this time.
/// 
/// @param tgt target
/// @param src source
/// @return 0 on success, < 0 on allocation failure
@ffi.Native<ffi.Int Function(ffi.Pointer<git_strarray> , ffi.Pointer<git_strarray> )>()
external int git_strarray_copy(ffi.Pointer<git_strarray> tgt,
ffi.Pointer<git_strarray> src,
);

/// Free the memory referred to by the git_strarray.  This is an alias of
/// `git_strarray_dispose` and is preserved for backward compatibility.
/// 
/// This function is deprecated, but there is no plan to remove this
/// function at this time.
/// 
/// @deprecated Use git_strarray_dispose
/// @see git_strarray_dispose
@ffi.Native<ffi.Void Function(ffi.Pointer<git_strarray> )>()
external void git_strarray_free(ffi.Pointer<git_strarray> array,
);

/// @name Deprecated Options Initialization Functions
/// 
/// These functions are retained for backward compatibility.  The newer
/// versions of these functions should be preferred in all new code.
/// 
/// There is no plan to remove these backward compatibility functions at
/// this time.
/// /
/// /**@{
@ffi.Native<ffi.Int Function(ffi.Pointer<git_blame_options> , ffi.UnsignedInt )>()
external int git_blame_init_options(ffi.Pointer<git_blame_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_checkout_options> , ffi.UnsignedInt )>()
external int git_checkout_init_options(ffi.Pointer<git_checkout_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_cherrypick_options> , ffi.UnsignedInt )>()
external int git_cherrypick_init_options(ffi.Pointer<git_cherrypick_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_clone_options> , ffi.UnsignedInt )>()
external int git_clone_init_options(ffi.Pointer<git_clone_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_describe_options> , ffi.UnsignedInt )>()
external int git_describe_init_options(ffi.Pointer<git_describe_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_describe_format_options> , ffi.UnsignedInt )>()
external int git_describe_init_format_options(ffi.Pointer<git_describe_format_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_diff_options> , ffi.UnsignedInt )>()
external int git_diff_init_options(ffi.Pointer<git_diff_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_diff_find_options> , ffi.UnsignedInt )>()
external int git_diff_find_init_options(ffi.Pointer<git_diff_find_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_diff_format_email_options> , ffi.UnsignedInt )>()
external int git_diff_format_email_init_options(ffi.Pointer<git_diff_format_email_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_diff_patchid_options> , ffi.UnsignedInt )>()
external int git_diff_patchid_init_options(ffi.Pointer<git_diff_patchid_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_fetch_options> , ffi.UnsignedInt )>()
external int git_fetch_init_options(ffi.Pointer<git_fetch_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_indexer_options> , ffi.UnsignedInt )>()
external int git_indexer_init_options(ffi.Pointer<git_indexer_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_merge_options> , ffi.UnsignedInt )>()
external int git_merge_init_options(ffi.Pointer<git_merge_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_merge_file_input> , ffi.UnsignedInt )>()
external int git_merge_file_init_input(ffi.Pointer<git_merge_file_input> input,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_merge_file_options> , ffi.UnsignedInt )>()
external int git_merge_file_init_options(ffi.Pointer<git_merge_file_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_proxy_options> , ffi.UnsignedInt )>()
external int git_proxy_init_options(ffi.Pointer<git_proxy_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_push_options> , ffi.UnsignedInt )>()
external int git_push_init_options(ffi.Pointer<git_push_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_rebase_options> , ffi.UnsignedInt )>()
external int git_rebase_init_options(ffi.Pointer<git_rebase_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_remote_create_options> , ffi.UnsignedInt )>()
external int git_remote_create_init_options(ffi.Pointer<git_remote_create_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository_init_options> , ffi.UnsignedInt )>()
external int git_repository_init_init_options(ffi.Pointer<git_repository_init_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_revert_options> , ffi.UnsignedInt )>()
external int git_revert_init_options(ffi.Pointer<git_revert_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_stash_apply_options> , ffi.UnsignedInt )>()
external int git_stash_apply_init_options(ffi.Pointer<git_stash_apply_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_status_options> , ffi.UnsignedInt )>()
external int git_status_init_options(ffi.Pointer<git_status_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_submodule_update_options> , ffi.UnsignedInt )>()
external int git_submodule_update_init_options(ffi.Pointer<git_submodule_update_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_worktree_add_options> , ffi.UnsignedInt )>()
external int git_worktree_add_init_options(ffi.Pointer<git_worktree_add_options> opts,
int version,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<git_worktree_prune_options> , ffi.UnsignedInt )>()
external int git_worktree_prune_init_options(ffi.Pointer<git_worktree_prune_options> opts,
int version,
);

/// Create a diff for a commit in mbox format for sending via email.
/// The commit must not be a merge commit.
/// 
/// @param out buffer to store the e-mail patch in
/// @param commit commit to create a patch for
/// @param opts email creation options
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_commit> , ffi.Pointer<git_email_create_options> )>()
external int git_email_create_from_commit(ffi.Pointer<git_buf> out,
ffi.Pointer<git_commit> commit,
ffi.Pointer<git_email_create_options> opts,
);

/// Init the global state
/// 
/// This function must be called before any other libgit2 function in
/// order to set up global state and threading.
/// 
/// This function may be called multiple times - it will return the number
/// of times the initialization has been called (including this one) that have
/// not subsequently been shutdown.
/// 
/// @return the number of initializations of the library, or an error code.
@ffi.Native<ffi.Int Function()>()
external int git_libgit2_init();

/// Shutdown the global state
/// 
/// Clean up the global state and threading context after calling it as
/// many times as `git_libgit2_init()` was called - it will return the
/// number of remainining initializations that have not been shutdown
/// (after this one).
/// 
/// @return the number of remaining initializations of the library, or an
/// error code.
@ffi.Native<ffi.Int Function()>()
external int git_libgit2_shutdown();

/// Count the number of unique commits between two commit objects
/// 
/// There is no need for branches containing the commits to have any
/// upstream relationship, but it helps to think of one as a branch and
/// the other as its upstream, the `ahead` and `behind` values will be
/// what git would report for the branches.
/// 
/// @param ahead number of unique from commits in `upstream`
/// @param behind number of unique from commits in `local`
/// @param repo the repository where the commits exist
/// @param local the commit for local
/// @param upstream the commit for upstream
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Size> , ffi.Pointer<ffi.Size> , ffi.Pointer<git_repository> , ffi.Pointer<git_oid> , ffi.Pointer<git_oid> )>()
external int git_graph_ahead_behind(ffi.Pointer<ffi.Size> ahead,
ffi.Pointer<ffi.Size> behind,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_oid> local,
ffi.Pointer<git_oid> upstream,
);

/// Determine if a commit is the descendant of another commit.
/// 
/// Note that a commit is not considered a descendant of itself, in contrast
/// to `git merge-base --is-ancestor`.
/// 
/// @param repo the repository where the commits exist
/// @param commit a previously loaded commit
/// @param ancestor a potential ancestor commit
/// @return 1 if the given commit is a descendant of the potential ancestor,
/// 0 if not, error code otherwise.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<git_oid> , ffi.Pointer<git_oid> )>()
external int git_graph_descendant_of(ffi.Pointer<git_repository> repo,
ffi.Pointer<git_oid> commit,
ffi.Pointer<git_oid> ancestor,
);

/// Determine if a commit is reachable from any of a list of commits by
/// following parent edges.
/// 
/// @param repo the repository where the commits exist
/// @param commit a previously loaded commit
/// @param descendant_array oids of the commits
/// @param length the number of commits in the provided `descendant_array`
/// @return 1 if the given commit is an ancestor of any of the given potential
/// descendants, 0 if not, error code otherwise.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<git_oid> , ffi.Pointer<git_oid> , ffi.Size )>()
external int git_graph_reachable_from_any(ffi.Pointer<git_repository> repo,
ffi.Pointer<git_oid> commit,
ffi.Pointer<git_oid> descendant_array,
int length,
);

/// Add ignore rules for a repository.
/// 
/// Excludesfile rules (i.e. .gitignore rules) are generally read from
/// .gitignore files in the repository tree or from a shared system file
/// only if a "core.excludesfile" config value is set.  The library also
/// keeps a set of per-repository internal ignores that can be configured
/// in-memory and will not persist.  This function allows you to add to
/// that internal rules list.
/// 
/// Example usage:
/// 
/// error = git_ignore_add_rule(myrepo, "*.c\ndir/\nFile with space\n");
/// 
/// This would add three rules to the ignores.
/// 
/// @param repo The repository to add ignore rules to.
/// @param rules Text of rules, the contents to add on a .gitignore file.
/// It is okay to have multiple rules in the text; if so,
/// each rule should be terminated with a newline.
/// @return 0 on success
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_ignore_add_rule(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> rules,
);

/// Clear ignore rules that were explicitly added.
/// 
/// Resets to the default internal ignore rules.  This will not turn off
/// rules in .gitignore files that actually exist in the filesystem.
/// 
/// The default internal ignores ignore ".", ".." and ".git" entries.
/// 
/// @param repo The repository to remove ignore rules from.
/// @return 0 on success
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> )>()
external int git_ignore_clear_internal_rules(ffi.Pointer<git_repository> repo,
);

/// Test if the ignore rules apply to a given path.
/// 
/// This function checks the ignore rules to see if they would apply to the
/// given file.  This indicates if the file would be ignored regardless of
/// whether the file is already in the index or committed to the repository.
/// 
/// One way to think of this is if you were to do "git check-ignore --no-index"
/// on the given file, would it be shown or not?
/// 
/// @param ignored boolean returning 0 if the file is not ignored, 1 if it is
/// @param repo a repository object
/// @param path the file to check ignores for, relative to the repo's workdir.
/// @return 0 if ignore rules could be processed for the file (regardless
/// of whether it exists or not), or an error < 0 if they could not.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Int> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_ignore_path_is_ignored(ffi.Pointer<ffi.Int> ignored,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> path,
);

/// Allocate a new mailmap object.
/// 
/// This object is empty, so you'll have to add a mailmap file before you can do
/// anything with it. The mailmap must be freed with 'git_mailmap_free'.
/// 
/// @param out pointer to store the new mailmap
/// @return 0 on success, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_mailmap>> )>()
external int git_mailmap_new(ffi.Pointer<ffi.Pointer<git_mailmap>> out,
);

/// Free the mailmap and its associated memory.
/// 
/// @param mm the mailmap to free
@ffi.Native<ffi.Void Function(ffi.Pointer<git_mailmap> )>()
external void git_mailmap_free(ffi.Pointer<git_mailmap> mm,
);

/// Add a single entry to the given mailmap object. If the entry already exists,
/// it will be replaced with the new entry.
/// 
/// @param mm mailmap to add the entry to
/// @param real_name the real name to use, or NULL
/// @param real_email the real email to use, or NULL
/// @param replace_name the name to replace, or NULL
/// @param replace_email the email to replace
/// @return 0 on success, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_mailmap> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_mailmap_add_entry(ffi.Pointer<git_mailmap> mm,
ffi.Pointer<ffi.Char> real_name,
ffi.Pointer<ffi.Char> real_email,
ffi.Pointer<ffi.Char> replace_name,
ffi.Pointer<ffi.Char> replace_email,
);

/// Create a new mailmap instance containing a single mailmap file
/// 
/// @param out pointer to store the new mailmap
/// @param buf buffer to parse the mailmap from
/// @param len the length of the input buffer
/// @return 0 on success, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_mailmap>> , ffi.Pointer<ffi.Char> , ffi.Size )>()
external int git_mailmap_from_buffer(ffi.Pointer<ffi.Pointer<git_mailmap>> out,
ffi.Pointer<ffi.Char> buf,
int len,
);

/// Create a new mailmap instance from a repository, loading mailmap files based
/// on the repository's configuration.
/// 
/// Mailmaps are loaded in the following order:
/// 1. '.mailmap' in the root of the repository's working directory, if present.
/// 2. The blob object identified by the 'mailmap.blob' config entry, if set.
/// [NOTE: 'mailmap.blob' defaults to 'HEAD:.mailmap' in bare repositories]
/// 3. The path in the 'mailmap.file' config entry, if set.
/// 
/// @param out pointer to store the new mailmap
/// @param repo repository to load mailmap information from
/// @return 0 on success, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_mailmap>> , ffi.Pointer<git_repository> )>()
external int git_mailmap_from_repository(ffi.Pointer<ffi.Pointer<git_mailmap>> out,
ffi.Pointer<git_repository> repo,
);

/// Resolve a name and email to the corresponding real name and email.
/// 
/// The lifetime of the strings are tied to `mm`, `name`, and `email` parameters.
/// 
/// @param real_name pointer to store the real name
/// @param real_email pointer to store the real email
/// @param mm the mailmap to perform a lookup with (may be NULL)
/// @param name the name to look up
/// @param email the email to look up
/// @return 0 on success, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>> , ffi.Pointer<ffi.Pointer<ffi.Char>> , ffi.Pointer<git_mailmap> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_mailmap_resolve(ffi.Pointer<ffi.Pointer<ffi.Char>> real_name,
ffi.Pointer<ffi.Pointer<ffi.Char>> real_email,
ffi.Pointer<git_mailmap> mm,
ffi.Pointer<ffi.Char> name,
ffi.Pointer<ffi.Char> email,
);

/// Resolve a signature to use real names and emails with a mailmap.
/// 
/// Call `git_signature_free()` to free the data.
/// 
/// @param out new signature
/// @param mm mailmap to resolve with
/// @param sig signature to resolve
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_signature>> , ffi.Pointer<git_mailmap> , ffi.Pointer<git_signature> )>()
external int git_mailmap_resolve_signature(ffi.Pointer<ffi.Pointer<git_signature>> out,
ffi.Pointer<git_mailmap> mm,
ffi.Pointer<git_signature> sig,
);

/// Clean up excess whitespace and make sure there is a trailing newline in the message.
/// 
/// Optionally, it can remove lines which start with the comment character.
/// 
/// @param out The user-allocated git_buf which will be filled with the
/// cleaned up message.
/// 
/// @param message The message to be prettified.
/// 
/// @param strip_comments Non-zero to remove comment lines, 0 to leave them in.
/// 
/// @param comment_char Comment character. Lines starting with this character
/// are considered to be comments and removed if `strip_comments` is non-zero.
/// 
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<ffi.Char> , ffi.Int , ffi.Char )>()
external int git_message_prettify(ffi.Pointer<git_buf> out,
ffi.Pointer<ffi.Char> message,
int strip_comments,
int comment_char,
);

/// Parse trailers out of a message, filling the array pointed to by +arr+.
/// 
/// Trailers are key/value pairs in the last paragraph of a message, not
/// including any patches or conflicts that may be present.
/// 
/// @param arr A pre-allocated git_message_trailer_array struct to be filled in
/// with any trailers found during parsing.
/// @param message The message to be parsed
/// @return 0 on success, or non-zero on error.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_message_trailer_array> , ffi.Pointer<ffi.Char> )>()
external int git_message_trailers(ffi.Pointer<git_message_trailer_array> arr,
ffi.Pointer<ffi.Char> message,
);

/// Clean's up any allocated memory in the git_message_trailer_array filled by
/// a call to git_message_trailers.
/// 
/// @param arr The trailer to free.
@ffi.Native<ffi.Void Function(ffi.Pointer<git_message_trailer_array> )>()
external void git_message_trailer_array_free(ffi.Pointer<git_message_trailer_array> arr,
);

/// Creates a new iterator for notes
/// 
/// The iterator must be freed manually by the user.
/// 
/// @param out pointer to the iterator
/// @param repo repository where to look up the note
/// @param notes_ref canonical name of the reference to use (optional); defaults to
/// "refs/notes/commits"
/// 
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_iterator>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_note_iterator_new(ffi.Pointer<ffi.Pointer<git_iterator>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> notes_ref,
);

/// Creates a new iterator for notes from a commit
/// 
/// The iterator must be freed manually by the user.
/// 
/// @param out pointer to the iterator
/// @param notes_commit a pointer to the notes commit object
/// 
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_iterator>> , ffi.Pointer<git_commit> )>()
external int git_note_commit_iterator_new(ffi.Pointer<ffi.Pointer<git_iterator>> out,
ffi.Pointer<git_commit> notes_commit,
);

/// Frees an git_note_iterator
/// 
/// @param it pointer to the iterator
@ffi.Native<ffi.Void Function(ffi.Pointer<git_iterator> )>()
external void git_note_iterator_free(ffi.Pointer<git_iterator> it,
);

/// Return the current item (note_id and annotated_id) and advance the iterator
/// internally to the next value
/// 
/// @param note_id id of blob containing the message
/// @param annotated_id id of the git object being annotated
/// @param it pointer to the iterator
/// 
/// @return 0 (no error), GIT_ITEROVER (iteration is done) or an error code
/// (negative value)
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_oid> , ffi.Pointer<git_iterator> )>()
external int git_note_next(ffi.Pointer<git_oid> note_id,
ffi.Pointer<git_oid> annotated_id,
ffi.Pointer<git_iterator> it,
);

/// Read the note for an object
/// 
/// The note must be freed manually by the user.
/// 
/// @param out pointer to the read note; NULL in case of error
/// @param repo repository where to look up the note
/// @param notes_ref canonical name of the reference to use (optional); defaults to
/// "refs/notes/commits"
/// @param oid OID of the git object to read the note from
/// 
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_note>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_oid> )>()
external int git_note_read(ffi.Pointer<ffi.Pointer<git_note>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> notes_ref,
ffi.Pointer<git_oid> oid,
);

/// Read the note for an object from a note commit
/// 
/// The note must be freed manually by the user.
/// 
/// @param out pointer to the read note; NULL in case of error
/// @param repo repository where to look up the note
/// @param notes_commit a pointer to the notes commit object
/// @param oid OID of the git object to read the note from
/// 
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_note>> , ffi.Pointer<git_repository> , ffi.Pointer<git_commit> , ffi.Pointer<git_oid> )>()
external int git_note_commit_read(ffi.Pointer<ffi.Pointer<git_note>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_commit> notes_commit,
ffi.Pointer<git_oid> oid,
);

/// Get the note author
/// 
/// @param note the note
/// @return the author
@ffi.Native<ffi.Pointer<git_signature> Function(ffi.Pointer<git_note> )>()
external ffi.Pointer<git_signature> git_note_author(ffi.Pointer<git_note> note,
);

/// Get the note committer
/// 
/// @param note the note
/// @return the committer
@ffi.Native<ffi.Pointer<git_signature> Function(ffi.Pointer<git_note> )>()
external ffi.Pointer<git_signature> git_note_committer(ffi.Pointer<git_note> note,
);

/// Get the note message
/// 
/// @param note the note
/// @return the note message
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_note> )>()
external ffi.Pointer<ffi.Char> git_note_message(ffi.Pointer<git_note> note,
);

/// Get the note object's id
/// 
/// @param note the note
/// @return the note object's id
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_note> )>()
external ffi.Pointer<git_oid> git_note_id(ffi.Pointer<git_note> note,
);

/// Add a note for an object
/// 
/// @param out pointer to store the OID (optional); NULL in case of error
/// @param repo repository where to store the note
/// @param notes_ref canonical name of the reference to use (optional);
/// defaults to "refs/notes/commits"
/// @param author signature of the notes commit author
/// @param committer signature of the notes commit committer
/// @param oid OID of the git object to decorate
/// @param note Content of the note to add for object oid
/// @param force Overwrite existing note
/// 
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_signature> , ffi.Pointer<git_signature> , ffi.Pointer<git_oid> , ffi.Pointer<ffi.Char> , ffi.Int )>()
external int git_note_create(ffi.Pointer<git_oid> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> notes_ref,
ffi.Pointer<git_signature> author,
ffi.Pointer<git_signature> committer,
ffi.Pointer<git_oid> oid,
ffi.Pointer<ffi.Char> note,
int force,
);

/// Add a note for an object from a commit
/// 
/// This function will create a notes commit for a given object,
/// the commit is a dangling commit, no reference is created.
/// 
/// @param notes_commit_out pointer to store the commit (optional);
/// NULL in case of error
/// @param notes_blob_out a point to the id of a note blob (optional)
/// @param repo repository where the note will live
/// @param parent Pointer to parent note
/// or NULL if this shall start a new notes tree
/// @param author signature of the notes commit author
/// @param committer signature of the notes commit committer
/// @param oid OID of the git object to decorate
/// @param note Content of the note to add for object oid
/// @param allow_note_overwrite Overwrite existing note
/// 
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<git_commit> , ffi.Pointer<git_signature> , ffi.Pointer<git_signature> , ffi.Pointer<git_oid> , ffi.Pointer<ffi.Char> , ffi.Int )>()
external int git_note_commit_create(ffi.Pointer<git_oid> notes_commit_out,
ffi.Pointer<git_oid> notes_blob_out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_commit> parent,
ffi.Pointer<git_signature> author,
ffi.Pointer<git_signature> committer,
ffi.Pointer<git_oid> oid,
ffi.Pointer<ffi.Char> note,
int allow_note_overwrite,
);

/// Remove the note for an object
/// 
/// @param repo repository where the note lives
/// @param notes_ref canonical name of the reference to use (optional);
/// defaults to "refs/notes/commits"
/// @param author signature of the notes commit author
/// @param committer signature of the notes commit committer
/// @param oid OID of the git object to remove the note from
/// 
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_signature> , ffi.Pointer<git_signature> , ffi.Pointer<git_oid> )>()
external int git_note_remove(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> notes_ref,
ffi.Pointer<git_signature> author,
ffi.Pointer<git_signature> committer,
ffi.Pointer<git_oid> oid,
);

/// Remove the note for an object
/// 
/// @param notes_commit_out pointer to store the new notes commit (optional);
/// NULL in case of error.
/// When removing a note a new tree containing all notes
/// sans the note to be removed is created and a new commit
/// pointing to that tree is also created.
/// In the case where the resulting tree is an empty tree
/// a new commit pointing to this empty tree will be returned.
/// @param repo repository where the note lives
/// @param notes_commit a pointer to the notes commit object
/// @param author signature of the notes commit author
/// @param committer signature of the notes commit committer
/// @param oid OID of the git object to remove the note from
/// 
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<git_commit> , ffi.Pointer<git_signature> , ffi.Pointer<git_signature> , ffi.Pointer<git_oid> )>()
external int git_note_commit_remove(ffi.Pointer<git_oid> notes_commit_out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_commit> notes_commit,
ffi.Pointer<git_signature> author,
ffi.Pointer<git_signature> committer,
ffi.Pointer<git_oid> oid,
);

/// Free a git_note object
/// 
/// @param note git_note object
@ffi.Native<ffi.Void Function(ffi.Pointer<git_note> )>()
external void git_note_free(ffi.Pointer<git_note> note,
);

/// Get the default notes reference for a repository
/// 
/// @param out buffer in which to store the name of the default notes reference
/// @param repo The Git repository
/// 
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_repository> )>()
external int git_note_default_ref(ffi.Pointer<git_buf> out,
ffi.Pointer<git_repository> repo,
);

/// Loop over all the notes within a specified namespace
/// and issue a callback for each one.
/// 
/// @param repo Repository where to find the notes.
/// 
/// @param notes_ref Reference to read from (optional); defaults to
/// "refs/notes/commits".
/// 
/// @param note_cb Callback to invoke per found annotation.  Return non-zero
/// to stop looping.
/// 
/// @param payload Extra parameter to callback function.
/// 
/// @return 0 on success, non-zero callback return value, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_oid> blob_id, ffi.Pointer<git_oid> annotated_object_id, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_note_foreach(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> notes_ref,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_oid> blob_id, ffi.Pointer<git_oid> annotated_object_id, ffi.Pointer<ffi.Void> payload)>> note_cb,
ffi.Pointer<ffi.Void> payload,
);

/// Create a backend for a directory containing packfiles.
/// 
/// @param[out] out location to store the odb backend pointer
/// @param objects_dir the Git repository's objects directory
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb_backend>> , ffi.Pointer<ffi.Char> )>()
external int git_odb_backend_pack(ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
ffi.Pointer<ffi.Char> objects_dir,
);

/// Create a backend out of a single packfile
/// 
/// This can be useful for inspecting the contents of a single
/// packfile.
/// 
/// @param[out] out location to store the odb backend pointer
/// @param index_file path to the packfile's .idx file
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb_backend>> , ffi.Pointer<ffi.Char> )>()
external int git_odb_backend_one_pack(ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
ffi.Pointer<ffi.Char> index_file,
);

/// Create a backend for loose objects
/// 
/// @param[out] out location to store the odb backend pointer
/// @param objects_dir the Git repository's objects directory
/// @param compression_level zlib compression level (0-9), or -1 for the default
/// @param do_fsync if non-zero, perform an fsync on write
/// @param dir_mode permission to use when creating directories, or 0 for default
/// @param file_mode permission to use when creating directories, or 0 for default
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb_backend>> , ffi.Pointer<ffi.Char> , ffi.Int , ffi.Int , ffi.UnsignedInt , ffi.UnsignedInt )>()
external int git_odb_backend_loose(ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
ffi.Pointer<ffi.Char> objects_dir,
int compression_level,
int do_fsync,
int dir_mode,
int file_mode,
);

/// Get the repository associated with this patch. May be NULL.
/// 
/// @param patch the patch
/// @return a pointer to the repository
@ffi.Native<ffi.Pointer<git_repository> Function(ffi.Pointer<git_patch> )>()
external ffi.Pointer<git_repository> git_patch_owner(ffi.Pointer<git_patch> patch,
);

/// Return a patch for an entry in the diff list.
/// 
/// The `git_patch` is a newly created object contains the text diffs
/// for the delta.  You have to call `git_patch_free()` when you are
/// done with it.  You can use the patch object to loop over all the hunks
/// and lines in the diff of the one delta.
/// 
/// For an unchanged file or a binary file, no `git_patch` will be
/// created, the output will be set to NULL, and the `binary` flag will be
/// set true in the `git_diff_delta` structure.
/// 
/// It is okay to pass NULL for either of the output parameters; if you pass
/// NULL for the `git_patch`, then the text diff will not be calculated.
/// 
/// @param out Output parameter for the delta patch object
/// @param diff Diff list object
/// @param idx Index into diff list
/// @return 0 on success, other value < 0 on error
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_patch>> , ffi.Pointer<git_diff> , ffi.Size )>()
external int git_patch_from_diff(ffi.Pointer<ffi.Pointer<git_patch>> out,
ffi.Pointer<git_diff> diff,
int idx,
);

/// Directly generate a patch from the difference between two blobs.
/// 
/// This is just like `git_diff_blobs()` except it generates a patch object
/// for the difference instead of directly making callbacks.  You can use the
/// standard `git_patch` accessor functions to read the patch data, and
/// you must call `git_patch_free()` on the patch when done.
/// 
/// @param out The generated patch; NULL on error
/// @param old_blob Blob for old side of diff, or NULL for empty blob
/// @param old_as_path Treat old blob as if it had this filename; can be NULL
/// @param new_blob Blob for new side of diff, or NULL for empty blob
/// @param new_as_path Treat new blob as if it had this filename; can be NULL
/// @param opts Options for diff, or NULL for default options
/// @return 0 on success or error code < 0
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_patch>> , ffi.Pointer<git_blob> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_blob> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_diff_options> )>()
external int git_patch_from_blobs(ffi.Pointer<ffi.Pointer<git_patch>> out,
ffi.Pointer<git_blob> old_blob,
ffi.Pointer<ffi.Char> old_as_path,
ffi.Pointer<git_blob> new_blob,
ffi.Pointer<ffi.Char> new_as_path,
ffi.Pointer<git_diff_options> opts,
);

/// Directly generate a patch from the difference between a blob and a buffer.
/// 
/// This is just like `git_diff_blob_to_buffer()` except it generates a patch
/// object for the difference instead of directly making callbacks.  You can
/// use the standard `git_patch` accessor functions to read the patch
/// data, and you must call `git_patch_free()` on the patch when done.
/// 
/// @param out The generated patch; NULL on error
/// @param old_blob Blob for old side of diff, or NULL for empty blob
/// @param old_as_path Treat old blob as if it had this filename; can be NULL
/// @param buffer Raw data for new side of diff, or NULL for empty
/// @param buffer_len Length of raw data for new side of diff
/// @param buffer_as_path Treat buffer as if it had this filename; can be NULL
/// @param opts Options for diff, or NULL for default options
/// @return 0 on success or error code < 0
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_patch>> , ffi.Pointer<git_blob> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Void> , ffi.Size , ffi.Pointer<ffi.Char> , ffi.Pointer<git_diff_options> )>()
external int git_patch_from_blob_and_buffer(ffi.Pointer<ffi.Pointer<git_patch>> out,
ffi.Pointer<git_blob> old_blob,
ffi.Pointer<ffi.Char> old_as_path,
ffi.Pointer<ffi.Void> buffer,
int buffer_len,
ffi.Pointer<ffi.Char> buffer_as_path,
ffi.Pointer<git_diff_options> opts,
);

/// Directly generate a patch from the difference between two buffers.
/// 
/// This is just like `git_diff_buffers()` except it generates a patch
/// object for the difference instead of directly making callbacks.  You can
/// use the standard `git_patch` accessor functions to read the patch
/// data, and you must call `git_patch_free()` on the patch when done.
/// 
/// @param out The generated patch; NULL on error
/// @param old_buffer Raw data for old side of diff, or NULL for empty
/// @param old_len Length of the raw data for old side of the diff
/// @param old_as_path Treat old buffer as if it had this filename; can be NULL
/// @param new_buffer Raw data for new side of diff, or NULL for empty
/// @param new_len Length of raw data for new side of diff
/// @param new_as_path Treat buffer as if it had this filename; can be NULL
/// @param opts Options for diff, or NULL for default options
/// @return 0 on success or error code < 0
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_patch>> , ffi.Pointer<ffi.Void> , ffi.Size , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Void> , ffi.Size , ffi.Pointer<ffi.Char> , ffi.Pointer<git_diff_options> )>()
external int git_patch_from_buffers(ffi.Pointer<ffi.Pointer<git_patch>> out,
ffi.Pointer<ffi.Void> old_buffer,
int old_len,
ffi.Pointer<ffi.Char> old_as_path,
ffi.Pointer<ffi.Void> new_buffer,
int new_len,
ffi.Pointer<ffi.Char> new_as_path,
ffi.Pointer<git_diff_options> opts,
);

/// Free a git_patch object.
/// 
/// @param patch The patch to free.
@ffi.Native<ffi.Void Function(ffi.Pointer<git_patch> )>()
external void git_patch_free(ffi.Pointer<git_patch> patch,
);

/// Get the delta associated with a patch.  This delta points to internal
/// data and you do not have to release it when you are done with it.
/// 
/// @param patch The patch in which to get the delta.
/// @return The delta associated with the patch.
@ffi.Native<ffi.Pointer<git_diff_delta> Function(ffi.Pointer<git_patch> )>()
external ffi.Pointer<git_diff_delta> git_patch_get_delta(ffi.Pointer<git_patch> patch,
);

/// Get the number of hunks in a patch
/// 
/// @param patch The patch in which to get the number of hunks.
/// @return The number of hunks of the patch.
@ffi.Native<ffi.Size Function(ffi.Pointer<git_patch> )>()
external int git_patch_num_hunks(ffi.Pointer<git_patch> patch,
);

/// Get line counts of each type in a patch.
/// 
/// This helps imitate a diff --numstat type of output.  For that purpose,
/// you only need the `total_additions` and `total_deletions` values, but we
/// include the `total_context` line count in case you want the total number
/// of lines of diff output that will be generated.
/// 
/// All outputs are optional. Pass NULL if you don't need a particular count.
/// 
/// @param total_context Count of context lines in output, can be NULL.
/// @param total_additions Count of addition lines in output, can be NULL.
/// @param total_deletions Count of deletion lines in output, can be NULL.
/// @param patch The git_patch object
/// @return 0 on success, <0 on error
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Size> , ffi.Pointer<ffi.Size> , ffi.Pointer<ffi.Size> , ffi.Pointer<git_patch> )>()
external int git_patch_line_stats(ffi.Pointer<ffi.Size> total_context,
ffi.Pointer<ffi.Size> total_additions,
ffi.Pointer<ffi.Size> total_deletions,
ffi.Pointer<git_patch> patch,
);

/// Get the information about a hunk in a patch
/// 
/// Given a patch and a hunk index into the patch, this returns detailed
/// information about that hunk.  Any of the output pointers can be passed
/// as NULL if you don't care about that particular piece of information.
/// 
/// @param out Output pointer to git_diff_hunk of hunk
/// @param lines_in_hunk Output count of total lines in this hunk
/// @param patch Input pointer to patch object
/// @param hunk_idx Input index of hunk to get information about
/// @return 0 on success, GIT_ENOTFOUND if hunk_idx out of range, <0 on error
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_diff_hunk>> , ffi.Pointer<ffi.Size> , ffi.Pointer<git_patch> , ffi.Size )>()
external int git_patch_get_hunk(ffi.Pointer<ffi.Pointer<git_diff_hunk>> out,
ffi.Pointer<ffi.Size> lines_in_hunk,
ffi.Pointer<git_patch> patch,
int hunk_idx,
);

/// Get the number of lines in a hunk.
/// 
/// @param patch The git_patch object
/// @param hunk_idx Index of the hunk
/// @return Number of lines in hunk or GIT_ENOTFOUND if invalid hunk index
@ffi.Native<ffi.Int Function(ffi.Pointer<git_patch> , ffi.Size )>()
external int git_patch_num_lines_in_hunk(ffi.Pointer<git_patch> patch,
int hunk_idx,
);

/// Get data about a line in a hunk of a patch.
/// 
/// Given a patch, a hunk index, and a line index in the hunk, this
/// will return a lot of details about that line.  If you pass a hunk
/// index larger than the number of hunks or a line index larger than
/// the number of lines in the hunk, this will return -1.
/// 
/// @param out The git_diff_line data for this line
/// @param patch The patch to look in
/// @param hunk_idx The index of the hunk
/// @param line_of_hunk The index of the line in the hunk
/// @return 0 on success, <0 on failure
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_diff_line>> , ffi.Pointer<git_patch> , ffi.Size , ffi.Size )>()
external int git_patch_get_line_in_hunk(ffi.Pointer<ffi.Pointer<git_diff_line>> out,
ffi.Pointer<git_patch> patch,
int hunk_idx,
int line_of_hunk,
);

/// Look up size of patch diff data in bytes
/// 
/// This returns the raw size of the patch data.  This only includes the
/// actual data from the lines of the diff, not the file or hunk headers.
/// 
/// If you pass `include_context` as true (non-zero), this will be the size
/// of all of the diff output; if you pass it as false (zero), this will
/// only include the actual changed lines (as if `context_lines` was 0).
/// 
/// @param patch A git_patch representing changes to one file
/// @param include_context Include context lines in size if non-zero
/// @param include_hunk_headers Include hunk header lines if non-zero
/// @param include_file_headers Include file header lines if non-zero
/// @return The number of bytes of data
@ffi.Native<ffi.Size Function(ffi.Pointer<git_patch> , ffi.Int , ffi.Int , ffi.Int )>()
external int git_patch_size(ffi.Pointer<git_patch> patch,
int include_context,
int include_hunk_headers,
int include_file_headers,
);

/// Serialize the patch to text via callback.
/// 
/// Returning a non-zero value from the callback will terminate the iteration
/// and return that value to the caller.
/// 
/// @param patch A git_patch representing changes to one file
/// @param print_cb Callback function to output lines of the patch.  Will be
/// called for file headers, hunk headers, and diff lines.
/// @param payload Reference pointer that will be passed to your callbacks.
/// @return 0 on success, non-zero callback return value, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_patch> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<git_diff_line> line, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_patch_print(ffi.Pointer<git_patch> patch,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<git_diff_line> line, ffi.Pointer<ffi.Void> payload)>> print_cb,
ffi.Pointer<ffi.Void> payload,
);

/// Get the content of a patch as a single diff text.
/// 
/// @param out The git_buf to be filled in
/// @param patch A git_patch representing changes to one file
/// @return 0 on success, <0 on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_patch> )>()
external int git_patch_to_buf(ffi.Pointer<git_buf> out,
ffi.Pointer<git_patch> patch,
);

/// Compile a pathspec
/// 
/// @param out Output of the compiled pathspec
/// @param pathspec A git_strarray of the paths to match
/// @return 0 on success, <0 on failure
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_pathspec>> , ffi.Pointer<git_strarray> )>()
external int git_pathspec_new(ffi.Pointer<ffi.Pointer<git_pathspec>> out,
ffi.Pointer<git_strarray> pathspec,
);

/// Free a pathspec
/// 
/// @param ps The compiled pathspec
@ffi.Native<ffi.Void Function(ffi.Pointer<git_pathspec> )>()
external void git_pathspec_free(ffi.Pointer<git_pathspec> ps,
);

/// Try to match a path against a pathspec
/// 
/// Unlike most of the other pathspec matching functions, this will not
/// fall back on the native case-sensitivity for your platform.  You must
/// explicitly pass flags to control case sensitivity or else this will
/// fall back on being case sensitive.
/// 
/// @param ps The compiled pathspec
/// @param flags Combination of git_pathspec_flag_t options to control match
/// @param path The pathname to attempt to match
/// @return 1 is path matches spec, 0 if it does not
@ffi.Native<ffi.Int Function(ffi.Pointer<git_pathspec> , ffi.Uint32 , ffi.Pointer<ffi.Char> )>()
external int git_pathspec_matches_path(ffi.Pointer<git_pathspec> ps,
int flags,
ffi.Pointer<ffi.Char> path,
);

/// Match a pathspec against the working directory of a repository.
/// 
/// This matches the pathspec against the current files in the working
/// directory of the repository.  It is an error to invoke this on a bare
/// repo.  This handles git ignores (i.e. ignored files will not be
/// considered to match the `pathspec` unless the file is tracked in the
/// index).
/// 
/// If `out` is not NULL, this returns a `git_patchspec_match_list`.  That
/// contains the list of all matched filenames (unless you pass the
/// `GIT_PATHSPEC_FAILURES_ONLY` flag) and may also contain the list of
/// pathspecs with no match (if you used the `GIT_PATHSPEC_FIND_FAILURES`
/// flag).  You must call `git_pathspec_match_list_free()` on this object.
/// 
/// @param out Output list of matches; pass NULL to just get return value
/// @param repo The repository in which to match; bare repo is an error
/// @param flags Combination of git_pathspec_flag_t options to control match
/// @param ps Pathspec to be matched
/// @return 0 on success, -1 on error, GIT_ENOTFOUND if no matches and
/// the GIT_PATHSPEC_NO_MATCH_ERROR flag was given
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> , ffi.Pointer<git_repository> , ffi.Uint32 , ffi.Pointer<git_pathspec> )>()
external int git_pathspec_match_workdir(ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
ffi.Pointer<git_repository> repo,
int flags,
ffi.Pointer<git_pathspec> ps,
);

/// Match a pathspec against entries in an index.
/// 
/// This matches the pathspec against the files in the repository index.
/// 
/// NOTE: At the moment, the case sensitivity of this match is controlled
/// by the current case-sensitivity of the index object itself and the
/// USE_CASE and IGNORE_CASE flags will have no effect.  This behavior will
/// be corrected in a future release.
/// 
/// If `out` is not NULL, this returns a `git_patchspec_match_list`.  That
/// contains the list of all matched filenames (unless you pass the
/// `GIT_PATHSPEC_FAILURES_ONLY` flag) and may also contain the list of
/// pathspecs with no match (if you used the `GIT_PATHSPEC_FIND_FAILURES`
/// flag).  You must call `git_pathspec_match_list_free()` on this object.
/// 
/// @param out Output list of matches; pass NULL to just get return value
/// @param index The index to match against
/// @param flags Combination of git_pathspec_flag_t options to control match
/// @param ps Pathspec to be matched
/// @return 0 on success, -1 on error, GIT_ENOTFOUND if no matches and
/// the GIT_PATHSPEC_NO_MATCH_ERROR flag is used
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> , ffi.Pointer<git_index> , ffi.Uint32 , ffi.Pointer<git_pathspec> )>()
external int git_pathspec_match_index(ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
ffi.Pointer<git_index> index,
int flags,
ffi.Pointer<git_pathspec> ps,
);

/// Match a pathspec against files in a tree.
/// 
/// This matches the pathspec against the files in the given tree.
/// 
/// If `out` is not NULL, this returns a `git_patchspec_match_list`.  That
/// contains the list of all matched filenames (unless you pass the
/// `GIT_PATHSPEC_FAILURES_ONLY` flag) and may also contain the list of
/// pathspecs with no match (if you used the `GIT_PATHSPEC_FIND_FAILURES`
/// flag).  You must call `git_pathspec_match_list_free()` on this object.
/// 
/// @param out Output list of matches; pass NULL to just get return value
/// @param tree The root-level tree to match against
/// @param flags Combination of git_pathspec_flag_t options to control match
/// @param ps Pathspec to be matched
/// @return 0 on success, -1 on error, GIT_ENOTFOUND if no matches and
/// the GIT_PATHSPEC_NO_MATCH_ERROR flag is used
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> , ffi.Pointer<git_tree> , ffi.Uint32 , ffi.Pointer<git_pathspec> )>()
external int git_pathspec_match_tree(ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
ffi.Pointer<git_tree> tree,
int flags,
ffi.Pointer<git_pathspec> ps,
);

/// Match a pathspec against files in a diff list.
/// 
/// This matches the pathspec against the files in the given diff list.
/// 
/// If `out` is not NULL, this returns a `git_patchspec_match_list`.  That
/// contains the list of all matched filenames (unless you pass the
/// `GIT_PATHSPEC_FAILURES_ONLY` flag) and may also contain the list of
/// pathspecs with no match (if you used the `GIT_PATHSPEC_FIND_FAILURES`
/// flag).  You must call `git_pathspec_match_list_free()` on this object.
/// 
/// @param out Output list of matches; pass NULL to just get return value
/// @param diff A generated diff list
/// @param flags Combination of git_pathspec_flag_t options to control match
/// @param ps Pathspec to be matched
/// @return 0 on success, -1 on error, GIT_ENOTFOUND if no matches and
/// the GIT_PATHSPEC_NO_MATCH_ERROR flag is used
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> , ffi.Pointer<git_diff> , ffi.Uint32 , ffi.Pointer<git_pathspec> )>()
external int git_pathspec_match_diff(ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
ffi.Pointer<git_diff> diff,
int flags,
ffi.Pointer<git_pathspec> ps,
);

/// Free memory associates with a git_pathspec_match_list
/// 
/// @param m The git_pathspec_match_list to be freed
@ffi.Native<ffi.Void Function(ffi.Pointer<git_pathspec_match_list> )>()
external void git_pathspec_match_list_free(ffi.Pointer<git_pathspec_match_list> m,
);

/// Get the number of items in a match list.
/// 
/// @param m The git_pathspec_match_list object
/// @return Number of items in match list
@ffi.Native<ffi.Size Function(ffi.Pointer<git_pathspec_match_list> )>()
external int git_pathspec_match_list_entrycount(ffi.Pointer<git_pathspec_match_list> m,
);

/// Get a matching filename by position.
/// 
/// This routine cannot be used if the match list was generated by
/// `git_pathspec_match_diff`.  If so, it will always return NULL.
/// 
/// @param m The git_pathspec_match_list object
/// @param pos The index into the list
/// @return The filename of the match
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_pathspec_match_list> , ffi.Size )>()
external ffi.Pointer<ffi.Char> git_pathspec_match_list_entry(ffi.Pointer<git_pathspec_match_list> m,
int pos,
);

/// Get a matching diff delta by position.
/// 
/// This routine can only be used if the match list was generated by
/// `git_pathspec_match_diff`.  Otherwise it will always return NULL.
/// 
/// @param m The git_pathspec_match_list object
/// @param pos The index into the list
/// @return The filename of the match
@ffi.Native<ffi.Pointer<git_diff_delta> Function(ffi.Pointer<git_pathspec_match_list> , ffi.Size )>()
external ffi.Pointer<git_diff_delta> git_pathspec_match_list_diff_entry(ffi.Pointer<git_pathspec_match_list> m,
int pos,
);

/// Get the number of pathspec items that did not match.
/// 
/// This will be zero unless you passed GIT_PATHSPEC_FIND_FAILURES when
/// generating the git_pathspec_match_list.
/// 
/// @param m The git_pathspec_match_list object
/// @return Number of items in original pathspec that had no matches
@ffi.Native<ffi.Size Function(ffi.Pointer<git_pathspec_match_list> )>()
external int git_pathspec_match_list_failed_entrycount(ffi.Pointer<git_pathspec_match_list> m,
);

/// Get an original pathspec string that had no matches.
/// 
/// This will be return NULL for positions out of range.
/// 
/// @param m The git_pathspec_match_list object
/// @param pos The index into the failed items
/// @return The pathspec pattern that didn't match anything
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_pathspec_match_list> , ffi.Size )>()
external ffi.Pointer<ffi.Char> git_pathspec_match_list_failed_entry(ffi.Pointer<git_pathspec_match_list> m,
int pos,
);

/// Create a new reference database with no backends.
/// 
/// Before the Ref DB can be used for read/writing, a custom database
/// backend must be manually set using `git_refdb_set_backend()`
/// 
/// @param out location to store the database pointer, if opened.
/// Set to NULL if the open failed.
/// @param repo the repository
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_refdb>> , ffi.Pointer<git_repository> )>()
external int git_refdb_new(ffi.Pointer<ffi.Pointer<git_refdb>> out,
ffi.Pointer<git_repository> repo,
);

/// Create a new reference database and automatically add
/// the default backends:
/// 
/// - git_refdb_dir: read and write loose and packed refs
/// from disk, assuming the repository dir as the folder
/// 
/// @param out location to store the database pointer, if opened.
/// Set to NULL if the open failed.
/// @param repo the repository
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_refdb>> , ffi.Pointer<git_repository> )>()
external int git_refdb_open(ffi.Pointer<ffi.Pointer<git_refdb>> out,
ffi.Pointer<git_repository> repo,
);

/// Suggests that the given refdb compress or optimize its references.
/// This mechanism is implementation specific.  For on-disk reference
/// databases, for example, this may pack all loose references.
/// 
/// @param refdb The reference database to optimize.
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_refdb> )>()
external int git_refdb_compress(ffi.Pointer<git_refdb> refdb,
);

/// Close an open reference database.
/// 
/// @param refdb reference database pointer or NULL
@ffi.Native<ffi.Void Function(ffi.Pointer<git_refdb> )>()
external void git_refdb_free(ffi.Pointer<git_refdb> refdb,
);

/// Read the reflog for the given reference
/// 
/// If there is no reflog file for the given
/// reference yet, an empty reflog object will
/// be returned.
/// 
/// The reflog must be freed manually by using
/// git_reflog_free().
/// 
/// @param out pointer to reflog
/// @param repo the repository
/// @param name reference to look up
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reflog>> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_reflog_read(ffi.Pointer<ffi.Pointer<git_reflog>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
);

/// Write an existing in-memory reflog object back to disk
/// using an atomic file lock.
/// 
/// @param reflog an existing reflog object
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_reflog> )>()
external int git_reflog_write(ffi.Pointer<git_reflog> reflog,
);

/// Add a new entry to the in-memory reflog.
/// 
/// `msg` is optional and can be NULL.
/// 
/// @param reflog an existing reflog object
/// @param id the OID the reference is now pointing to
/// @param committer the signature of the committer
/// @param msg the reflog message
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_reflog> , ffi.Pointer<git_oid> , ffi.Pointer<git_signature> , ffi.Pointer<ffi.Char> )>()
external int git_reflog_append(ffi.Pointer<git_reflog> reflog,
ffi.Pointer<git_oid> id,
ffi.Pointer<git_signature> committer,
ffi.Pointer<ffi.Char> msg,
);

/// Rename a reflog
/// 
/// The reflog to be renamed is expected to already exist
/// 
/// The new name will be checked for validity.
/// See `git_reference_create_symbolic()` for rules about valid names.
/// 
/// @param repo the repository
/// @param old_name the old name of the reference
/// @param name the new name of the reference
/// @return 0 on success, GIT_EINVALIDSPEC or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_reflog_rename(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> old_name,
ffi.Pointer<ffi.Char> name,
);

/// Delete the reflog for the given reference
/// 
/// @param repo the repository
/// @param name the reflog to delete
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_reflog_delete(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> name,
);

/// Get the number of log entries in a reflog
/// 
/// @param reflog the previously loaded reflog
/// @return the number of log entries
@ffi.Native<ffi.Size Function(ffi.Pointer<git_reflog> )>()
external int git_reflog_entrycount(ffi.Pointer<git_reflog> reflog,
);

/// Lookup an entry by its index
/// 
/// Requesting the reflog entry with an index of 0 (zero) will
/// return the most recently created entry.
/// 
/// @param reflog a previously loaded reflog
/// @param idx the position of the entry to lookup. Should be greater than or
/// equal to 0 (zero) and less than `git_reflog_entrycount()`.
/// @return the entry; NULL if not found
@ffi.Native<ffi.Pointer<git_reflog_entry> Function(ffi.Pointer<git_reflog> , ffi.Size )>()
external ffi.Pointer<git_reflog_entry> git_reflog_entry_byindex(ffi.Pointer<git_reflog> reflog,
int idx,
);

/// Remove an entry from the reflog by its index
/// 
/// To ensure there's no gap in the log history, set `rewrite_previous_entry`
/// param value to 1. When deleting entry `n`, member old_oid of entry `n-1`
/// (if any) will be updated with the value of member new_oid of entry `n+1`.
/// 
/// @param reflog a previously loaded reflog.
/// 
/// @param idx the position of the entry to remove. Should be greater than or
/// equal to 0 (zero) and less than `git_reflog_entrycount()`.
/// 
/// @param rewrite_previous_entry 1 to rewrite the history; 0 otherwise.
/// 
/// @return 0 on success, GIT_ENOTFOUND if the entry doesn't exist
/// or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_reflog> , ffi.Size , ffi.Int )>()
external int git_reflog_drop(ffi.Pointer<git_reflog> reflog,
int idx,
int rewrite_previous_entry,
);

/// Get the old oid
/// 
/// @param entry a reflog entry
/// @return the old oid
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_reflog_entry> )>()
external ffi.Pointer<git_oid> git_reflog_entry_id_old(ffi.Pointer<git_reflog_entry> entry,
);

/// Get the new oid
/// 
/// @param entry a reflog entry
/// @return the new oid at this time
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_reflog_entry> )>()
external ffi.Pointer<git_oid> git_reflog_entry_id_new(ffi.Pointer<git_reflog_entry> entry,
);

/// Get the committer of this entry
/// 
/// @param entry a reflog entry
/// @return the committer
@ffi.Native<ffi.Pointer<git_signature> Function(ffi.Pointer<git_reflog_entry> )>()
external ffi.Pointer<git_signature> git_reflog_entry_committer(ffi.Pointer<git_reflog_entry> entry,
);

/// Get the log message
/// 
/// @param entry a reflog entry
/// @return the log msg
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_reflog_entry> )>()
external ffi.Pointer<ffi.Char> git_reflog_entry_message(ffi.Pointer<git_reflog_entry> entry,
);

/// Free the reflog
/// 
/// @param reflog reflog to free
@ffi.Native<ffi.Void Function(ffi.Pointer<git_reflog> )>()
external void git_reflog_free(ffi.Pointer<git_reflog> reflog,
);

/// Sets the current head to the specified commit oid and optionally
/// resets the index and working tree to match.
/// 
/// SOFT reset means the Head will be moved to the commit.
/// 
/// MIXED reset will trigger a SOFT reset, plus the index will be replaced
/// with the content of the commit tree.
/// 
/// HARD reset will trigger a MIXED reset and the working directory will be
/// replaced with the content of the index.  (Untracked and ignored files
/// will be left alone, however.)
/// 
/// TODO: Implement remaining kinds of resets.
/// 
/// @param repo Repository where to perform the reset operation.
/// 
/// @param target Committish to which the Head should be moved to. This object
/// must belong to the given `repo` and can either be a git_commit or a
/// git_tag. When a git_tag is being passed, it should be dereferenceable
/// to a git_commit which oid will be used as the target of the branch.
/// 
/// @param reset_type Kind of reset operation to perform.
/// 
/// @param checkout_opts Optional checkout options to be used for a HARD reset.
/// The checkout_strategy field will be overridden (based on reset_type).
/// This parameter can be used to propagate notify and progress callbacks.
/// 
/// @return 0 on success or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<git_object> , ffi.UnsignedInt , ffi.Pointer<git_checkout_options> )>(symbol: 'git_reset')
external int _git_reset(ffi.Pointer<git_repository> repo,
ffi.Pointer<git_object> target,
int reset_type,
ffi.Pointer<git_checkout_options> checkout_opts,
);

int git_reset(ffi.Pointer<git_repository> repo,
ffi.Pointer<git_object> target,
git_reset_t reset_type,
ffi.Pointer<git_checkout_options> checkout_opts,
) => _git_reset(repo,
target,
reset_type.value,
checkout_opts,
);

/// Sets the current head to the specified commit oid and optionally
/// resets the index and working tree to match.
/// 
/// This behaves like `git_reset()` but takes an annotated commit,
/// which lets you specify which extended sha syntax string was
/// specified by a user, allowing for more exact reflog messages.
/// 
/// See the documentation for `git_reset()`.
/// 
/// @param repo Repository where to perform the reset operation.
/// 
/// @param target Annotated commit to which the Head should be moved to.
/// This object must belong to the given `repo`, it will be dereferenced
/// to a git_commit which oid will be used as the target of the branch.
/// 
/// @param reset_type Kind of reset operation to perform.
/// 
/// @param checkout_opts Optional checkout options to be used for a HARD reset.
/// The checkout_strategy field will be overridden (based on reset_type).
/// This parameter can be used to propagate notify and progress callbacks.
/// 
/// @return 0 on success or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<git_annotated_commit> , ffi.UnsignedInt , ffi.Pointer<git_checkout_options> )>(symbol: 'git_reset_from_annotated')
external int _git_reset_from_annotated(ffi.Pointer<git_repository> repo,
ffi.Pointer<git_annotated_commit> target,
int reset_type,
ffi.Pointer<git_checkout_options> checkout_opts,
);

int git_reset_from_annotated(ffi.Pointer<git_repository> repo,
ffi.Pointer<git_annotated_commit> target,
git_reset_t reset_type,
ffi.Pointer<git_checkout_options> checkout_opts,
) => _git_reset_from_annotated(repo,
target,
reset_type.value,
checkout_opts,
);

/// Updates some entries in the index from the target commit tree.
/// 
/// The scope of the updated entries is determined by the paths
/// being passed in the `pathspec` parameters.
/// 
/// Passing a NULL `target` will result in removing
/// entries in the index matching the provided pathspecs.
/// 
/// @param repo Repository where to perform the reset operation.
/// 
/// @param target The committish which content will be used to reset the content
/// of the index.
/// 
/// @param pathspecs List of pathspecs to operate on.
/// 
/// @return 0 on success or an error code < 0
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<git_object> , ffi.Pointer<git_strarray> )>()
external int git_reset_default(ffi.Pointer<git_repository> repo,
ffi.Pointer<git_object> target,
ffi.Pointer<git_strarray> pathspecs,
);

/// Allocate a new revision walker to iterate through a repo.
/// 
/// This revision walker uses a custom memory pool and an internal
/// commit cache, so it is relatively expensive to allocate.
/// 
/// For maximum performance, this revision walker should be
/// reused for different walks.
/// 
/// This revision walker is *not* thread safe: it may only be
/// used to walk a repository on a single thread; however,
/// it is possible to have several revision walkers in
/// several different threads walking the same repository.
/// 
/// @param out pointer to the new revision walker
/// @param repo the repo to walk through
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_revwalk>> , ffi.Pointer<git_repository> )>()
external int git_revwalk_new(ffi.Pointer<ffi.Pointer<git_revwalk>> out,
ffi.Pointer<git_repository> repo,
);

/// Reset the revision walker for reuse.
/// 
/// This will clear all the pushed and hidden commits, and
/// leave the walker in a blank state (just like at
/// creation) ready to receive new commit pushes and
/// start a new walk.
/// 
/// The revision walk is automatically reset when a walk
/// is over.
/// 
/// @param walker handle to reset.
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_revwalk> )>()
external int git_revwalk_reset(ffi.Pointer<git_revwalk> walker,
);

/// Add a new root for the traversal
/// 
/// The pushed commit will be marked as one of the roots from which to
/// start the walk. This commit may not be walked if it or a child is
/// hidden.
/// 
/// At least one commit must be pushed onto the walker before a walk
/// can be started.
/// 
/// The given id must belong to a committish on the walked
/// repository.
/// 
/// @param walk the walker being used for the traversal.
/// @param id the oid of the commit to start from.
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_revwalk> , ffi.Pointer<git_oid> )>()
external int git_revwalk_push(ffi.Pointer<git_revwalk> walk,
ffi.Pointer<git_oid> id,
);

/// Push matching references
/// 
/// The OIDs pointed to by the references that match the given glob
/// pattern will be pushed to the revision walker.
/// 
/// A leading 'refs/' is implied if not present as well as a trailing
/// '/\*' if the glob lacks '?', '\*' or '['.
/// 
/// Any references matching this glob which do not point to a
/// committish will be ignored.
/// 
/// @param walk the walker being used for the traversal
/// @param glob the glob pattern references should match
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_revwalk> , ffi.Pointer<ffi.Char> )>()
external int git_revwalk_push_glob(ffi.Pointer<git_revwalk> walk,
ffi.Pointer<ffi.Char> glob,
);

/// Push the repository's HEAD
/// 
/// @param walk the walker being used for the traversal
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_revwalk> )>()
external int git_revwalk_push_head(ffi.Pointer<git_revwalk> walk,
);

/// Mark a commit (and its ancestors) uninteresting for the output.
/// 
/// The given id must belong to a committish on the walked
/// repository.
/// 
/// The resolved commit and all its parents will be hidden from the
/// output on the revision walk.
/// 
/// @param walk the walker being used for the traversal.
/// @param commit_id the oid of commit that will be ignored during the traversal
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_revwalk> , ffi.Pointer<git_oid> )>()
external int git_revwalk_hide(ffi.Pointer<git_revwalk> walk,
ffi.Pointer<git_oid> commit_id,
);

/// Hide matching references.
/// 
/// The OIDs pointed to by the references that match the given glob
/// pattern and their ancestors will be hidden from the output on the
/// revision walk.
/// 
/// A leading 'refs/' is implied if not present as well as a trailing
/// '/\*' if the glob lacks '?', '\*' or '['.
/// 
/// Any references matching this glob which do not point to a
/// committish will be ignored.
/// 
/// @param walk the walker being used for the traversal
/// @param glob the glob pattern references should match
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_revwalk> , ffi.Pointer<ffi.Char> )>()
external int git_revwalk_hide_glob(ffi.Pointer<git_revwalk> walk,
ffi.Pointer<ffi.Char> glob,
);

/// Hide the repository's HEAD
/// 
/// @param walk the walker being used for the traversal
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_revwalk> )>()
external int git_revwalk_hide_head(ffi.Pointer<git_revwalk> walk,
);

/// Push the OID pointed to by a reference
/// 
/// The reference must point to a committish.
/// 
/// @param walk the walker being used for the traversal
/// @param refname the reference to push
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_revwalk> , ffi.Pointer<ffi.Char> )>()
external int git_revwalk_push_ref(ffi.Pointer<git_revwalk> walk,
ffi.Pointer<ffi.Char> refname,
);

/// Hide the OID pointed to by a reference
/// 
/// The reference must point to a committish.
/// 
/// @param walk the walker being used for the traversal
/// @param refname the reference to hide
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_revwalk> , ffi.Pointer<ffi.Char> )>()
external int git_revwalk_hide_ref(ffi.Pointer<git_revwalk> walk,
ffi.Pointer<ffi.Char> refname,
);

/// Get the next commit from the revision walk.
/// 
/// The initial call to this method is *not* blocking when
/// iterating through a repo with a time-sorting mode.
/// 
/// Iterating with Topological or inverted modes makes the initial
/// call blocking to preprocess the commit list, but this block should be
/// mostly unnoticeable on most repositories (topological preprocessing
/// times at 0.3s on the git.git repo).
/// 
/// The revision walker is reset when the walk is over.
/// 
/// @param out Pointer where to store the oid of the next commit
/// @param walk the walker to pop the commit from.
/// @return 0 if the next commit was found;
/// GIT_ITEROVER if there are no commits left to iterate
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_revwalk> )>()
external int git_revwalk_next(ffi.Pointer<git_oid> out,
ffi.Pointer<git_revwalk> walk,
);

/// Change the sorting mode when iterating through the
/// repository's contents.
/// 
/// Changing the sorting mode resets the walker.
/// 
/// @param walk the walker being used for the traversal.
/// @param sort_mode combination of GIT_SORT_XXX flags
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_revwalk> , ffi.UnsignedInt )>()
external int git_revwalk_sorting(ffi.Pointer<git_revwalk> walk,
int sort_mode,
);

/// Push and hide the respective endpoints of the given range.
/// 
/// The range should be of the form
/// <commit>..<commit>
/// where each <commit> is in the form accepted by 'git_revparse_single'.
/// The left-hand commit will be hidden and the right-hand commit pushed.
/// 
/// @param walk the walker being used for the traversal
/// @param range the range
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_revwalk> , ffi.Pointer<ffi.Char> )>()
external int git_revwalk_push_range(ffi.Pointer<git_revwalk> walk,
ffi.Pointer<ffi.Char> range,
);

/// Simplify the history by first-parent
/// 
/// No parents other than the first for each commit will be enqueued.
/// 
/// @param walk The revision walker.
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_revwalk> )>()
external int git_revwalk_simplify_first_parent(ffi.Pointer<git_revwalk> walk,
);

/// Free a revision walker previously allocated.
/// 
/// @param walk traversal handle to close. If NULL nothing occurs.
@ffi.Native<ffi.Void Function(ffi.Pointer<git_revwalk> )>()
external void git_revwalk_free(ffi.Pointer<git_revwalk> walk,
);

/// Return the repository on which this walker
/// is operating.
/// 
/// @param walk the revision walker
/// @return the repository being walked
@ffi.Native<ffi.Pointer<git_repository> Function(ffi.Pointer<git_revwalk> )>()
external ffi.Pointer<git_repository> git_revwalk_repository(ffi.Pointer<git_revwalk> walk,
);

/// Adds, changes or removes a callback function to hide a commit and its parents
/// 
/// @param walk the revision walker
/// @param hide_cb  callback function to hide a commit and its parents
/// @param payload  data payload to be passed to callback function
/// @return 0 or an error code.
@ffi.Native<ffi.Int Function(ffi.Pointer<git_revwalk> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_oid> commit_id, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_revwalk_add_hide_cb(ffi.Pointer<git_revwalk> walk,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_oid> commit_id, ffi.Pointer<ffi.Void> payload)>> hide_cb,
ffi.Pointer<ffi.Void> payload,
);

/// Create a new action signature.
/// 
/// Call `git_signature_free()` to free the data.
/// 
/// Note: angle brackets ('<' and '>') characters are not allowed
/// to be used in either the `name` or the `email` parameter.
/// 
/// @param out new signature, in case of error NULL
/// @param name name of the person
/// @param email email of the person
/// @param time time (in seconds from epoch) when the action happened
/// @param offset timezone offset (in minutes) for the time
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_signature>> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Int64 , ffi.Int )>()
external int git_signature_new(ffi.Pointer<ffi.Pointer<git_signature>> out,
ffi.Pointer<ffi.Char> name,
ffi.Pointer<ffi.Char> email,
int time,
int offset,
);

/// Create a new action signature with a timestamp of 'now'.
/// 
/// Call `git_signature_free()` to free the data.
/// 
/// @param out new signature, in case of error NULL
/// @param name name of the person
/// @param email email of the person
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_signature>> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> )>()
external int git_signature_now(ffi.Pointer<ffi.Pointer<git_signature>> out,
ffi.Pointer<ffi.Char> name,
ffi.Pointer<ffi.Char> email,
);

/// Create a new author and/or committer signatures with default
/// information based on the configuration and environment variables.
/// 
/// If `author_out` is set, it will be populated with the author
/// information. The `GIT_AUTHOR_NAME` and `GIT_AUTHOR_EMAIL`
/// environment variables will be honored, and `user.name` and
/// `user.email` configuration options will be honored if the
/// environment variables are unset. For timestamps, `GIT_AUTHOR_DATE`
/// will be used, otherwise the current time will be used.
/// 
/// If `committer_out` is set, it will be populated with the
/// committer information. The `GIT_COMMITTER_NAME` and
/// `GIT_COMMITTER_EMAIL` environment variables will be honored,
/// and `user.name` and `user.email` configuration options will
/// be honored if the environment variables are unset. For timestamps,
/// `GIT_COMMITTER_DATE` will be used, otherwise the current time will
/// be used.
/// 
/// If neither `GIT_AUTHOR_DATE` nor `GIT_COMMITTER_DATE` are set,
/// both timestamps will be set to the same time.
/// 
/// It will return `GIT_ENOTFOUND` if either the `user.name` or
/// `user.email` are not set and there is no fallback from an environment
/// variable. One of `author_out` or `committer_out` must be set.
/// 
/// @param author_out pointer to set the author signature, or NULL
/// @param committer_out pointer to set the committer signature, or NULL
/// @param repo repository pointer
/// @return 0 on success, GIT_ENOTFOUND if config is missing, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_signature>> , ffi.Pointer<ffi.Pointer<git_signature>> , ffi.Pointer<git_repository> )>()
external int git_signature_default_from_env(ffi.Pointer<ffi.Pointer<git_signature>> author_out,
ffi.Pointer<ffi.Pointer<git_signature>> committer_out,
ffi.Pointer<git_repository> repo,
);

/// Create a new action signature with default user and now timestamp.
/// 
/// This looks up the user.name and user.email from the configuration and
/// uses the current time as the timestamp, and creates a new signature
/// based on that information.  It will return GIT_ENOTFOUND if either the
/// user.name or user.email are not set.
/// 
/// Note that these do not examine environment variables, only the
/// configuration files. Use `git_signature_default_from_env` to
/// consider the environment variables.
/// 
/// @param out new signature
/// @param repo repository pointer
/// @return 0 on success, GIT_ENOTFOUND if config is missing, or error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_signature>> , ffi.Pointer<git_repository> )>()
external int git_signature_default(ffi.Pointer<ffi.Pointer<git_signature>> out,
ffi.Pointer<git_repository> repo,
);

/// Create a new signature by parsing the given buffer, which is
/// expected to be in the format "Real Name <email> timestamp tzoffset",
/// where `timestamp` is the number of seconds since the Unix epoch and
/// `tzoffset` is the timezone offset in `hhmm` format (note the lack
/// of a colon separator).
/// 
/// @param out new signature
/// @param buf signature string
/// @return 0 on success, GIT_EINVALID if the signature is not parseable, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_signature>> , ffi.Pointer<ffi.Char> )>()
external int git_signature_from_buffer(ffi.Pointer<ffi.Pointer<git_signature>> out,
ffi.Pointer<ffi.Char> buf,
);

/// Create a copy of an existing signature.  All internal strings are also
/// duplicated.
/// 
/// Call `git_signature_free()` to free the data.
/// 
/// @param dest pointer where to store the copy
/// @param sig signature to duplicate
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_signature>> , ffi.Pointer<git_signature> )>()
external int git_signature_dup(ffi.Pointer<ffi.Pointer<git_signature>> dest,
ffi.Pointer<git_signature> sig,
);

/// Free an existing signature.
/// 
/// Because the signature is not an opaque structure, it is legal to free it
/// manually, but be sure to free the "name" and "email" strings in addition
/// to the structure itself.
/// 
/// @param sig signature to free
@ffi.Native<ffi.Void Function(ffi.Pointer<git_signature> )>()
external void git_signature_free(ffi.Pointer<git_signature> sig,
);

/// Lookup a tag object from the repository.
/// 
/// @param out pointer to the looked up tag
/// @param repo the repo to use when locating the tag.
/// @param id identity of the tag to locate.
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_tag>> , ffi.Pointer<git_repository> , ffi.Pointer<git_oid> )>()
external int git_tag_lookup(ffi.Pointer<ffi.Pointer<git_tag>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_oid> id,
);

/// Lookup a tag object from the repository,
/// given a prefix of its identifier (short id).
/// 
/// @see git_object_lookup_prefix
/// 
/// @param out pointer to the looked up tag
/// @param repo the repo to use when locating the tag.
/// @param id identity of the tag to locate.
/// @param len the length of the short identifier
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_tag>> , ffi.Pointer<git_repository> , ffi.Pointer<git_oid> , ffi.Size )>()
external int git_tag_lookup_prefix(ffi.Pointer<ffi.Pointer<git_tag>> out,
ffi.Pointer<git_repository> repo,
ffi.Pointer<git_oid> id,
int len,
);

/// Close an open tag
/// 
/// You can no longer use the git_tag pointer after this call.
/// 
/// IMPORTANT: You MUST call this method when you are through with a tag to
/// release memory. Failure to do so will cause a memory leak.
/// 
/// @param tag the tag to close
@ffi.Native<ffi.Void Function(ffi.Pointer<git_tag> )>()
external void git_tag_free(ffi.Pointer<git_tag> tag,
);

/// Get the id of a tag.
/// 
/// @param tag a previously loaded tag.
/// @return object identity for the tag.
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_tag> )>()
external ffi.Pointer<git_oid> git_tag_id(ffi.Pointer<git_tag> tag,
);

/// Get the repository that contains the tag.
/// 
/// @param tag A previously loaded tag.
/// @return Repository that contains this tag.
@ffi.Native<ffi.Pointer<git_repository> Function(ffi.Pointer<git_tag> )>()
external ffi.Pointer<git_repository> git_tag_owner(ffi.Pointer<git_tag> tag,
);

/// Get the tagged object of a tag
/// 
/// This method performs a repository lookup for the
/// given object and returns it
/// 
/// @param target_out pointer where to store the target
/// @param tag a previously loaded tag.
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_object>> , ffi.Pointer<git_tag> )>()
external int git_tag_target(ffi.Pointer<ffi.Pointer<git_object>> target_out,
ffi.Pointer<git_tag> tag,
);

/// Get the OID of the tagged object of a tag
/// 
/// @param tag a previously loaded tag.
/// @return pointer to the OID
@ffi.Native<ffi.Pointer<git_oid> Function(ffi.Pointer<git_tag> )>()
external ffi.Pointer<git_oid> git_tag_target_id(ffi.Pointer<git_tag> tag,
);

/// Get the type of a tag's tagged object
/// 
/// @param tag a previously loaded tag.
/// @return type of the tagged object
@ffi.Native<ffi.Int Function(ffi.Pointer<git_tag> )>(symbol: 'git_tag_target_type')
external int _git_tag_target_type(ffi.Pointer<git_tag> tag,
);

git_object_t git_tag_target_type(ffi.Pointer<git_tag> tag,
) => git_object_t.fromValue(_git_tag_target_type(tag,
));

/// Get the name of a tag
/// 
/// @param tag a previously loaded tag.
/// @return name of the tag
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_tag> )>()
external ffi.Pointer<ffi.Char> git_tag_name(ffi.Pointer<git_tag> tag,
);

/// Get the tagger (author) of a tag
/// 
/// @param tag a previously loaded tag.
/// @return reference to the tag's author or NULL when unspecified
@ffi.Native<ffi.Pointer<git_signature> Function(ffi.Pointer<git_tag> )>()
external ffi.Pointer<git_signature> git_tag_tagger(ffi.Pointer<git_tag> tag,
);

/// Get the message of a tag
/// 
/// @param tag a previously loaded tag.
/// @return message of the tag or NULL when unspecified
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_tag> )>()
external ffi.Pointer<ffi.Char> git_tag_message(ffi.Pointer<git_tag> tag,
);

/// Create a new tag in the repository from an object
/// 
/// A new reference will also be created pointing to
/// this tag object. If `force` is true and a reference
/// already exists with the given name, it'll be replaced.
/// 
/// The message will not be cleaned up. This can be achieved
/// through `git_message_prettify()`.
/// 
/// The tag name will be checked for validity. You must avoid
/// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
/// sequences ".." and "@{" which have special meaning to revparse.
/// 
/// @param oid Pointer where to store the OID of the
/// newly created tag. If the tag already exists, this parameter
/// will be the oid of the existing tag, and the function will
/// return a GIT_EEXISTS error code.
/// 
/// @param repo Repository where to store the tag
/// 
/// @param tag_name Name for the tag; this name is validated
/// for consistency. It should also not conflict with an
/// already existing tag name
/// 
/// @param target Object to which this tag points. This object
/// must belong to the given `repo`.
/// 
/// @param tagger Signature of the tagger for this tag, and
/// of the tagging time
/// 
/// @param message Full message for this tag
/// 
/// @param force Overwrite existing references
/// 
/// @return 0 on success, GIT_EINVALIDSPEC or an error code
/// A tag object is written to the ODB, and a proper reference
/// is written in the /refs/tags folder, pointing to it
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_object> , ffi.Pointer<git_signature> , ffi.Pointer<ffi.Char> , ffi.Int )>()
external int git_tag_create(ffi.Pointer<git_oid> oid,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> tag_name,
ffi.Pointer<git_object> target,
ffi.Pointer<git_signature> tagger,
ffi.Pointer<ffi.Char> message,
int force,
);

/// Create a new tag in the object database pointing to a git_object
/// 
/// The message will not be cleaned up. This can be achieved
/// through `git_message_prettify()`.
/// 
/// @param oid Pointer where to store the OID of the
/// newly created tag
/// 
/// @param repo Repository where to store the tag
/// 
/// @param tag_name Name for the tag
/// 
/// @param target Object to which this tag points. This object
/// must belong to the given `repo`.
/// 
/// @param tagger Signature of the tagger for this tag, and
/// of the tagging time
/// 
/// @param message Full message for this tag
/// 
/// @return 0 on success or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_object> , ffi.Pointer<git_signature> , ffi.Pointer<ffi.Char> )>()
external int git_tag_annotation_create(ffi.Pointer<git_oid> oid,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> tag_name,
ffi.Pointer<git_object> target,
ffi.Pointer<git_signature> tagger,
ffi.Pointer<ffi.Char> message,
);

/// Create a new tag in the repository from a buffer
/// 
/// @param oid Pointer where to store the OID of the newly created tag
/// @param repo Repository where to store the tag
/// @param buffer Raw tag data
/// @param force Overwrite existing tags
/// @return 0 on success; error code otherwise
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Int )>()
external int git_tag_create_from_buffer(ffi.Pointer<git_oid> oid,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> buffer,
int force,
);

/// Create a new lightweight tag pointing at a target object
/// 
/// A new direct reference will be created pointing to
/// this target object. If `force` is true and a reference
/// already exists with the given name, it'll be replaced.
/// 
/// The tag name will be checked for validity.
/// See `git_tag_create()` for rules about valid names.
/// 
/// @param oid Pointer where to store the OID of the provided
/// target object. If the tag already exists, this parameter
/// will be filled with the oid of the existing pointed object
/// and the function will return a GIT_EEXISTS error code.
/// 
/// @param repo Repository where to store the lightweight tag
/// 
/// @param tag_name Name for the tag; this name is validated
/// for consistency. It should also not conflict with an
/// already existing tag name
/// 
/// @param target Object to which this tag points. This object
/// must belong to the given `repo`.
/// 
/// @param force Overwrite existing references
/// 
/// @return 0 on success, GIT_EINVALIDSPEC or an error code
/// A proper reference is written in the /refs/tags folder,
/// pointing to the provided target object
@ffi.Native<ffi.Int Function(ffi.Pointer<git_oid> , ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_object> , ffi.Int )>()
external int git_tag_create_lightweight(ffi.Pointer<git_oid> oid,
ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> tag_name,
ffi.Pointer<git_object> target,
int force,
);

/// Delete an existing tag reference.
/// 
/// The tag name will be checked for validity.
/// See `git_tag_create()` for rules about valid names.
/// 
/// @param repo Repository where lives the tag
/// 
/// @param tag_name Name of the tag to be deleted;
/// this name is validated for consistency.
/// 
/// @return 0 on success, GIT_EINVALIDSPEC or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.Char> )>()
external int git_tag_delete(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.Char> tag_name,
);

/// Fill a list with all the tags in the Repository
/// 
/// The string array will be filled with the names of the
/// matching tags; these values are owned by the user and
/// should be free'd manually when no longer needed, using
/// `git_strarray_free`.
/// 
/// @param tag_names Pointer to a git_strarray structure where
/// the tag names will be stored
/// @param repo Repository where to find the tags
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_strarray> , ffi.Pointer<git_repository> )>()
external int git_tag_list(ffi.Pointer<git_strarray> tag_names,
ffi.Pointer<git_repository> repo,
);

/// Fill a list with all the tags in the Repository
/// which name match a defined pattern
/// 
/// If an empty pattern is provided, all the tags
/// will be returned.
/// 
/// The string array will be filled with the names of the
/// matching tags; these values are owned by the user and
/// should be free'd manually when no longer needed, using
/// `git_strarray_free`.
/// 
/// @param tag_names Pointer to a git_strarray structure where
/// the tag names will be stored
/// @param pattern Standard fnmatch pattern
/// @param repo Repository where to find the tags
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_strarray> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_repository> )>()
external int git_tag_list_match(ffi.Pointer<git_strarray> tag_names,
ffi.Pointer<ffi.Char> pattern,
ffi.Pointer<git_repository> repo,
);

/// Call callback `cb' for each tag in the repository
/// 
/// @param repo Repository
/// @param callback Callback function
/// @param payload Pointer to callback data (optional)
/// @return 0 on success or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_repository> , ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> name, ffi.Pointer<git_oid> oid, ffi.Pointer<ffi.Void> payload)>> , ffi.Pointer<ffi.Void> )>()
external int git_tag_foreach(ffi.Pointer<git_repository> repo,
ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> name, ffi.Pointer<git_oid> oid, ffi.Pointer<ffi.Void> payload)>> callback,
ffi.Pointer<ffi.Void> payload,
);

/// Recursively peel a tag until a non tag git_object is found
/// 
/// The retrieved `tag_target` object is owned by the repository
/// and should be closed with the `git_object_free` method.
/// 
/// @param tag_target_out Pointer to the peeled git_object
/// @param tag The tag to be processed
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_object>> , ffi.Pointer<git_tag> )>()
external int git_tag_peel(ffi.Pointer<ffi.Pointer<git_object>> tag_target_out,
ffi.Pointer<git_tag> tag,
);

/// Create an in-memory copy of a tag. The copy must be explicitly
/// free'd or it will leak.
/// 
/// @param out Pointer to store the copy of the tag
/// @param source Original tag to copy
/// @return 0
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_tag>> , ffi.Pointer<git_tag> )>()
external int git_tag_dup(ffi.Pointer<ffi.Pointer<git_tag>> out,
ffi.Pointer<git_tag> source,
);

/// Determine whether a tag name is valid, meaning that (when prefixed
/// with `refs/tags/`) that it is a valid reference name, and that any
/// additional tag name restrictions are imposed (eg, it cannot start
/// with a `-`).
/// 
/// @param valid output pointer to set with validity of given tag name
/// @param name a tag name to test
/// @return 0 on success or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Int> , ffi.Pointer<ffi.Char> )>()
external int git_tag_name_is_valid(ffi.Pointer<ffi.Int> valid,
ffi.Pointer<ffi.Char> name,
);

/// Create a new transaction object
/// 
/// This does not lock anything, but sets up the transaction object to
/// know from which repository to lock.
/// 
/// @param out the resulting transaction
/// @param repo the repository in which to lock
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_transaction>> , ffi.Pointer<git_repository> )>()
external int git_transaction_new(ffi.Pointer<ffi.Pointer<git_transaction>> out,
ffi.Pointer<git_repository> repo,
);

/// Lock a reference
/// 
/// Lock the specified reference. This is the first step to updating a
/// reference.
/// 
/// @param tx the transaction
/// @param refname the reference to lock
/// @return 0 or an error message
@ffi.Native<ffi.Int Function(ffi.Pointer<git_transaction> , ffi.Pointer<ffi.Char> )>()
external int git_transaction_lock_ref(ffi.Pointer<git_transaction> tx,
ffi.Pointer<ffi.Char> refname,
);

/// Set the target of a reference
/// 
/// Set the target of the specified reference. This reference must be
/// locked.
/// 
/// @param tx the transaction
/// @param refname reference to update
/// @param target target to set the reference to
/// @param sig signature to use in the reflog; pass NULL to read the identity from the config
/// @param msg message to use in the reflog
/// @return 0, GIT_ENOTFOUND if the reference is not among the locked ones, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_transaction> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_oid> , ffi.Pointer<git_signature> , ffi.Pointer<ffi.Char> )>()
external int git_transaction_set_target(ffi.Pointer<git_transaction> tx,
ffi.Pointer<ffi.Char> refname,
ffi.Pointer<git_oid> target,
ffi.Pointer<git_signature> sig,
ffi.Pointer<ffi.Char> msg,
);

/// Set the target of a reference
/// 
/// Set the target of the specified reference. This reference must be
/// locked.
/// 
/// @param tx the transaction
/// @param refname reference to update
/// @param target target to set the reference to
/// @param sig signature to use in the reflog; pass NULL to read the identity from the config
/// @param msg message to use in the reflog
/// @return 0, GIT_ENOTFOUND if the reference is not among the locked ones, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_transaction> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_signature> , ffi.Pointer<ffi.Char> )>()
external int git_transaction_set_symbolic_target(ffi.Pointer<git_transaction> tx,
ffi.Pointer<ffi.Char> refname,
ffi.Pointer<ffi.Char> target,
ffi.Pointer<git_signature> sig,
ffi.Pointer<ffi.Char> msg,
);

/// Set the reflog of a reference
/// 
/// Set the specified reference's reflog. If this is combined with
/// setting the target, that update won't be written to the reflog.
/// 
/// @param tx the transaction
/// @param refname the reference whose reflog to set
/// @param reflog the reflog as it should be written out
/// @return 0, GIT_ENOTFOUND if the reference is not among the locked ones, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_transaction> , ffi.Pointer<ffi.Char> , ffi.Pointer<git_reflog> )>()
external int git_transaction_set_reflog(ffi.Pointer<git_transaction> tx,
ffi.Pointer<ffi.Char> refname,
ffi.Pointer<git_reflog> reflog,
);

/// Remove a reference
/// 
/// @param tx the transaction
/// @param refname the reference to remove
/// @return 0, GIT_ENOTFOUND if the reference is not among the locked ones, or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_transaction> , ffi.Pointer<ffi.Char> )>()
external int git_transaction_remove(ffi.Pointer<git_transaction> tx,
ffi.Pointer<ffi.Char> refname,
);

/// Commit the changes from the transaction
/// 
/// Perform the changes that have been queued. The updates will be made
/// one by one, and the first failure will stop the processing.
/// 
/// @param tx the transaction
/// @return 0 or an error code
@ffi.Native<ffi.Int Function(ffi.Pointer<git_transaction> )>()
external int git_transaction_commit(ffi.Pointer<git_transaction> tx,
);

/// Free the resources allocated by this transaction
/// 
/// If any references remain locked, they will be unlocked without any
/// changes made to them.
/// 
/// @param tx the transaction
@ffi.Native<ffi.Void Function(ffi.Pointer<git_transaction> )>()
external void git_transaction_free(ffi.Pointer<git_transaction> tx,
);

/// Configurable features of libgit2; either optional settings (like
/// threading), or features that can be enabled by one of a number of
/// different backend "providers" (like HTTPS, which can be provided by
/// OpenSSL, mbedTLS, or system libraries).
enum git_feature_t {
  /// libgit2 is thread-aware and can be used from multiple threads
  /// (as described in the documentation).
  GIT_FEATURE_THREADS(1),
  /// HTTPS remotes
  GIT_FEATURE_HTTPS(2),
  /// SSH remotes
  GIT_FEATURE_SSH(4),
  /// Sub-second resolution in index timestamps
  GIT_FEATURE_NSEC(8),
  /// HTTP parsing; always available
  GIT_FEATURE_HTTP_PARSER(16),
  /// Regular expression support; always available
  GIT_FEATURE_REGEX(32),
  /// Internationalization support for filename translation
  GIT_FEATURE_I18N(64),
  /// NTLM support over HTTPS
  GIT_FEATURE_AUTH_NTLM(128),
  /// Kerberos (SPNEGO) authentication support over HTTPS
  GIT_FEATURE_AUTH_NEGOTIATE(256),
  /// zlib support; always available
  GIT_FEATURE_COMPRESSION(512),
  /// SHA1 object support; always available
  GIT_FEATURE_SHA1(1024),
  /// SHA256 object support
  GIT_FEATURE_SHA256(2048);


  final int value;
  const git_feature_t(this.value);

  static git_feature_t fromValue(int value) => switch (value) {
    1 => GIT_FEATURE_THREADS,
    2 => GIT_FEATURE_HTTPS,
    4 => GIT_FEATURE_SSH,
    8 => GIT_FEATURE_NSEC,
    16 => GIT_FEATURE_HTTP_PARSER,
    32 => GIT_FEATURE_REGEX,
    64 => GIT_FEATURE_I18N,
    128 => GIT_FEATURE_AUTH_NTLM,
    256 => GIT_FEATURE_AUTH_NEGOTIATE,
    512 => GIT_FEATURE_COMPRESSION,
    1024 => GIT_FEATURE_SHA1,
    2048 => GIT_FEATURE_SHA256,
    _ => throw ArgumentError('Unknown value for git_feature_t: $value'),
  };

}

/// Global library options
/// 
/// These are used to select which global option to set or get and are
/// used in `git_libgit2_opts()`.
enum git_libgit2_opt_t {
  GIT_OPT_GET_MWINDOW_SIZE(0),
  GIT_OPT_SET_MWINDOW_SIZE(1),
  GIT_OPT_GET_MWINDOW_MAPPED_LIMIT(2),
  GIT_OPT_SET_MWINDOW_MAPPED_LIMIT(3),
  GIT_OPT_GET_SEARCH_PATH(4),
  GIT_OPT_SET_SEARCH_PATH(5),
  GIT_OPT_SET_CACHE_OBJECT_LIMIT(6),
  GIT_OPT_SET_CACHE_MAX_SIZE(7),
  GIT_OPT_ENABLE_CACHING(8),
  GIT_OPT_GET_CACHED_MEMORY(9),
  GIT_OPT_GET_TEMPLATE_PATH(10),
  GIT_OPT_SET_TEMPLATE_PATH(11),
  GIT_OPT_SET_SSL_CERT_LOCATIONS(12),
  GIT_OPT_SET_USER_AGENT(13),
  GIT_OPT_ENABLE_STRICT_OBJECT_CREATION(14),
  GIT_OPT_ENABLE_STRICT_SYMBOLIC_REF_CREATION(15),
  GIT_OPT_SET_SSL_CIPHERS(16),
  GIT_OPT_GET_USER_AGENT(17),
  GIT_OPT_ENABLE_OFS_DELTA(18),
  GIT_OPT_ENABLE_FSYNC_GITDIR(19),
  GIT_OPT_GET_WINDOWS_SHAREMODE(20),
  GIT_OPT_SET_WINDOWS_SHAREMODE(21),
  GIT_OPT_ENABLE_STRICT_HASH_VERIFICATION(22),
  GIT_OPT_SET_ALLOCATOR(23),
  GIT_OPT_ENABLE_UNSAVED_INDEX_SAFETY(24),
  GIT_OPT_GET_PACK_MAX_OBJECTS(25),
  GIT_OPT_SET_PACK_MAX_OBJECTS(26),
  GIT_OPT_DISABLE_PACK_KEEP_FILE_CHECKS(27),
  GIT_OPT_ENABLE_HTTP_EXPECT_CONTINUE(28),
  GIT_OPT_GET_MWINDOW_FILE_LIMIT(29),
  GIT_OPT_SET_MWINDOW_FILE_LIMIT(30),
  GIT_OPT_SET_ODB_PACKED_PRIORITY(31),
  GIT_OPT_SET_ODB_LOOSE_PRIORITY(32),
  GIT_OPT_GET_EXTENSIONS(33),
  GIT_OPT_SET_EXTENSIONS(34),
  GIT_OPT_GET_OWNER_VALIDATION(35),
  GIT_OPT_SET_OWNER_VALIDATION(36),
  GIT_OPT_GET_HOMEDIR(37),
  GIT_OPT_SET_HOMEDIR(38),
  GIT_OPT_SET_SERVER_CONNECT_TIMEOUT(39),
  GIT_OPT_GET_SERVER_CONNECT_TIMEOUT(40),
  GIT_OPT_SET_SERVER_TIMEOUT(41),
  GIT_OPT_GET_SERVER_TIMEOUT(42),
  GIT_OPT_SET_USER_AGENT_PRODUCT(43),
  GIT_OPT_GET_USER_AGENT_PRODUCT(44),
  GIT_OPT_ADD_SSL_X509_CERT(45);


  final int value;
  const git_libgit2_opt_t(this.value);

  static git_libgit2_opt_t fromValue(int value) => switch (value) {
    0 => GIT_OPT_GET_MWINDOW_SIZE,
    1 => GIT_OPT_SET_MWINDOW_SIZE,
    2 => GIT_OPT_GET_MWINDOW_MAPPED_LIMIT,
    3 => GIT_OPT_SET_MWINDOW_MAPPED_LIMIT,
    4 => GIT_OPT_GET_SEARCH_PATH,
    5 => GIT_OPT_SET_SEARCH_PATH,
    6 => GIT_OPT_SET_CACHE_OBJECT_LIMIT,
    7 => GIT_OPT_SET_CACHE_MAX_SIZE,
    8 => GIT_OPT_ENABLE_CACHING,
    9 => GIT_OPT_GET_CACHED_MEMORY,
    10 => GIT_OPT_GET_TEMPLATE_PATH,
    11 => GIT_OPT_SET_TEMPLATE_PATH,
    12 => GIT_OPT_SET_SSL_CERT_LOCATIONS,
    13 => GIT_OPT_SET_USER_AGENT,
    14 => GIT_OPT_ENABLE_STRICT_OBJECT_CREATION,
    15 => GIT_OPT_ENABLE_STRICT_SYMBOLIC_REF_CREATION,
    16 => GIT_OPT_SET_SSL_CIPHERS,
    17 => GIT_OPT_GET_USER_AGENT,
    18 => GIT_OPT_ENABLE_OFS_DELTA,
    19 => GIT_OPT_ENABLE_FSYNC_GITDIR,
    20 => GIT_OPT_GET_WINDOWS_SHAREMODE,
    21 => GIT_OPT_SET_WINDOWS_SHAREMODE,
    22 => GIT_OPT_ENABLE_STRICT_HASH_VERIFICATION,
    23 => GIT_OPT_SET_ALLOCATOR,
    24 => GIT_OPT_ENABLE_UNSAVED_INDEX_SAFETY,
    25 => GIT_OPT_GET_PACK_MAX_OBJECTS,
    26 => GIT_OPT_SET_PACK_MAX_OBJECTS,
    27 => GIT_OPT_DISABLE_PACK_KEEP_FILE_CHECKS,
    28 => GIT_OPT_ENABLE_HTTP_EXPECT_CONTINUE,
    29 => GIT_OPT_GET_MWINDOW_FILE_LIMIT,
    30 => GIT_OPT_SET_MWINDOW_FILE_LIMIT,
    31 => GIT_OPT_SET_ODB_PACKED_PRIORITY,
    32 => GIT_OPT_SET_ODB_LOOSE_PRIORITY,
    33 => GIT_OPT_GET_EXTENSIONS,
    34 => GIT_OPT_SET_EXTENSIONS,
    35 => GIT_OPT_GET_OWNER_VALIDATION,
    36 => GIT_OPT_SET_OWNER_VALIDATION,
    37 => GIT_OPT_GET_HOMEDIR,
    38 => GIT_OPT_SET_HOMEDIR,
    39 => GIT_OPT_SET_SERVER_CONNECT_TIMEOUT,
    40 => GIT_OPT_GET_SERVER_CONNECT_TIMEOUT,
    41 => GIT_OPT_SET_SERVER_TIMEOUT,
    42 => GIT_OPT_GET_SERVER_TIMEOUT,
    43 => GIT_OPT_SET_USER_AGENT_PRODUCT,
    44 => GIT_OPT_GET_USER_AGENT_PRODUCT,
    45 => GIT_OPT_ADD_SSL_X509_CERT,
    _ => throw ArgumentError('Unknown value for git_libgit2_opt_t: $value'),
  };

}

/// A data buffer for exporting data from libgit2
/// 
/// Sometimes libgit2 wants to return an allocated data buffer to the
/// caller and have the caller take responsibility for freeing that memory.
/// To make ownership clear in these cases, libgit2 uses  `git_buf` to
/// return this data.  Callers should use `git_buf_dispose()` to release
/// the memory when they are done.
/// 
/// A `git_buf` contains a pointer to a NUL-terminated C string, and
/// the length of the string (not including the NUL terminator).
final class git_buf extends ffi.Struct{
  /// The buffer contents.  `ptr` points to the start of the buffer
  /// being returned.  The buffer's length (in bytes) is specified
  /// by the `size` member of the structure, and contains a NUL
  /// terminator at position `(size + 1)`.
  external ffi.Pointer<ffi.Char> ptr;

  /// This field is reserved and unused.
  @ffi.Size()
  external int reserved;

  /// The length (in bytes) of the buffer pointed to by `ptr`,
  /// not including a NUL terminator.
  @ffi.Size()
  external int size;

}

/// The type of object id.
enum git_oid_t {
  /// < SHA1
  GIT_OID_SHA1(1);


  final int value;
  const git_oid_t(this.value);

  static git_oid_t fromValue(int value) => switch (value) {
    1 => GIT_OID_SHA1,
    _ => throw ArgumentError('Unknown value for git_oid_t: $value'),
  };

}

/// Unique identity of any object (commit, tree, blob, tag).
final class git_oid extends ffi.Struct{
  /// raw binary formatted id
@ffi.Array.multi([20])
  external ffi.Array<ffi.UnsignedChar> id;

}

final class git_oid_shorten extends ffi.Opaque{
}

/// Basic type (loose or packed) of any Git object.
enum git_object_t {
  /// < Object can be any of the following
  GIT_OBJECT_ANY(-2),
  /// < Object is invalid.
  GIT_OBJECT_INVALID(-1),
  /// < A commit object.
  GIT_OBJECT_COMMIT(1),
  /// < A tree (directory listing) object.
  GIT_OBJECT_TREE(2),
  /// < A file revision object.
  GIT_OBJECT_BLOB(3),
  /// < An annotated tag object.
  GIT_OBJECT_TAG(4),
  /// < A delta, base is given by an offset.
  GIT_OBJECT_OFS_DELTA(6),
  /// < A delta, base is given by object id.
  GIT_OBJECT_REF_DELTA(7);


  final int value;
  const git_object_t(this.value);

  static git_object_t fromValue(int value) => switch (value) {
    -2 => GIT_OBJECT_ANY,
    -1 => GIT_OBJECT_INVALID,
    1 => GIT_OBJECT_COMMIT,
    2 => GIT_OBJECT_TREE,
    3 => GIT_OBJECT_BLOB,
    4 => GIT_OBJECT_TAG,
    6 => GIT_OBJECT_OFS_DELTA,
    7 => GIT_OBJECT_REF_DELTA,
    _ => throw ArgumentError('Unknown value for git_object_t: $value'),
  };

}

final class git_odb extends ffi.Opaque{
}

final class git_odb_backend extends ffi.Opaque{
}

final class git_odb_object extends ffi.Opaque{
}

/// A stream to read/write from a backend.
/// 
/// This represents a stream of data being written to or read from a
/// backend. When writing, the frontend functions take care of
/// calculating the object's id and all `finalize_write` needs to do is
/// store the object with the id it is passed.
final class git_odb_stream extends ffi.Struct{
  external ffi.Pointer<git_odb_backend> backend;

  @ffi.UnsignedInt()
  external int mode;

  external ffi.Pointer<ffi.Void> hash_ctx;

  @ffi.Uint64()
  external int declared_size;

  @ffi.Uint64()
  external int received_bytes;

  /// Write at most `len` bytes into `buffer` and advance the stream.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_odb_stream> stream, ffi.Pointer<ffi.Char> buffer, ffi.Size len)>> read;

  /// Write `len` bytes from `buffer` into the stream.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_odb_stream> stream, ffi.Pointer<ffi.Char> buffer, ffi.Size len)>> write;

  /// Store the contents of the stream as an object with the id
  /// specified in `oid`.
  /// 
  /// This method might not be invoked if:
  /// - an error occurs earlier with the `write` callback,
  /// - the object referred to by `oid` already exists in any backend, or
  /// - the final number of received bytes differs from the size declared
  /// with `git_odb_open_wstream()`
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_odb_stream> stream, ffi.Pointer<git_oid> oid)>> finalize_write;

  /// Free the stream's memory.
  /// 
  /// This method might be called without a call to `finalize_write` if
  /// an error occurs or if the object is already present in the ODB.
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_odb_stream> stream)>> free;

}

/// This structure is used to provide callers information about the
/// progress of indexing a packfile, either directly or part of a
/// fetch or clone that downloads a packfile.
final class git_indexer_progress extends ffi.Struct{
  /// number of objects in the packfile being indexed
  @ffi.UnsignedInt()
  external int total_objects;

  /// received objects that have been hashed
  @ffi.UnsignedInt()
  external int indexed_objects;

  /// received_objects: objects which have been downloaded
  @ffi.UnsignedInt()
  external int received_objects;

  /// locally-available objects that have been injected in order
  /// to fix a thin pack
  @ffi.UnsignedInt()
  external int local_objects;

  /// number of deltas in the packfile being indexed
  @ffi.UnsignedInt()
  external int total_deltas;

  /// received deltas that have been indexed
  @ffi.UnsignedInt()
  external int indexed_deltas;

  /// size of the packfile received up to now
  @ffi.Size()
  external int received_bytes;

}

/// A stream to write a pack file to the ODB
final class git_odb_writepack extends ffi.Struct{
  external ffi.Pointer<git_odb_backend> backend;

  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_odb_writepack> writepack, ffi.Pointer<ffi.Void> data, ffi.Size size, ffi.Pointer<git_indexer_progress> stats)>> append;

  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_odb_writepack> writepack, ffi.Pointer<git_indexer_progress> stats)>> commit;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_odb_writepack> writepack)>> free;

}

final class git_midx_writer extends ffi.Opaque{
}

final class git_refdb extends ffi.Opaque{
}

final class git_refdb_backend extends ffi.Opaque{
}

final class git_commit_graph extends ffi.Opaque{
}

final class git_commit_graph_writer extends ffi.Opaque{
}

final class git_repository extends ffi.Opaque{
}

final class git_worktree extends ffi.Opaque{
}

final class git_object extends ffi.Opaque{
}

final class git_revwalk extends ffi.Opaque{
}

final class git_tag extends ffi.Opaque{
}

final class git_blob extends ffi.Opaque{
}

final class git_commit extends ffi.Opaque{
}

final class git_tree_entry extends ffi.Opaque{
}

final class git_tree extends ffi.Opaque{
}

final class git_treebuilder extends ffi.Opaque{
}

final class git_index extends ffi.Opaque{
}

final class git_index_iterator extends ffi.Opaque{
}

final class git_index_conflict_iterator extends ffi.Opaque{
}

final class git_config extends ffi.Opaque{
}

final class git_config_backend extends ffi.Opaque{
}

final class git_reflog_entry extends ffi.Opaque{
}

final class git_reflog extends ffi.Opaque{
}

final class git_note extends ffi.Opaque{
}

final class git_packbuilder extends ffi.Opaque{
}

/// Time in a signature
final class git_time extends ffi.Struct{
  /// < time in seconds from epoch
  @ffi.Int64()
  external int time;

  /// < timezone offset, in minutes
  @ffi.Int()
  external int offset;

  /// < indicator for questionable '-0000' offsets in signature
  @ffi.Char()
  external int sign;

}

/// An action signature (e.g. for committers, taggers, etc)
final class git_signature extends ffi.Struct{
  /// < full name of the author
  external ffi.Pointer<ffi.Char> name;

  /// < email of the author
  external ffi.Pointer<ffi.Char> email;

  /// < time when the action happened
  external git_time when;

}

final class git_reference extends ffi.Opaque{
}

final class git_reference_iterator extends ffi.Opaque{
}

final class git_transaction extends ffi.Opaque{
}

final class git_annotated_commit extends ffi.Opaque{
}

final class git_status_list extends ffi.Opaque{
}

final class git_rebase extends ffi.Opaque{
}

/// Basic type of any Git reference.
enum git_reference_t {
  /// < Invalid reference
  GIT_REFERENCE_INVALID(0),
  /// < A reference that points at an object id
  GIT_REFERENCE_DIRECT(1),
  /// < A reference that points at another reference
  GIT_REFERENCE_SYMBOLIC(2),
  GIT_REFERENCE_ALL(3);


  final int value;
  const git_reference_t(this.value);

  static git_reference_t fromValue(int value) => switch (value) {
    0 => GIT_REFERENCE_INVALID,
    1 => GIT_REFERENCE_DIRECT,
    2 => GIT_REFERENCE_SYMBOLIC,
    3 => GIT_REFERENCE_ALL,
    _ => throw ArgumentError('Unknown value for git_reference_t: $value'),
  };

}

/// Basic type of any Git branch.
enum git_branch_t {
  GIT_BRANCH_LOCAL(1),
  GIT_BRANCH_REMOTE(2),
  GIT_BRANCH_ALL(3);


  final int value;
  const git_branch_t(this.value);

  static git_branch_t fromValue(int value) => switch (value) {
    1 => GIT_BRANCH_LOCAL,
    2 => GIT_BRANCH_REMOTE,
    3 => GIT_BRANCH_ALL,
    _ => throw ArgumentError('Unknown value for git_branch_t: $value'),
  };

}

/// Valid modes for index and tree entries.
enum git_filemode_t {
  GIT_FILEMODE_UNREADABLE(0),
  GIT_FILEMODE_TREE(16384),
  GIT_FILEMODE_BLOB(33188),
  GIT_FILEMODE_BLOB_EXECUTABLE(33261),
  GIT_FILEMODE_LINK(40960),
  GIT_FILEMODE_COMMIT(57344);


  final int value;
  const git_filemode_t(this.value);

  static git_filemode_t fromValue(int value) => switch (value) {
    0 => GIT_FILEMODE_UNREADABLE,
    16384 => GIT_FILEMODE_TREE,
    33188 => GIT_FILEMODE_BLOB,
    33261 => GIT_FILEMODE_BLOB_EXECUTABLE,
    40960 => GIT_FILEMODE_LINK,
    57344 => GIT_FILEMODE_COMMIT,
    _ => throw ArgumentError('Unknown value for git_filemode_t: $value'),
  };

}

final class git_refspec extends ffi.Opaque{
}

final class git_remote extends ffi.Opaque{
}

final class git_transport extends ffi.Opaque{
}

final class git_push extends ffi.Opaque{
}

/// Description of a reference advertised by a remote server, given out
/// on `ls` calls.
final class git_remote_head extends ffi.Struct{
  @ffi.Int()
  external int local;

  external git_oid oid;

  external git_oid loid;

  external ffi.Pointer<ffi.Char> name;

  /// If the server send a symref mapping for this ref, this will
  /// point to the target.
  external ffi.Pointer<ffi.Char> symref_target;

}

/// Argument to the completion callback which tells it which operation
/// finished.
enum git_remote_completion_t {
  GIT_REMOTE_COMPLETION_DOWNLOAD(0),
  GIT_REMOTE_COMPLETION_INDEXING(1),
  GIT_REMOTE_COMPLETION_ERROR(2);


  final int value;
  const git_remote_completion_t(this.value);

  static git_remote_completion_t fromValue(int value) => switch (value) {
    0 => GIT_REMOTE_COMPLETION_DOWNLOAD,
    1 => GIT_REMOTE_COMPLETION_INDEXING,
    2 => GIT_REMOTE_COMPLETION_ERROR,
    _ => throw ArgumentError('Unknown value for git_remote_completion_t: $value'),
  };

}

/// Supported credential types
/// 
/// This represents the various types of authentication methods supported by
/// the library.
enum git_credential_t {
  /// A vanilla user/password request
  /// @see git_credential_userpass_plaintext_new
  GIT_CREDENTIAL_USERPASS_PLAINTEXT(1),
  /// An SSH key-based authentication request
  /// @see git_credential_ssh_key_new
  GIT_CREDENTIAL_SSH_KEY(2),
  /// An SSH key-based authentication request, with a custom signature
  /// @see git_credential_ssh_custom_new
  GIT_CREDENTIAL_SSH_CUSTOM(4),
  /// An NTLM/Negotiate-based authentication request.
  /// @see git_credential_default
  GIT_CREDENTIAL_DEFAULT(8),
  /// An SSH interactive authentication request
  /// @see git_credential_ssh_interactive_new
  GIT_CREDENTIAL_SSH_INTERACTIVE(16),
  /// Username-only authentication request
  /// 
  /// Used as a pre-authentication step if the underlying transport
  /// (eg. SSH, with no username in its URL) does not know which username
  /// to use.
  /// 
  /// @see git_credential_username_new
  GIT_CREDENTIAL_USERNAME(32),
  /// An SSH key-based authentication request
  /// 
  /// Allows credentials to be read from memory instead of files.
  /// Note that because of differences in crypto backend support, it might
  /// not be functional.
  /// 
  /// @see git_credential_ssh_key_memory_new
  GIT_CREDENTIAL_SSH_MEMORY(64);


  final int value;
  const git_credential_t(this.value);

  static git_credential_t fromValue(int value) => switch (value) {
    1 => GIT_CREDENTIAL_USERPASS_PLAINTEXT,
    2 => GIT_CREDENTIAL_SSH_KEY,
    4 => GIT_CREDENTIAL_SSH_CUSTOM,
    8 => GIT_CREDENTIAL_DEFAULT,
    16 => GIT_CREDENTIAL_SSH_INTERACTIVE,
    32 => GIT_CREDENTIAL_USERNAME,
    64 => GIT_CREDENTIAL_SSH_MEMORY,
    _ => throw ArgumentError('Unknown value for git_credential_t: $value'),
  };

}

/// The base structure for all credential types
final class git_credential extends ffi.Struct{
  /// < A type of credential
  @ffi.UnsignedInt()
  external int credtypeAsInt;

git_credential_t get credtype => git_credential_t.fromValue(credtypeAsInt);

  /// The deallocator for this type of credentials
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_credential> cred)>> free;

}

/// Type of host certificate structure that is passed to the check callback
enum git_cert_t {
  /// No information about the certificate is available. This may
  /// happen when using curl.
  GIT_CERT_NONE(0),
  /// The `data` argument to the callback will be a pointer to
  /// the DER-encoded data.
  GIT_CERT_X509(1),
  /// The `data` argument to the callback will be a pointer to a
  /// `git_cert_hostkey` structure.
  GIT_CERT_HOSTKEY_LIBSSH2(2),
  /// The `data` argument to the callback will be a pointer to a
  /// `git_strarray` with `name:content` strings containing
  /// information about the certificate. This is used when using
  /// curl.
  GIT_CERT_STRARRAY(3);


  final int value;
  const git_cert_t(this.value);

  static git_cert_t fromValue(int value) => switch (value) {
    0 => GIT_CERT_NONE,
    1 => GIT_CERT_X509,
    2 => GIT_CERT_HOSTKEY_LIBSSH2,
    3 => GIT_CERT_STRARRAY,
    _ => throw ArgumentError('Unknown value for git_cert_t: $value'),
  };

}

/// Parent type for `git_cert_hostkey` and `git_cert_x509`.
final class git_cert extends ffi.Struct{
  /// Type of certificate. A `GIT_CERT_` value.
  @ffi.UnsignedInt()
  external int cert_typeAsInt;

git_cert_t get cert_type => git_cert_t.fromValue(cert_typeAsInt);

}

/// Represents an update which will be performed on the remote during push
final class git_push_update extends ffi.Struct{
  /// The source name of the reference
  external ffi.Pointer<ffi.Char> src_refname;

  /// The name of the reference to update on the server
  external ffi.Pointer<ffi.Char> dst_refname;

  /// The current target of the reference
  external git_oid src;

  /// The new target for the reference
  external git_oid dst;

}

/// The callback settings structure
/// 
/// Set the callbacks to be called by the remote when informing the user
/// about the progress of the network operations.
final class git_remote_callbacks extends ffi.Struct{
  /// < The version
  @ffi.UnsignedInt()
  external int version;

  /// Textual progress from the remote. Text send over the
  /// progress side-band will be passed to this function (this is
  /// the 'counting objects' output).
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> str, ffi.Int len, ffi.Pointer<ffi.Void> payload)>> sideband_progress;

  /// Completion is called when different parts of the download
  /// process are done (currently unused).
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt type, ffi.Pointer<ffi.Void> data)>> completion;

  /// This will be called if the remote host requires
  /// authentication in order to connect to it.
  /// 
  /// Returning GIT_PASSTHROUGH will make libgit2 behave as
  /// though this field isn't set.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>> out, ffi.Pointer<ffi.Char> url, ffi.Pointer<ffi.Char> username_from_url, ffi.UnsignedInt allowed_types, ffi.Pointer<ffi.Void> payload)>> credentials;

  /// If cert verification fails, this will be called to let the
  /// user make the final decision of whether to allow the
  /// connection to proceed. Returns 0 to allow the connection
  /// or a negative value to indicate an error.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_cert> cert, ffi.Int valid, ffi.Pointer<ffi.Char> host, ffi.Pointer<ffi.Void> payload)>> certificate_check;

  /// During the download of new data, this will be regularly
  /// called with the current count of progress done by the
  /// indexer.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_indexer_progress> stats, ffi.Pointer<ffi.Void> payload)>> transfer_progress;

  /// Deprecated callback for reference updates, callers should
  /// set `update_refs` instead. This is retained for backward
  /// compatibility; if you specify both `update_refs` and
  /// `update_tips`, then only the `update_refs` function will
  /// be called.
  /// 
  /// @deprecated the `update_refs` callback in this structure
  /// should be preferred
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> refname, ffi.Pointer<git_oid> a, ffi.Pointer<git_oid> b, ffi.Pointer<ffi.Void> data)>> update_tips;

  /// Function to call with progress information during pack
  /// building. Be aware that this is called inline with pack
  /// building operations, so performance may be affected.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Int stage, ffi.Uint32 current, ffi.Uint32 total, ffi.Pointer<ffi.Void> payload)>> pack_progress;

  /// Function to call with progress information during the
  /// upload portion of a push. Be aware that this is called
  /// inline with pack building operations, so performance may be
  /// affected.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt current, ffi.UnsignedInt total, ffi.Size bytes, ffi.Pointer<ffi.Void> payload)>> push_transfer_progress;

  /// See documentation of git_push_update_reference_cb
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> refname, ffi.Pointer<ffi.Char> status, ffi.Pointer<ffi.Void> data)>> push_update_reference;

  /// Called once between the negotiation step and the upload. It
  /// provides information about what updates will be performed.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_push_update>> updates, ffi.Size len, ffi.Pointer<ffi.Void> payload)>> push_negotiation;

  /// Create the transport to use for this operation. Leave NULL
  /// to auto-detect.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_transport>> out, ffi.Pointer<git_remote> owner, ffi.Pointer<ffi.Void> param)>> transport;

  /// Callback when the remote is ready to connect.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_remote> remote, ffi.Int direction, ffi.Pointer<ffi.Void> payload)>> remote_ready;

  /// This will be passed to each of the callbacks in this struct
  /// as the last parameter.
  external ffi.Pointer<ffi.Void> payload;

  /// Resolve URL before connecting to remote.
  /// The returned URL will be used to connect to the remote instead.
  /// 
  /// This callback is deprecated; users should use
  /// git_remote_ready_cb and configure the instance URL instead.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_buf> url_resolved, ffi.Pointer<ffi.Char> url, ffi.Int direction, ffi.Pointer<ffi.Void> payload)>> resolve_url;

  /// Each time a reference is updated locally, this function
  /// will be called with information about it. This should be
  /// preferred over the `update_tips` callback in this
  /// structure.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char> refname, ffi.Pointer<git_oid> a, ffi.Pointer<git_oid> b, ffi.Pointer<git_refspec> spec, ffi.Pointer<ffi.Void> data)>> update_refs;

}

final class git_submodule extends ffi.Opaque{
}

/// Submodule update values
/// 
/// These values represent settings for the `submodule.$name.update`
/// configuration value which says how to handle `git submodule update` for
/// this submodule.  The value is usually set in the ".gitmodules" file and
/// copied to ".git/config" when the submodule is initialized.
/// 
/// You can override this setting on a per-submodule basis with
/// `git_submodule_set_update()` and write the changed value to disk using
/// `git_submodule_save()`.  If you have overwritten the value, you can
/// revert it by passing `GIT_SUBMODULE_UPDATE_RESET` to the set function.
/// 
/// The values are:
/// 
/// - GIT_SUBMODULE_UPDATE_CHECKOUT: the default; when a submodule is
/// updated, checkout the new detached HEAD to the submodule directory.
/// - GIT_SUBMODULE_UPDATE_REBASE: update by rebasing the current checked
/// out branch onto the commit from the superproject.
/// - GIT_SUBMODULE_UPDATE_MERGE: update by merging the commit in the
/// superproject into the current checkout out branch of the submodule.
/// - GIT_SUBMODULE_UPDATE_NONE: do not update this submodule even when
/// the commit in the superproject is updated.
/// - GIT_SUBMODULE_UPDATE_DEFAULT: not used except as static initializer
/// when we don't want any particular update rule to be specified.
enum git_submodule_update_t {
  GIT_SUBMODULE_UPDATE_CHECKOUT(1),
  GIT_SUBMODULE_UPDATE_REBASE(2),
  GIT_SUBMODULE_UPDATE_MERGE(3),
  GIT_SUBMODULE_UPDATE_NONE(4),
  GIT_SUBMODULE_UPDATE_DEFAULT(0);


  final int value;
  const git_submodule_update_t(this.value);

  static git_submodule_update_t fromValue(int value) => switch (value) {
    1 => GIT_SUBMODULE_UPDATE_CHECKOUT,
    2 => GIT_SUBMODULE_UPDATE_REBASE,
    3 => GIT_SUBMODULE_UPDATE_MERGE,
    4 => GIT_SUBMODULE_UPDATE_NONE,
    0 => GIT_SUBMODULE_UPDATE_DEFAULT,
    _ => throw ArgumentError('Unknown value for git_submodule_update_t: $value'),
  };

}

/// Submodule ignore values
/// 
/// These values represent settings for the `submodule.$name.ignore`
/// configuration value which says how deeply to look at the working
/// directory when getting submodule status.
/// 
/// You can override this value in memory on a per-submodule basis with
/// `git_submodule_set_ignore()` and can write the changed value to disk
/// with `git_submodule_save()`.  If you have overwritten the value, you
/// can revert to the on disk value by using `GIT_SUBMODULE_IGNORE_RESET`.
/// 
/// The values are:
/// 
/// - GIT_SUBMODULE_IGNORE_UNSPECIFIED: use the submodule's configuration
/// - GIT_SUBMODULE_IGNORE_NONE: don't ignore any change - i.e. even an
/// untracked file, will mark the submodule as dirty.  Ignored files are
/// still ignored, of course.
/// - GIT_SUBMODULE_IGNORE_UNTRACKED: ignore untracked files; only changes
/// to tracked files, or the index or the HEAD commit will matter.
/// - GIT_SUBMODULE_IGNORE_DIRTY: ignore changes in the working directory,
/// only considering changes if the HEAD of submodule has moved from the
/// value in the superproject.
/// - GIT_SUBMODULE_IGNORE_ALL: never check if the submodule is dirty
/// - GIT_SUBMODULE_IGNORE_DEFAULT: not used except as static initializer
/// when we don't want any particular ignore rule to be specified.
enum git_submodule_ignore_t {
  /// < use the submodule's configuration
  GIT_SUBMODULE_IGNORE_UNSPECIFIED(-1),
  /// < any change or untracked == dirty
  GIT_SUBMODULE_IGNORE_NONE(1),
  /// < dirty if tracked files change
  GIT_SUBMODULE_IGNORE_UNTRACKED(2),
  /// < only dirty if HEAD moved
  GIT_SUBMODULE_IGNORE_DIRTY(3),
  /// < never dirty
  GIT_SUBMODULE_IGNORE_ALL(4);


  final int value;
  const git_submodule_ignore_t(this.value);

  static git_submodule_ignore_t fromValue(int value) => switch (value) {
    -1 => GIT_SUBMODULE_IGNORE_UNSPECIFIED,
    1 => GIT_SUBMODULE_IGNORE_NONE,
    2 => GIT_SUBMODULE_IGNORE_UNTRACKED,
    3 => GIT_SUBMODULE_IGNORE_DIRTY,
    4 => GIT_SUBMODULE_IGNORE_ALL,
    _ => throw ArgumentError('Unknown value for git_submodule_ignore_t: $value'),
  };

}

/// Options for submodule recurse.
/// 
/// Represent the value of `submodule.$name.fetchRecurseSubmodules`
/// 
/// * GIT_SUBMODULE_RECURSE_NO    - do no recurse into submodules
/// * GIT_SUBMODULE_RECURSE_YES   - recurse into submodules
/// * GIT_SUBMODULE_RECURSE_ONDEMAND - recurse into submodules only when
/// commit not already in local clone
enum git_submodule_recurse_t {
  GIT_SUBMODULE_RECURSE_NO(0),
  GIT_SUBMODULE_RECURSE_YES(1),
  GIT_SUBMODULE_RECURSE_ONDEMAND(2);


  final int value;
  const git_submodule_recurse_t(this.value);

  static git_submodule_recurse_t fromValue(int value) => switch (value) {
    0 => GIT_SUBMODULE_RECURSE_NO,
    1 => GIT_SUBMODULE_RECURSE_YES,
    2 => GIT_SUBMODULE_RECURSE_ONDEMAND,
    _ => throw ArgumentError('Unknown value for git_submodule_recurse_t: $value'),
  };

}

/// A type to write in a streaming fashion, for example, for filters.
final class git_writestream extends ffi.Struct{
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_writestream> stream, ffi.Pointer<ffi.Char> buffer, ffi.Size len)>> write;

  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_writestream> stream)>> close;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_writestream> stream)>> free;

}

final class git_mailmap extends ffi.Opaque{
}

/// Array of object ids
final class git_oidarray extends ffi.Struct{
  external ffi.Pointer<git_oid> ids;

  @ffi.Size()
  external int count;

}

final class git_indexer extends ffi.Opaque{
}

/// Options for indexer configuration
final class git_indexer_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// progress_cb function to call with progress information
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_indexer_progress> stats, ffi.Pointer<ffi.Void> payload)>> progress_cb;

  /// progress_cb_payload payload for the progress callback
  external ffi.Pointer<ffi.Void> progress_cb_payload;

  /// Do connectivity checks for the received pack
  @ffi.UnsignedChar()
  external int verify;

}

/// Flags controlling the behavior of ODB lookup operations
enum git_odb_lookup_flags_t {
  /// Don't call `git_odb_refresh` if the lookup fails. Useful when doing
  /// a batch of lookup operations for objects that may legitimately not
  /// exist. When using this flag, you may wish to manually call
  /// `git_odb_refresh` before processing a batch of objects.
  GIT_ODB_LOOKUP_NO_REFRESH(1);


  final int value;
  const git_odb_lookup_flags_t(this.value);

  static git_odb_lookup_flags_t fromValue(int value) => switch (value) {
    1 => GIT_ODB_LOOKUP_NO_REFRESH,
    _ => throw ArgumentError('Unknown value for git_odb_lookup_flags_t: $value'),
  };

}

/// Options for configuring a loose object backend.
final class git_odb_options extends ffi.Struct{
  /// < version for the struct
  @ffi.UnsignedInt()
  external int version;

  /// Type of object IDs to use for this object database, or
  /// 0 for default (currently SHA1).
  @ffi.UnsignedInt()
  external int oid_typeAsInt;

git_oid_t get oid_type => git_oid_t.fromValue(oid_typeAsInt);

}

/// The information about object IDs to query in `git_odb_expand_ids`,
/// which will be populated upon return.
final class git_odb_expand_id extends ffi.Struct{
  /// The object ID to expand
  external git_oid id;

  /// The length of the object ID (in nibbles, or packets of 4 bits; the
  /// number of hex characters)
  @ffi.UnsignedShort()
  external int length;

  /// The (optional) type of the object to search for; leave as `0` or set
  /// to `GIT_OBJECT_ANY` to query for any object matching the ID.
  @ffi.Int()
  external int typeAsInt;

git_object_t get type => git_object_t.fromValue(typeAsInt);

}

final class git_commit_create_options extends ffi.Opaque{
}

/// An array of commits returned from the library
final class git_commitarray extends ffi.Struct{
  external ffi.Pointer<ffi.Pointer<git_commit>> commits;

  @ffi.Size()
  external int count;

}

/// Option flags for `git_repository_open_ext`.
enum git_repository_open_flag_t {
  /// Only open the repository if it can be immediately found in the
  /// start_path. Do not walk up from the start_path looking at parent
  /// directories.
  GIT_REPOSITORY_OPEN_NO_SEARCH(1),
  /// Unless this flag is set, open will not continue searching across
  /// filesystem boundaries (i.e. when `st_dev` changes from the `stat`
  /// system call).  For example, searching in a user's home directory at
  /// "/home/user/source/" will not return "/.git/" as the found repo if
  /// "/" is a different filesystem than "/home".
  GIT_REPOSITORY_OPEN_CROSS_FS(2),
  /// Open repository as a bare repo regardless of core.bare config, and
  /// defer loading config file for faster setup.
  /// Unlike `git_repository_open_bare`, this can follow gitlinks.
  GIT_REPOSITORY_OPEN_BARE(4),
  /// Do not check for a repository by appending /.git to the start_path;
  /// only open the repository if start_path itself points to the git
  /// directory.
  GIT_REPOSITORY_OPEN_NO_DOTGIT(8),
  /// Find and open a git repository, respecting the environment variables
  /// used by the git command-line tools.
  /// If set, `git_repository_open_ext` will ignore the other flags and
  /// the `ceiling_dirs` argument, and will allow a NULL `path` to use
  /// `GIT_DIR` or search from the current directory.
  /// The search for a repository will respect $GIT_CEILING_DIRECTORIES and
  /// $GIT_DISCOVERY_ACROSS_FILESYSTEM.  The opened repository will
  /// respect $GIT_INDEX_FILE, $GIT_NAMESPACE, $GIT_OBJECT_DIRECTORY, and
  /// $GIT_ALTERNATE_OBJECT_DIRECTORIES.
  /// In the future, this flag will also cause `git_repository_open_ext`
  /// to respect $GIT_WORK_TREE and $GIT_COMMON_DIR; currently,
  /// `git_repository_open_ext` with this flag will error out if either
  /// $GIT_WORK_TREE or $GIT_COMMON_DIR is set.
  GIT_REPOSITORY_OPEN_FROM_ENV(16);


  final int value;
  const git_repository_open_flag_t(this.value);

  static git_repository_open_flag_t fromValue(int value) => switch (value) {
    1 => GIT_REPOSITORY_OPEN_NO_SEARCH,
    2 => GIT_REPOSITORY_OPEN_CROSS_FS,
    4 => GIT_REPOSITORY_OPEN_BARE,
    8 => GIT_REPOSITORY_OPEN_NO_DOTGIT,
    16 => GIT_REPOSITORY_OPEN_FROM_ENV,
    _ => throw ArgumentError('Unknown value for git_repository_open_flag_t: $value'),
  };

}

/// Option flags for `git_repository_init_ext`.
/// 
/// These flags configure extra behaviors to `git_repository_init_ext`.
/// In every case, the default behavior is the zero value (i.e. flag is
/// not set). Just OR the flag values together for the `flags` parameter
/// when initializing a new repo.
enum git_repository_init_flag_t {
  /// Create a bare repository with no working directory.
  GIT_REPOSITORY_INIT_BARE(1),
  /// Return an GIT_EEXISTS error if the repo_path appears to already be
  /// an git repository.
  GIT_REPOSITORY_INIT_NO_REINIT(2),
  /// Normally a "/.git/" will be appended to the repo path for
  /// non-bare repos (if it is not already there), but passing this flag
  /// prevents that behavior.
  GIT_REPOSITORY_INIT_NO_DOTGIT_DIR(4),
  /// Make the repo_path (and workdir_path) as needed. Init is always willing
  /// to create the ".git" directory even without this flag. This flag tells
  /// init to create the trailing component of the repo and workdir paths
  /// as needed.
  GIT_REPOSITORY_INIT_MKDIR(8),
  /// Recursively make all components of the repo and workdir paths as
  /// necessary.
  GIT_REPOSITORY_INIT_MKPATH(16),
  /// libgit2 normally uses internal templates to initialize a new repo.
  /// This flags enables external templates, looking the "template_path" from
  /// the options if set, or the `init.templatedir` global config if not,
  /// or falling back on "/usr/share/git-core/templates" if it exists.
  GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE(32),
  /// If an alternate workdir is specified, use relative paths for the gitdir
  /// and core.worktree.
  GIT_REPOSITORY_INIT_RELATIVE_GITLINK(64);


  final int value;
  const git_repository_init_flag_t(this.value);

  static git_repository_init_flag_t fromValue(int value) => switch (value) {
    1 => GIT_REPOSITORY_INIT_BARE,
    2 => GIT_REPOSITORY_INIT_NO_REINIT,
    4 => GIT_REPOSITORY_INIT_NO_DOTGIT_DIR,
    8 => GIT_REPOSITORY_INIT_MKDIR,
    16 => GIT_REPOSITORY_INIT_MKPATH,
    32 => GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE,
    64 => GIT_REPOSITORY_INIT_RELATIVE_GITLINK,
    _ => throw ArgumentError('Unknown value for git_repository_init_flag_t: $value'),
  };

}

/// Mode options for `git_repository_init_ext`.
/// 
/// Set the mode field of the `git_repository_init_options` structure
/// either to the custom mode that you would like, or to one of the
/// defined modes.
enum git_repository_init_mode_t {
  /// Use permissions configured by umask - the default.
  GIT_REPOSITORY_INIT_SHARED_UMASK(0),
  /// Use "--shared=group" behavior, chmod'ing the new repo to be group
  /// writable and "g+sx" for sticky group assignment.
  GIT_REPOSITORY_INIT_SHARED_GROUP(1533),
  /// Use "--shared=all" behavior, adding world readability.
  GIT_REPOSITORY_INIT_SHARED_ALL(1535);


  final int value;
  const git_repository_init_mode_t(this.value);

  static git_repository_init_mode_t fromValue(int value) => switch (value) {
    0 => GIT_REPOSITORY_INIT_SHARED_UMASK,
    1533 => GIT_REPOSITORY_INIT_SHARED_GROUP,
    1535 => GIT_REPOSITORY_INIT_SHARED_ALL,
    _ => throw ArgumentError('Unknown value for git_repository_init_mode_t: $value'),
  };

}

/// Extended options structure for `git_repository_init_ext`.
/// 
/// This contains extra options for `git_repository_init_ext` that enable
/// additional initialization features.
final class git_repository_init_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// Combination of GIT_REPOSITORY_INIT flags above.
  @ffi.Uint32()
  external int flags;

  /// Set to one of the standard GIT_REPOSITORY_INIT_SHARED_... constants
  /// above, or to a custom value that you would like.
  @ffi.Uint32()
  external int mode;

  /// The path to the working dir or NULL for default (i.e. repo_path parent
  /// on non-bare repos). IF THIS IS RELATIVE PATH, IT WILL BE EVALUATED
  /// RELATIVE TO THE REPO_PATH. If this is not the "natural" working
  /// directory, a .git gitlink file will be created here linking to the
  /// repo_path.
  external ffi.Pointer<ffi.Char> workdir_path;

  /// If set, this will be used to initialize the "description" file in the
  /// repository, instead of using the template content.
  external ffi.Pointer<ffi.Char> description;

  /// When GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE is set, this contains
  /// the path to use for the template directory. If this is NULL, the config
  /// or default directory options will be used instead.
  external ffi.Pointer<ffi.Char> template_path;

  /// The name of the head to point HEAD at. If NULL, then this will be
  /// treated as "master" and the HEAD ref will be set to "refs/heads/master".
  /// If this begins with "refs/" it will be used verbatim;
  /// otherwise "refs/heads/" will be prefixed.
  external ffi.Pointer<ffi.Char> initial_head;

  /// If this is non-NULL, then after the rest of the repository
  /// initialization is completed, an "origin" remote will be added
  /// pointing to this URL.
  external ffi.Pointer<ffi.Char> origin_url;

}

/// List of items which belong to the git repository layout
enum git_repository_item_t {
  GIT_REPOSITORY_ITEM_GITDIR(0),
  GIT_REPOSITORY_ITEM_WORKDIR(1),
  GIT_REPOSITORY_ITEM_COMMONDIR(2),
  GIT_REPOSITORY_ITEM_INDEX(3),
  GIT_REPOSITORY_ITEM_OBJECTS(4),
  GIT_REPOSITORY_ITEM_REFS(5),
  GIT_REPOSITORY_ITEM_PACKED_REFS(6),
  GIT_REPOSITORY_ITEM_REMOTES(7),
  GIT_REPOSITORY_ITEM_CONFIG(8),
  GIT_REPOSITORY_ITEM_INFO(9),
  GIT_REPOSITORY_ITEM_HOOKS(10),
  GIT_REPOSITORY_ITEM_LOGS(11),
  GIT_REPOSITORY_ITEM_MODULES(12),
  GIT_REPOSITORY_ITEM_WORKTREES(13),
  GIT_REPOSITORY_ITEM_WORKTREE_CONFIG(14),
  GIT_REPOSITORY_ITEM__LAST(15);


  final int value;
  const git_repository_item_t(this.value);

  static git_repository_item_t fromValue(int value) => switch (value) {
    0 => GIT_REPOSITORY_ITEM_GITDIR,
    1 => GIT_REPOSITORY_ITEM_WORKDIR,
    2 => GIT_REPOSITORY_ITEM_COMMONDIR,
    3 => GIT_REPOSITORY_ITEM_INDEX,
    4 => GIT_REPOSITORY_ITEM_OBJECTS,
    5 => GIT_REPOSITORY_ITEM_REFS,
    6 => GIT_REPOSITORY_ITEM_PACKED_REFS,
    7 => GIT_REPOSITORY_ITEM_REMOTES,
    8 => GIT_REPOSITORY_ITEM_CONFIG,
    9 => GIT_REPOSITORY_ITEM_INFO,
    10 => GIT_REPOSITORY_ITEM_HOOKS,
    11 => GIT_REPOSITORY_ITEM_LOGS,
    12 => GIT_REPOSITORY_ITEM_MODULES,
    13 => GIT_REPOSITORY_ITEM_WORKTREES,
    14 => GIT_REPOSITORY_ITEM_WORKTREE_CONFIG,
    15 => GIT_REPOSITORY_ITEM__LAST,
    _ => throw ArgumentError('Unknown value for git_repository_item_t: $value'),
  };

}

/// Repository state
/// 
/// These values represent possible states for the repository to be in,
/// based on the current operation which is ongoing.
enum git_repository_state_t {
  GIT_REPOSITORY_STATE_NONE(0),
  GIT_REPOSITORY_STATE_MERGE(1),
  GIT_REPOSITORY_STATE_REVERT(2),
  GIT_REPOSITORY_STATE_REVERT_SEQUENCE(3),
  GIT_REPOSITORY_STATE_CHERRYPICK(4),
  GIT_REPOSITORY_STATE_CHERRYPICK_SEQUENCE(5),
  GIT_REPOSITORY_STATE_BISECT(6),
  GIT_REPOSITORY_STATE_REBASE(7),
  GIT_REPOSITORY_STATE_REBASE_INTERACTIVE(8),
  GIT_REPOSITORY_STATE_REBASE_MERGE(9),
  GIT_REPOSITORY_STATE_APPLY_MAILBOX(10),
  GIT_REPOSITORY_STATE_APPLY_MAILBOX_OR_REBASE(11);


  final int value;
  const git_repository_state_t(this.value);

  static git_repository_state_t fromValue(int value) => switch (value) {
    0 => GIT_REPOSITORY_STATE_NONE,
    1 => GIT_REPOSITORY_STATE_MERGE,
    2 => GIT_REPOSITORY_STATE_REVERT,
    3 => GIT_REPOSITORY_STATE_REVERT_SEQUENCE,
    4 => GIT_REPOSITORY_STATE_CHERRYPICK,
    5 => GIT_REPOSITORY_STATE_CHERRYPICK_SEQUENCE,
    6 => GIT_REPOSITORY_STATE_BISECT,
    7 => GIT_REPOSITORY_STATE_REBASE,
    8 => GIT_REPOSITORY_STATE_REBASE_INTERACTIVE,
    9 => GIT_REPOSITORY_STATE_REBASE_MERGE,
    10 => GIT_REPOSITORY_STATE_APPLY_MAILBOX,
    11 => GIT_REPOSITORY_STATE_APPLY_MAILBOX_OR_REBASE,
    _ => throw ArgumentError('Unknown value for git_repository_state_t: $value'),
  };

}

/// Tree traversal modes
enum git_treewalk_mode {
  GIT_TREEWALK_PRE(0),
  GIT_TREEWALK_POST(1);


  final int value;
  const git_treewalk_mode(this.value);

  static git_treewalk_mode fromValue(int value) => switch (value) {
    0 => GIT_TREEWALK_PRE,
    1 => GIT_TREEWALK_POST,
    _ => throw ArgumentError('Unknown value for git_treewalk_mode: $value'),
  };

}

/// The kind of update to perform
enum git_tree_update_t {
  /// Update or insert an entry at the specified path
  GIT_TREE_UPDATE_UPSERT(0),
  /// Remove an entry from the specified path
  GIT_TREE_UPDATE_REMOVE(1);


  final int value;
  const git_tree_update_t(this.value);

  static git_tree_update_t fromValue(int value) => switch (value) {
    0 => GIT_TREE_UPDATE_UPSERT,
    1 => GIT_TREE_UPDATE_REMOVE,
    _ => throw ArgumentError('Unknown value for git_tree_update_t: $value'),
  };

}

/// An action to perform during the update of a tree
final class git_tree_update extends ffi.Struct{
  /// Update action. If it's an removal, only the path is looked at
  @ffi.UnsignedInt()
  external int actionAsInt;

git_tree_update_t get action => git_tree_update_t.fromValue(actionAsInt);

  /// The entry's id
  external git_oid id;

  /// The filemode/kind of object
  @ffi.UnsignedInt()
  external int filemodeAsInt;

git_filemode_t get filemode => git_filemode_t.fromValue(filemodeAsInt);

  /// The full path from the root tree
  external ffi.Pointer<ffi.Char> path;

}

/// Array of strings
final class git_strarray extends ffi.Struct{
  external ffi.Pointer<ffi.Pointer<ffi.Char>> strings;

  @ffi.Size()
  external int count;

}

/// Normalization options for reference lookup
enum git_reference_format_t {
  /// No particular normalization.
  GIT_REFERENCE_FORMAT_NORMAL(0),
  /// Control whether one-level refnames are accepted
  /// (i.e., refnames that do not contain multiple /-separated
  /// components). Those are expected to be written only using
  /// uppercase letters and underscore (FETCH_HEAD, ...)
  GIT_REFERENCE_FORMAT_ALLOW_ONELEVEL(1),
  /// Interpret the provided name as a reference pattern for a
  /// refspec (as used with remote repositories). If this option
  /// is enabled, the name is allowed to contain a single * (<star>)
  /// in place of a one full pathname component
  /// (e.g., foo/<star>/bar but not foo/bar<star>).
  GIT_REFERENCE_FORMAT_REFSPEC_PATTERN(2),
  /// Interpret the name as part of a refspec in shorthand form
  /// so the `ONELEVEL` naming rules aren't enforced and 'master'
  /// becomes a valid name.
  GIT_REFERENCE_FORMAT_REFSPEC_SHORTHAND(4);


  final int value;
  const git_reference_format_t(this.value);

  static git_reference_format_t fromValue(int value) => switch (value) {
    0 => GIT_REFERENCE_FORMAT_NORMAL,
    1 => GIT_REFERENCE_FORMAT_ALLOW_ONELEVEL,
    2 => GIT_REFERENCE_FORMAT_REFSPEC_PATTERN,
    4 => GIT_REFERENCE_FORMAT_REFSPEC_SHORTHAND,
    _ => throw ArgumentError('Unknown value for git_reference_format_t: $value'),
  };

}

/// Flags for diff options.  A combination of these flags can be passed
/// in via the `flags` value in the `git_diff_options`.
enum git_diff_option_t {
  /// Normal diff, the default
  GIT_DIFF_NORMAL(0),
  /// Reverse the sides of the diff
  GIT_DIFF_REVERSE(1),
  /// Include ignored files in the diff
  GIT_DIFF_INCLUDE_IGNORED(2),
  /// Even with GIT_DIFF_INCLUDE_IGNORED, an entire ignored directory
  /// will be marked with only a single entry in the diff; this flag
  /// adds all files under the directory as IGNORED entries, too.
  GIT_DIFF_RECURSE_IGNORED_DIRS(4),
  /// Include untracked files in the diff
  GIT_DIFF_INCLUDE_UNTRACKED(8),
  /// Even with GIT_DIFF_INCLUDE_UNTRACKED, an entire untracked
  /// directory will be marked with only a single entry in the diff
  /// (a la what core Git does in `git status`); this flag adds *all*
  /// files under untracked directories as UNTRACKED entries, too.
  GIT_DIFF_RECURSE_UNTRACKED_DIRS(16),
  /// Include unmodified files in the diff
  GIT_DIFF_INCLUDE_UNMODIFIED(32),
  /// Normally, a type change between files will be converted into a
  /// DELETED record for the old and an ADDED record for the new; this
  /// options enabled the generation of TYPECHANGE delta records.
  GIT_DIFF_INCLUDE_TYPECHANGE(64),
  /// Even with GIT_DIFF_INCLUDE_TYPECHANGE, blob->tree changes still
  /// generally show as a DELETED blob.  This flag tries to correctly
  /// label blob->tree transitions as TYPECHANGE records with new_file's
  /// mode set to tree.  Note: the tree SHA will not be available.
  GIT_DIFF_INCLUDE_TYPECHANGE_TREES(128),
  /// Ignore file mode changes
  GIT_DIFF_IGNORE_FILEMODE(256),
  /// Treat all submodules as unmodified
  GIT_DIFF_IGNORE_SUBMODULES(512),
  /// Use case insensitive filename comparisons
  GIT_DIFF_IGNORE_CASE(1024),
  /// May be combined with `GIT_DIFF_IGNORE_CASE` to specify that a file
  /// that has changed case will be returned as an add/delete pair.
  GIT_DIFF_INCLUDE_CASECHANGE(2048),
  /// If the pathspec is set in the diff options, this flags indicates
  /// that the paths will be treated as literal paths instead of
  /// fnmatch patterns.  Each path in the list must either be a full
  /// path to a file or a directory.  (A trailing slash indicates that
  /// the path will _only_ match a directory).  If a directory is
  /// specified, all children will be included.
  GIT_DIFF_DISABLE_PATHSPEC_MATCH(4096),
  /// Disable updating of the `binary` flag in delta records.  This is
  /// useful when iterating over a diff if you don't need hunk and data
  /// callbacks and want to avoid having to load file completely.
  GIT_DIFF_SKIP_BINARY_CHECK(8192),
  /// When diff finds an untracked directory, to match the behavior of
  /// core Git, it scans the contents for IGNORED and UNTRACKED files.
  /// If *all* contents are IGNORED, then the directory is IGNORED; if
  /// any contents are not IGNORED, then the directory is UNTRACKED.
  /// This is extra work that may not matter in many cases.  This flag
  /// turns off that scan and immediately labels an untracked directory
  /// as UNTRACKED (changing the behavior to not match core Git).
  GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS(16384),
  /// When diff finds a file in the working directory with stat
  /// information different from the index, but the OID ends up being the
  /// same, write the correct stat information into the index.  Note:
  /// without this flag, diff will always leave the index untouched.
  GIT_DIFF_UPDATE_INDEX(32768),
  /// Include unreadable files in the diff
  GIT_DIFF_INCLUDE_UNREADABLE(65536),
  /// Include unreadable files in the diff
  GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED(131072),
  /// Use a heuristic that takes indentation and whitespace into account
  /// which generally can produce better diffs when dealing with ambiguous
  /// diff hunks.
  GIT_DIFF_INDENT_HEURISTIC(262144),
  /// Ignore blank lines
  GIT_DIFF_IGNORE_BLANK_LINES(524288),
  /// Treat all files as text, disabling binary attributes & detection
  GIT_DIFF_FORCE_TEXT(1048576),
  /// Treat all files as binary, disabling text diffs
  GIT_DIFF_FORCE_BINARY(2097152),
  /// Ignore all whitespace
  GIT_DIFF_IGNORE_WHITESPACE(4194304),
  /// Ignore changes in amount of whitespace
  GIT_DIFF_IGNORE_WHITESPACE_CHANGE(8388608),
  /// Ignore whitespace at end of line
  GIT_DIFF_IGNORE_WHITESPACE_EOL(16777216),
  /// When generating patch text, include the content of untracked
  /// files.  This automatically turns on GIT_DIFF_INCLUDE_UNTRACKED but
  /// it does not turn on GIT_DIFF_RECURSE_UNTRACKED_DIRS.  Add that
  /// flag if you want the content of every single UNTRACKED file.
  GIT_DIFF_SHOW_UNTRACKED_CONTENT(33554432),
  /// When generating output, include the names of unmodified files if
  /// they are included in the git_diff.  Normally these are skipped in
  /// the formats that list files (e.g. name-only, name-status, raw).
  /// Even with this, these will not be included in patch format.
  GIT_DIFF_SHOW_UNMODIFIED(67108864),
  /// Use the "patience diff" algorithm
  GIT_DIFF_PATIENCE(268435456),
  /// Take extra time to find minimal diff
  GIT_DIFF_MINIMAL(536870912),
  /// Include the necessary deflate / delta information so that `git-apply`
  /// can apply given diff information to binary files.
  GIT_DIFF_SHOW_BINARY(1073741824);


  final int value;
  const git_diff_option_t(this.value);

  static git_diff_option_t fromValue(int value) => switch (value) {
    0 => GIT_DIFF_NORMAL,
    1 => GIT_DIFF_REVERSE,
    2 => GIT_DIFF_INCLUDE_IGNORED,
    4 => GIT_DIFF_RECURSE_IGNORED_DIRS,
    8 => GIT_DIFF_INCLUDE_UNTRACKED,
    16 => GIT_DIFF_RECURSE_UNTRACKED_DIRS,
    32 => GIT_DIFF_INCLUDE_UNMODIFIED,
    64 => GIT_DIFF_INCLUDE_TYPECHANGE,
    128 => GIT_DIFF_INCLUDE_TYPECHANGE_TREES,
    256 => GIT_DIFF_IGNORE_FILEMODE,
    512 => GIT_DIFF_IGNORE_SUBMODULES,
    1024 => GIT_DIFF_IGNORE_CASE,
    2048 => GIT_DIFF_INCLUDE_CASECHANGE,
    4096 => GIT_DIFF_DISABLE_PATHSPEC_MATCH,
    8192 => GIT_DIFF_SKIP_BINARY_CHECK,
    16384 => GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS,
    32768 => GIT_DIFF_UPDATE_INDEX,
    65536 => GIT_DIFF_INCLUDE_UNREADABLE,
    131072 => GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED,
    262144 => GIT_DIFF_INDENT_HEURISTIC,
    524288 => GIT_DIFF_IGNORE_BLANK_LINES,
    1048576 => GIT_DIFF_FORCE_TEXT,
    2097152 => GIT_DIFF_FORCE_BINARY,
    4194304 => GIT_DIFF_IGNORE_WHITESPACE,
    8388608 => GIT_DIFF_IGNORE_WHITESPACE_CHANGE,
    16777216 => GIT_DIFF_IGNORE_WHITESPACE_EOL,
    33554432 => GIT_DIFF_SHOW_UNTRACKED_CONTENT,
    67108864 => GIT_DIFF_SHOW_UNMODIFIED,
    268435456 => GIT_DIFF_PATIENCE,
    536870912 => GIT_DIFF_MINIMAL,
    1073741824 => GIT_DIFF_SHOW_BINARY,
    _ => throw ArgumentError('Unknown value for git_diff_option_t: $value'),
  };

}

final class git_diff extends ffi.Opaque{
}

/// Flags for the delta object and the file objects on each side.
/// 
/// These flags are used for both the `flags` value of the `git_diff_delta`
/// and the flags for the `git_diff_file` objects representing the old and
/// new sides of the delta.  Values outside of this public range should be
/// considered reserved for internal or future use.
enum git_diff_flag_t {
  /// < file(s) treated as binary data
  GIT_DIFF_FLAG_BINARY(1),
  /// < file(s) treated as text data
  GIT_DIFF_FLAG_NOT_BINARY(2),
  /// < `id` value is known correct
  GIT_DIFF_FLAG_VALID_ID(4),
  /// < file exists at this side of the delta
  GIT_DIFF_FLAG_EXISTS(8),
  /// < file size value is known correct
  GIT_DIFF_FLAG_VALID_SIZE(16);


  final int value;
  const git_diff_flag_t(this.value);

  static git_diff_flag_t fromValue(int value) => switch (value) {
    1 => GIT_DIFF_FLAG_BINARY,
    2 => GIT_DIFF_FLAG_NOT_BINARY,
    4 => GIT_DIFF_FLAG_VALID_ID,
    8 => GIT_DIFF_FLAG_EXISTS,
    16 => GIT_DIFF_FLAG_VALID_SIZE,
    _ => throw ArgumentError('Unknown value for git_diff_flag_t: $value'),
  };

}

/// What type of change is described by a git_diff_delta?
/// 
/// `GIT_DELTA_RENAMED` and `GIT_DELTA_COPIED` will only show up if you run
/// `git_diff_find_similar()` on the diff object.
/// 
/// `GIT_DELTA_TYPECHANGE` only shows up given `GIT_DIFF_INCLUDE_TYPECHANGE`
/// in the option flags (otherwise type changes will be split into ADDED /
/// DELETED pairs).
enum git_delta_t {
  /// < no changes
  GIT_DELTA_UNMODIFIED(0),
  /// < entry does not exist in old version
  GIT_DELTA_ADDED(1),
  /// < entry does not exist in new version
  GIT_DELTA_DELETED(2),
  /// < entry content changed between old and new
  GIT_DELTA_MODIFIED(3),
  /// < entry was renamed between old and new
  GIT_DELTA_RENAMED(4),
  /// < entry was copied from another old entry
  GIT_DELTA_COPIED(5),
  /// < entry is ignored item in workdir
  GIT_DELTA_IGNORED(6),
  /// < entry is untracked item in workdir
  GIT_DELTA_UNTRACKED(7),
  /// < type of entry changed between old and new
  GIT_DELTA_TYPECHANGE(8),
  /// < entry is unreadable
  GIT_DELTA_UNREADABLE(9),
  /// < entry in the index is conflicted
  GIT_DELTA_CONFLICTED(10);


  final int value;
  const git_delta_t(this.value);

  static git_delta_t fromValue(int value) => switch (value) {
    0 => GIT_DELTA_UNMODIFIED,
    1 => GIT_DELTA_ADDED,
    2 => GIT_DELTA_DELETED,
    3 => GIT_DELTA_MODIFIED,
    4 => GIT_DELTA_RENAMED,
    5 => GIT_DELTA_COPIED,
    6 => GIT_DELTA_IGNORED,
    7 => GIT_DELTA_UNTRACKED,
    8 => GIT_DELTA_TYPECHANGE,
    9 => GIT_DELTA_UNREADABLE,
    10 => GIT_DELTA_CONFLICTED,
    _ => throw ArgumentError('Unknown value for git_delta_t: $value'),
  };

}

/// Description of one side of a delta.
/// 
/// Although this is called a "file", it could represent a file, a symbolic
/// link, a submodule commit id, or even a tree (although that only if you
/// are tracking type changes or ignored/untracked directories).
final class git_diff_file extends ffi.Struct{
  /// The `git_oid` of the item.  If the entry represents an
  /// absent side of a diff (e.g. the `old_file` of a `GIT_DELTA_ADDED` delta),
  /// then the oid will be zeroes.
  external git_oid id;

  /// The NUL-terminated path to the entry relative to the working
  /// directory of the repository.
  external ffi.Pointer<ffi.Char> path;

  /// The size of the entry in bytes.
  @ffi.Uint64()
  external int size;

  /// A combination of the `git_diff_flag_t` types
  @ffi.Uint32()
  external int flags;

  /// Roughly, the stat() `st_mode` value for the item.  This will
  /// be restricted to one of the `git_filemode_t` values.
  @ffi.Uint16()
  external int mode;

  /// Represents the known length of the `id` field, when
  /// converted to a hex string.  It is generally `GIT_OID_SHA1_HEXSIZE`, unless this
  /// delta was created from reading a patch file, in which case it may be
  /// abbreviated to something reasonable, like 7 characters.
  @ffi.Uint16()
  external int id_abbrev;

}

/// Description of changes to one entry.
/// 
/// A `delta` is a file pair with an old and new revision.  The old version
/// may be absent if the file was just created and the new version may be
/// absent if the file was deleted.  A diff is mostly just a list of deltas.
/// 
/// When iterating over a diff, this will be passed to most callbacks and
/// you can use the contents to understand exactly what has changed.
/// 
/// The `old_file` represents the "from" side of the diff and the `new_file`
/// represents to "to" side of the diff.  What those means depend on the
/// function that was used to generate the diff and will be documented below.
/// You can also use the `GIT_DIFF_REVERSE` flag to flip it around.
/// 
/// Although the two sides of the delta are named "old_file" and "new_file",
/// they actually may correspond to entries that represent a file, a symbolic
/// link, a submodule commit id, or even a tree (if you are tracking type
/// changes or ignored/untracked directories).
/// 
/// Under some circumstances, in the name of efficiency, not all fields will
/// be filled in, but we generally try to fill in as much as possible.  One
/// example is that the "flags" field may not have either the `BINARY` or the
/// `NOT_BINARY` flag set to avoid examining file contents if you do not pass
/// in hunk and/or line callbacks to the diff foreach iteration function.  It
/// will just use the git attributes for those files.
/// 
/// The similarity score is zero unless you call `git_diff_find_similar()`
/// which does a similarity analysis of files in the diff.  Use that
/// function to do rename and copy detection, and to split heavily modified
/// files in add/delete pairs.  After that call, deltas with a status of
/// GIT_DELTA_RENAMED or GIT_DELTA_COPIED will have a similarity score
/// between 0 and 100 indicating how similar the old and new sides are.
/// 
/// If you ask `git_diff_find_similar` to find heavily modified files to
/// break, but to not *actually* break the records, then GIT_DELTA_MODIFIED
/// records may have a non-zero similarity score if the self-similarity is
/// below the split threshold.  To display this value like core Git, invert
/// the score (a la `printf("M%03d", 100 - delta->similarity)`).
final class git_diff_delta extends ffi.Struct{
  @ffi.UnsignedInt()
  external int statusAsInt;

git_delta_t get status => git_delta_t.fromValue(statusAsInt);

  /// < git_diff_flag_t values
  @ffi.Uint32()
  external int flags;

  /// < for RENAMED and COPIED, value 0-100
  @ffi.Uint16()
  external int similarity;

  /// < number of files in this delta
  @ffi.Uint16()
  external int nfiles;

  external git_diff_file old_file;

  external git_diff_file new_file;

}

/// Structure describing options about how the diff should be executed.
/// 
/// Setting all values of the structure to zero will yield the default
/// values.  Similarly, passing NULL for the options structure will
/// give the defaults.  The default values are marked below.
final class git_diff_options extends ffi.Struct{
  /// < version for the struct
  @ffi.UnsignedInt()
  external int version;

  /// A combination of `git_diff_option_t` values above.
  /// Defaults to GIT_DIFF_NORMAL
  @ffi.Uint32()
  external int flags;

  /// Overrides the submodule ignore setting for all submodules in the diff.
  @ffi.Int()
  external int ignore_submodulesAsInt;

git_submodule_ignore_t get ignore_submodules => git_submodule_ignore_t.fromValue(ignore_submodulesAsInt);

  /// An array of paths / fnmatch patterns to constrain diff.
  /// All paths are included by default.
  external git_strarray pathspec;

  /// An optional callback function, notifying the consumer of changes to
  /// the diff as new deltas are added.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff> diff_so_far, ffi.Pointer<git_diff_delta> delta_to_add, ffi.Pointer<ffi.Char> matched_pathspec, ffi.Pointer<ffi.Void> payload)>> notify_cb;

  /// An optional callback function, notifying the consumer of which files
  /// are being examined as the diff is generated.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff> diff_so_far, ffi.Pointer<ffi.Char> old_path, ffi.Pointer<ffi.Char> new_path, ffi.Pointer<ffi.Void> payload)>> progress_cb;

  /// The payload to pass to the callback functions.
  external ffi.Pointer<ffi.Void> payload;

  /// The number of unchanged lines that define the boundary of a hunk
  /// (and to display before and after). Defaults to 3.
  @ffi.Uint32()
  external int context_lines;

  /// The maximum number of unchanged lines between hunk boundaries before
  /// the hunks will be merged into one. Defaults to 0.
  @ffi.Uint32()
  external int interhunk_lines;

  /// The object ID type to emit in diffs; this is used by functions
  /// that operate without a repository - namely `git_diff_buffers`,
  /// or `git_diff_blobs` and `git_diff_blob_to_buffer` when one blob
  /// is `NULL`.
  /// 
  /// This may be omitted (set to `0`). If a repository is available,
  /// the object ID format of the repository will be used. If no
  /// repository is available then the default is `GIT_OID_SHA`.
  /// 
  /// If this is specified and a repository is available, then the
  /// specified `oid_type` must match the repository's object ID
  /// format.
  @ffi.UnsignedInt()
  external int oid_typeAsInt;

git_oid_t get oid_type => git_oid_t.fromValue(oid_typeAsInt);

  /// The abbreviation length to use when formatting object ids.
  /// Defaults to the value of 'core.abbrev' from the config, or 7 if unset.
  @ffi.Uint16()
  external int id_abbrev;

  /// A size (in bytes) above which a blob will be marked as binary
  /// automatically; pass a negative value to disable.
  /// Defaults to 512MB.
  @ffi.Int64()
  external int max_size;

  /// The virtual "directory" prefix for old file names in hunk headers.
  /// Default is "a".
  external ffi.Pointer<ffi.Char> old_prefix;

  /// The virtual "directory" prefix for new file names in hunk headers.
  /// Defaults to "b".
  external ffi.Pointer<ffi.Char> new_prefix;

}

/// When producing a binary diff, the binary data returned will be
/// either the deflated full ("literal") contents of the file, or
/// the deflated binary delta between the two sides (whichever is
/// smaller).
enum git_diff_binary_t {
  /// There is no binary delta.
  GIT_DIFF_BINARY_NONE(0),
  /// The binary data is the literal contents of the file.
  GIT_DIFF_BINARY_LITERAL(1),
  /// The binary data is the delta from one side to the other.
  GIT_DIFF_BINARY_DELTA(2);


  final int value;
  const git_diff_binary_t(this.value);

  static git_diff_binary_t fromValue(int value) => switch (value) {
    0 => GIT_DIFF_BINARY_NONE,
    1 => GIT_DIFF_BINARY_LITERAL,
    2 => GIT_DIFF_BINARY_DELTA,
    _ => throw ArgumentError('Unknown value for git_diff_binary_t: $value'),
  };

}

/// The contents of one of the files in a binary diff.
final class git_diff_binary_file extends ffi.Struct{
  /// The type of binary data for this file.
  @ffi.UnsignedInt()
  external int typeAsInt;

git_diff_binary_t get type => git_diff_binary_t.fromValue(typeAsInt);

  /// The binary data, deflated.
  external ffi.Pointer<ffi.Char> data;

  /// The length of the binary data.
  @ffi.Size()
  external int datalen;

  /// The length of the binary data after inflation.
  @ffi.Size()
  external int inflatedlen;

}

/// Structure describing the binary contents of a diff.
/// 
/// A `binary` file / delta is a file (or pair) for which no text diffs
/// should be generated. A diff can contain delta entries that are
/// binary, but no diff content will be output for those files. There is
/// a base heuristic for binary detection and you can further tune the
/// behavior with git attributes or diff flags and option settings.
final class git_diff_binary extends ffi.Struct{
  /// Whether there is data in this binary structure or not.
  /// 
  /// If this is `1`, then this was produced and included binary content.
  /// If this is `0` then this was generated knowing only that a binary
  /// file changed but without providing the data, probably from a patch
  /// that said `Binary files a/file.txt and b/file.txt differ`.
  @ffi.UnsignedInt()
  external int contains_data;

  /// < The contents of the old file.
  external git_diff_binary_file old_file;

  /// < The contents of the new file.
  external git_diff_binary_file new_file;

}

/// Structure describing a hunk of a diff.
/// 
/// A `hunk` is a span of modified lines in a delta along with some stable
/// surrounding context. You can configure the amount of context and other
/// properties of how hunks are generated. Each hunk also comes with a
/// header that described where it starts and ends in both the old and new
/// versions in the delta.
final class git_diff_hunk extends ffi.Struct{
  /// < Starting line number in old_file
  @ffi.Int()
  external int old_start;

  /// < Number of lines in old_file
  @ffi.Int()
  external int old_lines;

  /// < Starting line number in new_file
  @ffi.Int()
  external int new_start;

  /// < Number of lines in new_file
  @ffi.Int()
  external int new_lines;

  /// < Number of bytes in header text
  @ffi.Size()
  external int header_len;

  /// < Header text, NUL-byte terminated
@ffi.Array.multi([128])
  external ffi.Array<ffi.Char> header;

}

/// Line origin constants.
/// 
/// These values describe where a line came from and will be passed to
/// the git_diff_line_cb when iterating over a diff.  There are some
/// special origin constants at the end that are used for the text
/// output callbacks to demarcate lines that are actually part of
/// the file or hunk headers.
enum git_diff_line_t {
  GIT_DIFF_LINE_CONTEXT(32),
  GIT_DIFF_LINE_ADDITION(43),
  GIT_DIFF_LINE_DELETION(45),
  /// < Both files have no LF at end
  GIT_DIFF_LINE_CONTEXT_EOFNL(61),
  /// < Old has no LF at end, new does
  GIT_DIFF_LINE_ADD_EOFNL(62),
  /// < Old has LF at end, new does not
  GIT_DIFF_LINE_DEL_EOFNL(60),
  GIT_DIFF_LINE_FILE_HDR(70),
  GIT_DIFF_LINE_HUNK_HDR(72),
  /// < For "Binary files x and y differ"
  GIT_DIFF_LINE_BINARY(66);


  final int value;
  const git_diff_line_t(this.value);

  static git_diff_line_t fromValue(int value) => switch (value) {
    32 => GIT_DIFF_LINE_CONTEXT,
    43 => GIT_DIFF_LINE_ADDITION,
    45 => GIT_DIFF_LINE_DELETION,
    61 => GIT_DIFF_LINE_CONTEXT_EOFNL,
    62 => GIT_DIFF_LINE_ADD_EOFNL,
    60 => GIT_DIFF_LINE_DEL_EOFNL,
    70 => GIT_DIFF_LINE_FILE_HDR,
    72 => GIT_DIFF_LINE_HUNK_HDR,
    66 => GIT_DIFF_LINE_BINARY,
    _ => throw ArgumentError('Unknown value for git_diff_line_t: $value'),
  };

}

/// Structure describing a line (or data span) of a diff.
/// 
/// A `line` is a range of characters inside a hunk.  It could be a context
/// line (i.e. in both old and new versions), an added line (i.e. only in
/// the new version), or a removed line (i.e. only in the old version).
/// Unfortunately, we don't know anything about the encoding of data in the
/// file being diffed, so we cannot tell you much about the line content.
/// Line data will not be NUL-byte terminated, however, because it will be
/// just a span of bytes inside the larger file.
final class git_diff_line extends ffi.Struct{
  /// < A git_diff_line_t value
  @ffi.Char()
  external int origin;

  /// < Line number in old file or -1 for added line
  @ffi.Int()
  external int old_lineno;

  /// < Line number in new file or -1 for deleted line
  @ffi.Int()
  external int new_lineno;

  /// < Number of newline characters in content
  @ffi.Int()
  external int num_lines;

  /// < Number of bytes of data
  @ffi.Size()
  external int content_len;

  /// < Offset in the original file to the content
  @ffi.Int64()
  external int content_offset;

  /// < Pointer to diff text, not NUL-byte terminated
  external ffi.Pointer<ffi.Char> content;

}

/// Flags to control the behavior of diff rename/copy detection.
enum git_diff_find_t {
  /// Obey `diff.renames`. Overridden by any other GIT_DIFF_FIND_... flag.
  GIT_DIFF_FIND_BY_CONFIG(0),
  /// Look for renames? (`--find-renames`)
  GIT_DIFF_FIND_RENAMES(1),
  /// Consider old side of MODIFIED for renames? (`--break-rewrites=N`)
  GIT_DIFF_FIND_RENAMES_FROM_REWRITES(2),
  /// Look for copies? (a la `--find-copies`).
  GIT_DIFF_FIND_COPIES(4),
  /// Consider UNMODIFIED as copy sources? (`--find-copies-harder`).
  /// 
  /// For this to work correctly, use GIT_DIFF_INCLUDE_UNMODIFIED when
  /// the initial `git_diff` is being generated.
  GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED(8),
  /// Mark significant rewrites for split (`--break-rewrites=/M`)
  GIT_DIFF_FIND_REWRITES(16),
  /// Actually split large rewrites into delete/add pairs
  GIT_DIFF_BREAK_REWRITES(32),
  /// Mark rewrites for split and break into delete/add pairs
  GIT_DIFF_FIND_AND_BREAK_REWRITES(48),
  /// Find renames/copies for UNTRACKED items in working directory.
  /// 
  /// For this to work correctly, use GIT_DIFF_INCLUDE_UNTRACKED when the
  /// initial `git_diff` is being generated (and obviously the diff must
  /// be against the working directory for this to make sense).
  GIT_DIFF_FIND_FOR_UNTRACKED(64),
  /// Turn on all finding features.
  GIT_DIFF_FIND_ALL(255),
  /// Measure similarity ignoring all whitespace
  GIT_DIFF_FIND_IGNORE_WHITESPACE(4096),
  /// Measure similarity including all data
  GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE(8192),
  /// Measure similarity only by comparing SHAs (fast and cheap)
  GIT_DIFF_FIND_EXACT_MATCH_ONLY(16384),
  /// Do not break rewrites unless they contribute to a rename.
  /// 
  /// Normally, GIT_DIFF_FIND_AND_BREAK_REWRITES will measure the self-
  /// similarity of modified files and split the ones that have changed a
  /// lot into a DELETE / ADD pair.  Then the sides of that pair will be
  /// considered candidates for rename and copy detection.
  /// 
  /// If you add this flag in and the split pair is *not* used for an
  /// actual rename or copy, then the modified record will be restored to
  /// a regular MODIFIED record instead of being split.
  GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY(32768),
  /// Remove any UNMODIFIED deltas after find_similar is done.
  /// 
  /// Using GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED to emulate the
  /// --find-copies-harder behavior requires building a diff with the
  /// GIT_DIFF_INCLUDE_UNMODIFIED flag.  If you do not want UNMODIFIED
  /// records in the final result, pass this flag to have them removed.
  GIT_DIFF_FIND_REMOVE_UNMODIFIED(65536);

  /// Measure similarity ignoring leading whitespace (default)
  static const GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE = GIT_DIFF_FIND_BY_CONFIG;

  final int value;
  const git_diff_find_t(this.value);

  static git_diff_find_t fromValue(int value) => switch (value) {
    0 => GIT_DIFF_FIND_BY_CONFIG,
    1 => GIT_DIFF_FIND_RENAMES,
    2 => GIT_DIFF_FIND_RENAMES_FROM_REWRITES,
    4 => GIT_DIFF_FIND_COPIES,
    8 => GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED,
    16 => GIT_DIFF_FIND_REWRITES,
    32 => GIT_DIFF_BREAK_REWRITES,
    48 => GIT_DIFF_FIND_AND_BREAK_REWRITES,
    64 => GIT_DIFF_FIND_FOR_UNTRACKED,
    255 => GIT_DIFF_FIND_ALL,
    4096 => GIT_DIFF_FIND_IGNORE_WHITESPACE,
    8192 => GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE,
    16384 => GIT_DIFF_FIND_EXACT_MATCH_ONLY,
    32768 => GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY,
    65536 => GIT_DIFF_FIND_REMOVE_UNMODIFIED,
    _ => throw ArgumentError('Unknown value for git_diff_find_t: $value'),
  };

  @override
  String toString() {
    if (this == GIT_DIFF_FIND_BY_CONFIG) return "git_diff_find_t.GIT_DIFF_FIND_BY_CONFIG, git_diff_find_t.GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE";
    return super.toString();
  }}

/// Pluggable similarity metric
final class git_diff_similarity_metric extends ffi.Struct{
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>> out, ffi.Pointer<git_diff_file> file, ffi.Pointer<ffi.Char> fullpath, ffi.Pointer<ffi.Void> payload)>> file_signature;

  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>> out, ffi.Pointer<git_diff_file> file, ffi.Pointer<ffi.Char> buf, ffi.Size buflen, ffi.Pointer<ffi.Void> payload)>> buffer_signature;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> sig, ffi.Pointer<ffi.Void> payload)>> free_signature;

  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Int> score, ffi.Pointer<ffi.Void> siga, ffi.Pointer<ffi.Void> sigb, ffi.Pointer<ffi.Void> payload)>> similarity;

  external ffi.Pointer<ffi.Void> payload;

}

/// Control behavior of rename and copy detection
/// 
/// These options mostly mimic parameters that can be passed to git-diff.
final class git_diff_find_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// Combination of git_diff_find_t values (default GIT_DIFF_FIND_BY_CONFIG).
  /// NOTE: if you don't explicitly set this, `diff.renames` could be set
  /// to false, resulting in `git_diff_find_similar` doing nothing.
  @ffi.Uint32()
  external int flags;

  /// Threshold above which similar files will be considered renames.
  /// This is equivalent to the -M option. Defaults to 50.
  @ffi.Uint16()
  external int rename_threshold;

  /// Threshold below which similar files will be eligible to be a rename source.
  /// This is equivalent to the first part of the -B option. Defaults to 50.
  @ffi.Uint16()
  external int rename_from_rewrite_threshold;

  /// Threshold above which similar files will be considered copies.
  /// This is equivalent to the -C option. Defaults to 50.
  @ffi.Uint16()
  external int copy_threshold;

  /// Threshold below which similar files will be split into a delete/add pair.
  /// This is equivalent to the last part of the -B option. Defaults to 60.
  @ffi.Uint16()
  external int break_rewrite_threshold;

  /// Maximum number of matches to consider for a particular file.
  /// 
  /// This is a little different from the `-l` option from Git because we
  /// will still process up to this many matches before abandoning the search.
  /// Defaults to 1000.
  @ffi.Size()
  external int rename_limit;

  /// The `metric` option allows you to plug in a custom similarity metric.
  /// 
  /// Set it to NULL to use the default internal metric.
  /// 
  /// The default metric is based on sampling hashes of ranges of data in
  /// the file, which is a pretty good similarity approximation that should
  /// work fairly well for both text and binary data while still being
  /// pretty fast with a fixed memory overhead.
  external ffi.Pointer<git_diff_similarity_metric> metric;

}

/// Possible output formats for diff data
enum git_diff_format_t {
  /// < full git diff
  GIT_DIFF_FORMAT_PATCH(1),
  /// < just the file headers of patch
  GIT_DIFF_FORMAT_PATCH_HEADER(2),
  /// < like git diff --raw
  GIT_DIFF_FORMAT_RAW(3),
  /// < like git diff --name-only
  GIT_DIFF_FORMAT_NAME_ONLY(4),
  /// < like git diff --name-status
  GIT_DIFF_FORMAT_NAME_STATUS(5),
  /// < git diff as used by git patch-id
  GIT_DIFF_FORMAT_PATCH_ID(6);


  final int value;
  const git_diff_format_t(this.value);

  static git_diff_format_t fromValue(int value) => switch (value) {
    1 => GIT_DIFF_FORMAT_PATCH,
    2 => GIT_DIFF_FORMAT_PATCH_HEADER,
    3 => GIT_DIFF_FORMAT_RAW,
    4 => GIT_DIFF_FORMAT_NAME_ONLY,
    5 => GIT_DIFF_FORMAT_NAME_STATUS,
    6 => GIT_DIFF_FORMAT_PATCH_ID,
    _ => throw ArgumentError('Unknown value for git_diff_format_t: $value'),
  };

}

/// Options for parsing a diff / patch file.
final class git_diff_parse_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  @ffi.UnsignedInt()
  external int oid_typeAsInt;

git_oid_t get oid_type => git_oid_t.fromValue(oid_typeAsInt);

}

final class git_diff_stats extends ffi.Opaque{
}

/// Formatting options for diff stats
enum git_diff_stats_format_t {
  /// No stats
  GIT_DIFF_STATS_NONE(0),
  /// Full statistics, equivalent of `--stat`
  GIT_DIFF_STATS_FULL(1),
  /// Short statistics, equivalent of `--shortstat`
  GIT_DIFF_STATS_SHORT(2),
  /// Number statistics, equivalent of `--numstat`
  GIT_DIFF_STATS_NUMBER(4),
  /// Extended header information such as creations, renames and mode changes, equivalent of `--summary`
  GIT_DIFF_STATS_INCLUDE_SUMMARY(8);


  final int value;
  const git_diff_stats_format_t(this.value);

  static git_diff_stats_format_t fromValue(int value) => switch (value) {
    0 => GIT_DIFF_STATS_NONE,
    1 => GIT_DIFF_STATS_FULL,
    2 => GIT_DIFF_STATS_SHORT,
    4 => GIT_DIFF_STATS_NUMBER,
    8 => GIT_DIFF_STATS_INCLUDE_SUMMARY,
    _ => throw ArgumentError('Unknown value for git_diff_stats_format_t: $value'),
  };

}

/// Patch ID options structure
/// 
/// Initialize with `GIT_PATCHID_OPTIONS_INIT`. Alternatively, you can
/// use `git_diff_patchid_options_init`.
final class git_diff_patchid_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

}

/// Flags controlling the behavior of `git_apply`.
/// 
/// When the callback:
/// - returns < 0, the apply process will be aborted.
/// - returns > 0, the hunk will not be applied, but the apply process
/// continues
/// - returns 0, the hunk is applied, and the apply process continues.
enum git_apply_flags_t {
  /// Don't actually make changes, just test that the patch applies.
  /// This is the equivalent of `git apply --check`.
  GIT_APPLY_CHECK(1);


  final int value;
  const git_apply_flags_t(this.value);

  static git_apply_flags_t fromValue(int value) => switch (value) {
    1 => GIT_APPLY_CHECK,
    _ => throw ArgumentError('Unknown value for git_apply_flags_t: $value'),
  };

}

/// Apply options structure.
/// 
/// When the callback:
/// - returns < 0, the apply process will be aborted.
/// - returns > 0, the hunk will not be applied, but the apply process
/// continues
/// - returns 0, the hunk is applied, and the apply process continues.
/// 
/// Initialize with `GIT_APPLY_OPTIONS_INIT`. Alternatively, you can
/// use `git_apply_options_init`.
/// 
/// @see git_apply_to_tree
/// @see git_apply
final class git_apply_options extends ffi.Struct{
  /// < The version
  @ffi.UnsignedInt()
  external int version;

  /// When applying a patch, callback that will be made per delta (file).
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_delta> delta, ffi.Pointer<ffi.Void> payload)>> delta_cb;

  /// When applying a patch, callback that will be made per hunk.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<ffi.Void> payload)>> hunk_cb;

  /// Payload passed to both `delta_cb` & `hunk_cb`.
  external ffi.Pointer<ffi.Void> payload;

  /// Bitmask of `git_apply_flags_t`
  @ffi.UnsignedInt()
  external int flags;

}

/// Possible application locations for git_apply
enum git_apply_location_t {
  /// Apply the patch to the workdir, leaving the index untouched.
  /// This is the equivalent of `git apply` with no location argument.
  GIT_APPLY_LOCATION_WORKDIR(0),
  /// Apply the patch to the index, leaving the working directory
  /// untouched.  This is the equivalent of `git apply --cached`.
  GIT_APPLY_LOCATION_INDEX(1),
  /// Apply the patch to both the working directory and the index.
  /// This is the equivalent of `git apply --index`.
  GIT_APPLY_LOCATION_BOTH(2);


  final int value;
  const git_apply_location_t(this.value);

  static git_apply_location_t fromValue(int value) => switch (value) {
    0 => GIT_APPLY_LOCATION_WORKDIR,
    1 => GIT_APPLY_LOCATION_INDEX,
    2 => GIT_APPLY_LOCATION_BOTH,
    _ => throw ArgumentError('Unknown value for git_apply_location_t: $value'),
  };

}

/// Possible states for an attribute
enum git_attr_value_t {
  /// < The attribute has been left unspecified
  GIT_ATTR_VALUE_UNSPECIFIED(0),
  /// < The attribute has been set
  GIT_ATTR_VALUE_TRUE(1),
  /// < The attribute has been unset
  GIT_ATTR_VALUE_FALSE(2),
  /// < This attribute has a value
  GIT_ATTR_VALUE_STRING(3);


  final int value;
  const git_attr_value_t(this.value);

  static git_attr_value_t fromValue(int value) => switch (value) {
    0 => GIT_ATTR_VALUE_UNSPECIFIED,
    1 => GIT_ATTR_VALUE_TRUE,
    2 => GIT_ATTR_VALUE_FALSE,
    3 => GIT_ATTR_VALUE_STRING,
    _ => throw ArgumentError('Unknown value for git_attr_value_t: $value'),
  };

}

/// An options structure for querying attributes.
final class git_attr_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// A combination of GIT_ATTR_CHECK flags
  @ffi.UnsignedInt()
  external int flags;

  external ffi.Pointer<git_oid> commit_id;

  /// The commit to load attributes from, when
  /// `GIT_ATTR_CHECK_INCLUDE_COMMIT` is specified.
  external git_oid attr_commit_id;

}

/// Flags to control the functionality of `git_blob_filter`.
/// 
/// @flags
enum git_blob_filter_flag_t {
  /// When set, filters will not be applied to binary files.
  GIT_BLOB_FILTER_CHECK_FOR_BINARY(1),
  /// When set, filters will not load configuration from the
  /// system-wide `gitattributes` in `/etc` (or system equivalent).
  GIT_BLOB_FILTER_NO_SYSTEM_ATTRIBUTES(2),
  /// When set, filters will be loaded from a `.gitattributes` file
  /// in the HEAD commit.
  GIT_BLOB_FILTER_ATTRIBUTES_FROM_HEAD(4),
  /// When set, filters will be loaded from a `.gitattributes` file
  /// in the specified commit.
  GIT_BLOB_FILTER_ATTRIBUTES_FROM_COMMIT(8);


  final int value;
  const git_blob_filter_flag_t(this.value);

  static git_blob_filter_flag_t fromValue(int value) => switch (value) {
    1 => GIT_BLOB_FILTER_CHECK_FOR_BINARY,
    2 => GIT_BLOB_FILTER_NO_SYSTEM_ATTRIBUTES,
    4 => GIT_BLOB_FILTER_ATTRIBUTES_FROM_HEAD,
    8 => GIT_BLOB_FILTER_ATTRIBUTES_FROM_COMMIT,
    _ => throw ArgumentError('Unknown value for git_blob_filter_flag_t: $value'),
  };

}

/// The options used when applying filter options to a file.
/// 
/// Initialize with `GIT_BLOB_FILTER_OPTIONS_INIT`. Alternatively, you can
/// use `git_blob_filter_options_init`.
/// 
/// @options[version] GIT_BLOB_FILTER_OPTIONS_VERSION
/// @options[init_macro] GIT_BLOB_FILTER_OPTIONS_INIT
/// @options[init_function] git_blob_filter_options_init
final class git_blob_filter_options extends ffi.Struct{
  /// Version number of the options structure.
  @ffi.Int()
  external int version;

  /// Flags to control the filtering process, see `git_blob_filter_flag_t` above.
  /// 
  /// @type[flags] git_blob_filter_flag_t
  @ffi.Uint32()
  external int flags;

  /// This value is unused and reserved for API compatibility.
  /// 
  /// @deprecated this value should not be set
  external ffi.Pointer<git_oid> commit_id;

  /// The commit to load attributes from, when
  /// `GIT_BLOB_FILTER_ATTRIBUTES_FROM_COMMIT` is specified.
  external git_oid attr_commit_id;

}

/// Flags for indicating option behavior for git_blame APIs.
enum git_blame_flag_t {
  /// Normal blame, the default
  GIT_BLAME_NORMAL(0),
  /// Track lines that have moved within a file (like `git blame -M`).
  /// 
  /// This is not yet implemented and reserved for future use.
  GIT_BLAME_TRACK_COPIES_SAME_FILE(1),
  /// Track lines that have moved across files in the same commit
  /// (like `git blame -C`).
  /// 
  /// This is not yet implemented and reserved for future use.
  GIT_BLAME_TRACK_COPIES_SAME_COMMIT_MOVES(2),
  /// Track lines that have been copied from another file that exists
  /// in the same commit (like `git blame -CC`).  Implies SAME_FILE.
  /// 
  /// This is not yet implemented and reserved for future use.
  GIT_BLAME_TRACK_COPIES_SAME_COMMIT_COPIES(4),
  /// Track lines that have been copied from another file that exists in
  /// *any* commit (like `git blame -CCC`).  Implies SAME_COMMIT_COPIES.
  /// 
  /// This is not yet implemented and reserved for future use.
  GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES(8),
  /// Restrict the search of commits to those reachable following only
  /// the first parents.
  GIT_BLAME_FIRST_PARENT(16),
  /// Use mailmap file to map author and committer names and email
  /// addresses to canonical real names and email addresses. The
  /// mailmap will be read from the working directory, or HEAD in a
  /// bare repository.
  GIT_BLAME_USE_MAILMAP(32),
  /// Ignore whitespace differences
  GIT_BLAME_IGNORE_WHITESPACE(64);


  final int value;
  const git_blame_flag_t(this.value);

  static git_blame_flag_t fromValue(int value) => switch (value) {
    0 => GIT_BLAME_NORMAL,
    1 => GIT_BLAME_TRACK_COPIES_SAME_FILE,
    2 => GIT_BLAME_TRACK_COPIES_SAME_COMMIT_MOVES,
    4 => GIT_BLAME_TRACK_COPIES_SAME_COMMIT_COPIES,
    8 => GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES,
    16 => GIT_BLAME_FIRST_PARENT,
    32 => GIT_BLAME_USE_MAILMAP,
    64 => GIT_BLAME_IGNORE_WHITESPACE,
    _ => throw ArgumentError('Unknown value for git_blame_flag_t: $value'),
  };

}

/// Blame options structure
/// 
/// Initialize with `GIT_BLAME_OPTIONS_INIT`. Alternatively, you can
/// use `git_blame_options_init`.
final class git_blame_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// A combination of `git_blame_flag_t`
  @ffi.UnsignedInt()
  external int flags;

  /// The lower bound on the number of alphanumeric characters that
  /// must be detected as moving/copying within a file for it to
  /// associate those lines with the parent commit. The default value
  /// is 20.
  /// 
  /// This value only takes effect if any of the `GIT_BLAME_TRACK_COPIES_*`
  /// flags are specified.
  @ffi.Uint16()
  external int min_match_characters;

  /// The id of the newest commit to consider. The default is HEAD.
  external git_oid newest_commit;

  /// The id of the oldest commit to consider.
  /// The default is the first commit encountered with a NULL parent.
  external git_oid oldest_commit;

  /// The first line in the file to blame.
  /// The default is 1 (line numbers start with 1).
  @ffi.Size()
  external int min_line;

  /// The last line in the file to blame.
  /// The default is the last line of the file.
  @ffi.Size()
  external int max_line;

}

/// Structure that represents a blame hunk.
final class git_blame_hunk extends ffi.Struct{
  /// The number of lines in this hunk.
  @ffi.Size()
  external int lines_in_hunk;

  /// The OID of the commit where this line was last changed.
  external git_oid final_commit_id;

  /// The 1-based line number where this hunk begins, in the final version
  /// of the file.
  @ffi.Size()
  external int final_start_line_number;

  /// The author of `final_commit_id`. If `GIT_BLAME_USE_MAILMAP` has been
  /// specified, it will contain the canonical real name and email address.
  external ffi.Pointer<git_signature> final_signature;

  /// The committer of `final_commit_id`. If `GIT_BLAME_USE_MAILMAP` has
  /// been specified, it will contain the canonical real name and email
  /// address.
  external ffi.Pointer<git_signature> final_committer;

  /// The OID of the commit where this hunk was found.
  /// This will usually be the same as `final_commit_id`, except when
  /// `GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES` has been specified.
  external git_oid orig_commit_id;

  /// The path to the file where this hunk originated, as of the commit
  /// specified by `orig_commit_id`.
  external ffi.Pointer<ffi.Char> orig_path;

  /// The 1-based line number where this hunk begins in the file named by
  /// `orig_path` in the commit specified by `orig_commit_id`.
  @ffi.Size()
  external int orig_start_line_number;

  /// The author of `orig_commit_id`. If `GIT_BLAME_USE_MAILMAP` has been
  /// specified, it will contain the canonical real name and email address.
  external ffi.Pointer<git_signature> orig_signature;

  /// The committer of `orig_commit_id`. If `GIT_BLAME_USE_MAILMAP` has
  /// been specified, it will contain the canonical real name and email
  /// address.
  external ffi.Pointer<git_signature> orig_committer;

  external ffi.Pointer<ffi.Char> summary;

  /// The 1 iff the hunk has been tracked to a boundary commit (the root,
  /// or the commit specified in git_blame_options.oldest_commit)
  @ffi.Char()
  external int boundary;

}

/// Structure that represents a line in a blamed file.
final class git_blame_line extends ffi.Struct{
  external ffi.Pointer<ffi.Char> ptr;

  @ffi.Size()
  external int len;

}

final class git_blame extends ffi.Opaque{
}

final class git_branch_iterator extends ffi.Opaque{
}

/// Type of SSH host fingerprint
enum git_cert_ssh_t {
  /// MD5 is available
  GIT_CERT_SSH_MD5(1),
  /// SHA-1 is available
  GIT_CERT_SSH_SHA1(2),
  /// SHA-256 is available
  GIT_CERT_SSH_SHA256(4),
  /// Raw hostkey is available
  GIT_CERT_SSH_RAW(8);


  final int value;
  const git_cert_ssh_t(this.value);

  static git_cert_ssh_t fromValue(int value) => switch (value) {
    1 => GIT_CERT_SSH_MD5,
    2 => GIT_CERT_SSH_SHA1,
    4 => GIT_CERT_SSH_SHA256,
    8 => GIT_CERT_SSH_RAW,
    _ => throw ArgumentError('Unknown value for git_cert_ssh_t: $value'),
  };

}

enum git_cert_ssh_raw_type_t {
  /// The raw key is of an unknown type.
  GIT_CERT_SSH_RAW_TYPE_UNKNOWN(0),
  /// The raw key is an RSA key.
  GIT_CERT_SSH_RAW_TYPE_RSA(1),
  /// The raw key is a DSS key.
  GIT_CERT_SSH_RAW_TYPE_DSS(2),
  /// The raw key is a ECDSA 256 key.
  GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_256(3),
  /// The raw key is a ECDSA 384 key.
  GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_384(4),
  /// The raw key is a ECDSA 521 key.
  GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_521(5),
  /// The raw key is a ED25519 key.
  GIT_CERT_SSH_RAW_TYPE_KEY_ED25519(6);


  final int value;
  const git_cert_ssh_raw_type_t(this.value);

  static git_cert_ssh_raw_type_t fromValue(int value) => switch (value) {
    0 => GIT_CERT_SSH_RAW_TYPE_UNKNOWN,
    1 => GIT_CERT_SSH_RAW_TYPE_RSA,
    2 => GIT_CERT_SSH_RAW_TYPE_DSS,
    3 => GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_256,
    4 => GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_384,
    5 => GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_521,
    6 => GIT_CERT_SSH_RAW_TYPE_KEY_ED25519,
    _ => throw ArgumentError('Unknown value for git_cert_ssh_raw_type_t: $value'),
  };

}

/// Hostkey information taken from libssh2
final class git_cert_hostkey extends ffi.Struct{
  /// < The parent cert
  external git_cert parent;

  /// A bitmask containing the available fields.
  @ffi.UnsignedInt()
  external int typeAsInt;

git_cert_ssh_t get type => git_cert_ssh_t.fromValue(typeAsInt);

  /// Hostkey hash. If `type` has `GIT_CERT_SSH_MD5` set, this will
  /// have the MD5 hash of the hostkey.
@ffi.Array.multi([16])
  external ffi.Array<ffi.UnsignedChar> hash_md5;

  /// Hostkey hash. If `type` has `GIT_CERT_SSH_SHA1` set, this will
  /// have the SHA-1 hash of the hostkey.
@ffi.Array.multi([20])
  external ffi.Array<ffi.UnsignedChar> hash_sha1;

  /// Hostkey hash. If `type` has `GIT_CERT_SSH_SHA256` set, this will
  /// have the SHA-256 hash of the hostkey.
@ffi.Array.multi([32])
  external ffi.Array<ffi.UnsignedChar> hash_sha256;

  /// Raw hostkey type. If `type` has `GIT_CERT_SSH_RAW` set, this will
  /// have the type of the raw hostkey.
  @ffi.UnsignedInt()
  external int raw_typeAsInt;

git_cert_ssh_raw_type_t get raw_type => git_cert_ssh_raw_type_t.fromValue(raw_typeAsInt);

  /// Pointer to the raw hostkey. If `type` has `GIT_CERT_SSH_RAW` set,
  /// this will have the raw contents of the hostkey.
  external ffi.Pointer<ffi.Char> hostkey;

  /// Raw hostkey length. If `type` has `GIT_CERT_SSH_RAW` set, this will
  /// have the length of the raw contents of the hostkey.
  @ffi.Size()
  external int hostkey_len;

}

/// X.509 certificate information
final class git_cert_x509 extends ffi.Struct{
  /// < The parent cert
  external git_cert parent;

  /// Pointer to the X.509 certificate data
  external ffi.Pointer<ffi.Void> data;

  /// Length of the memory block pointed to by `data`.
  @ffi.Size()
  external int len;

}

/// Checkout behavior flags
/// 
/// In libgit2, checkout is used to update the working directory and index
/// to match a target tree.  Unlike git checkout, it does not move the HEAD
/// commit for you - use `git_repository_set_head` or the like to do that.
/// 
/// Checkout looks at (up to) four things: the "target" tree you want to
/// check out, the "baseline" tree of what was checked out previously, the
/// working directory for actual files, and the index for staged changes.
/// 
/// You give checkout one of two strategies for update:
/// 
/// - `GIT_CHECKOUT_SAFE` is the default, and similar to git's default,
/// which will make modifications that will not lose changes in the
/// working directory.
/// 
/// |  target == baseline   |  target != baseline  |
/// ---------------------|-----------------------|----------------------|
/// workdir == baseline |       no action       |  create, update, or  |
/// |                       |     delete file      |
/// ---------------------|-----------------------|----------------------|
/// workdir exists and  |       no action       |   conflict (notify   |
/// is != baseline    | notify dirty MODIFIED | and cancel checkout) |
/// ---------------------|-----------------------|----------------------|
/// workdir missing,   | notify dirty DELETED  |     create file      |
/// baseline present   |                       |                      |
/// ---------------------|-----------------------|----------------------|
/// 
/// - `GIT_CHECKOUT_FORCE` will take any action to make the working
/// directory match the target (including potentially discarding
/// modified files).
/// 
/// To emulate `git checkout`, use `GIT_CHECKOUT_SAFE` with a checkout
/// notification callback (see below) that displays information about dirty
/// files.  The default behavior will cancel checkout on conflicts.
/// 
/// To emulate `git checkout-index`, use `GIT_CHECKOUT_SAFE` with a
/// notification callback that cancels the operation if a dirty-but-existing
/// file is found in the working directory.  This core git command isn't
/// quite "force" but is sensitive about some types of changes.
/// 
/// To emulate `git checkout -f`, use `GIT_CHECKOUT_FORCE`.
/// 
/// 
/// There are some additional flags to modify the behavior of checkout:
/// 
/// - `GIT_CHECKOUT_DRY_RUN` is a dry-run strategy that checks for conflicts,
/// etc., but doesn't make any actual changes.
/// 
/// - GIT_CHECKOUT_ALLOW_CONFLICTS makes SAFE mode apply safe file updates
/// even if there are conflicts (instead of cancelling the checkout).
/// 
/// - GIT_CHECKOUT_REMOVE_UNTRACKED means remove untracked files (i.e. not
/// in target, baseline, or index, and not ignored) from the working dir.
/// 
/// - GIT_CHECKOUT_REMOVE_IGNORED means remove ignored files (that are also
/// untracked) from the working directory as well.
/// 
/// - GIT_CHECKOUT_UPDATE_ONLY means to only update the content of files that
/// already exist.  Files will not be created nor deleted.  This just skips
/// applying adds, deletes, and typechanges.
/// 
/// - GIT_CHECKOUT_DONT_UPDATE_INDEX prevents checkout from writing the
/// updated files' information to the index.
/// 
/// - Normally, checkout will reload the index and git attributes from disk
/// before any operations.  GIT_CHECKOUT_NO_REFRESH prevents this reload.
/// 
/// - Unmerged index entries are conflicts.  GIT_CHECKOUT_SKIP_UNMERGED skips
/// files with unmerged index entries instead.  GIT_CHECKOUT_USE_OURS and
/// GIT_CHECKOUT_USE_THEIRS to proceed with the checkout using either the
/// stage 2 ("ours") or stage 3 ("theirs") version of files in the index.
/// 
/// - GIT_CHECKOUT_DONT_OVERWRITE_IGNORED prevents ignored files from being
/// overwritten.  Normally, files that are ignored in the working directory
/// are not considered "precious" and may be overwritten if the checkout
/// target contains that file.
/// 
/// - GIT_CHECKOUT_DONT_REMOVE_EXISTING prevents checkout from removing
/// files or folders that fold to the same name on case insensitive
/// filesystems.  This can cause files to retain their existing names
/// and write through existing symbolic links.
/// 
/// @flags
enum git_checkout_strategy_t {
  /// Allow safe updates that cannot overwrite uncommitted data.
  /// If the uncommitted changes don't conflict with the checked
  /// out files, the checkout will still proceed, leaving the
  /// changes intact.
  GIT_CHECKOUT_SAFE(0),
  /// Allow all updates to force working directory to look like
  /// the index, potentially losing data in the process.
  GIT_CHECKOUT_FORCE(2),
  /// Allow checkout to recreate missing files
  GIT_CHECKOUT_RECREATE_MISSING(4),
  /// Allow checkout to make safe updates even if conflicts are found
  GIT_CHECKOUT_ALLOW_CONFLICTS(16),
  /// Remove untracked files not in index (that are not ignored)
  GIT_CHECKOUT_REMOVE_UNTRACKED(32),
  /// Remove ignored files not in index
  GIT_CHECKOUT_REMOVE_IGNORED(64),
  /// Only update existing files, don't create new ones
  GIT_CHECKOUT_UPDATE_ONLY(128),
  /// Normally checkout updates index entries as it goes; this stops that.
  /// Implies `GIT_CHECKOUT_DONT_WRITE_INDEX`.
  GIT_CHECKOUT_DONT_UPDATE_INDEX(256),
  /// Don't refresh index/config/etc before doing checkout
  GIT_CHECKOUT_NO_REFRESH(512),
  /// Allow checkout to skip unmerged files
  GIT_CHECKOUT_SKIP_UNMERGED(1024),
  /// For unmerged files, checkout stage 2 from index
  GIT_CHECKOUT_USE_OURS(2048),
  /// For unmerged files, checkout stage 3 from index
  GIT_CHECKOUT_USE_THEIRS(4096),
  /// Treat pathspec as simple list of exact match file paths
  GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH(8192),
  /// Ignore directories in use, they will be left empty
  GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES(262144),
  /// Don't overwrite ignored files that exist in the checkout target
  GIT_CHECKOUT_DONT_OVERWRITE_IGNORED(524288),
  /// Write normal merge files for conflicts
  GIT_CHECKOUT_CONFLICT_STYLE_MERGE(1048576),
  /// Include common ancestor data in diff3 format files for conflicts
  GIT_CHECKOUT_CONFLICT_STYLE_DIFF3(2097152),
  /// Don't overwrite existing files or folders
  GIT_CHECKOUT_DONT_REMOVE_EXISTING(4194304),
  /// Normally checkout writes the index upon completion; this prevents that.
  GIT_CHECKOUT_DONT_WRITE_INDEX(8388608),
  /// Perform a "dry run", reporting what _would_ be done but
  /// without actually making changes in the working directory
  /// or the index.
  GIT_CHECKOUT_DRY_RUN(16777216),
  /// Include common ancestor data in zdiff3 format for conflicts
  GIT_CHECKOUT_CONFLICT_STYLE_ZDIFF3(33554432),
  /// Do not do a checkout and do not fire callbacks; this is primarily
  /// useful only for internal functions that will perform the
  /// checkout themselves but need to pass checkout options into
  /// another function, for example, `git_clone`.
  GIT_CHECKOUT_NONE(1073741824),
  /// Recursively checkout submodules with same options (NOT IMPLEMENTED)
  GIT_CHECKOUT_UPDATE_SUBMODULES(65536),
  /// Recursively checkout submodules if HEAD moved in super repo (NOT IMPLEMENTED)
  GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED(131072);


  final int value;
  const git_checkout_strategy_t(this.value);

  static git_checkout_strategy_t fromValue(int value) => switch (value) {
    0 => GIT_CHECKOUT_SAFE,
    2 => GIT_CHECKOUT_FORCE,
    4 => GIT_CHECKOUT_RECREATE_MISSING,
    16 => GIT_CHECKOUT_ALLOW_CONFLICTS,
    32 => GIT_CHECKOUT_REMOVE_UNTRACKED,
    64 => GIT_CHECKOUT_REMOVE_IGNORED,
    128 => GIT_CHECKOUT_UPDATE_ONLY,
    256 => GIT_CHECKOUT_DONT_UPDATE_INDEX,
    512 => GIT_CHECKOUT_NO_REFRESH,
    1024 => GIT_CHECKOUT_SKIP_UNMERGED,
    2048 => GIT_CHECKOUT_USE_OURS,
    4096 => GIT_CHECKOUT_USE_THEIRS,
    8192 => GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH,
    262144 => GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES,
    524288 => GIT_CHECKOUT_DONT_OVERWRITE_IGNORED,
    1048576 => GIT_CHECKOUT_CONFLICT_STYLE_MERGE,
    2097152 => GIT_CHECKOUT_CONFLICT_STYLE_DIFF3,
    4194304 => GIT_CHECKOUT_DONT_REMOVE_EXISTING,
    8388608 => GIT_CHECKOUT_DONT_WRITE_INDEX,
    16777216 => GIT_CHECKOUT_DRY_RUN,
    33554432 => GIT_CHECKOUT_CONFLICT_STYLE_ZDIFF3,
    1073741824 => GIT_CHECKOUT_NONE,
    65536 => GIT_CHECKOUT_UPDATE_SUBMODULES,
    131072 => GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED,
    _ => throw ArgumentError('Unknown value for git_checkout_strategy_t: $value'),
  };

}

/// Checkout notification flags
/// 
/// Checkout will invoke an options notification callback (`notify_cb`) for
/// certain cases - you pick which ones via `notify_flags`:
/// 
/// Returning a non-zero value from this callback will cancel the checkout.
/// The non-zero return value will be propagated back and returned by the
/// git_checkout_... call.
/// 
/// Notification callbacks are made prior to modifying any files on disk,
/// so canceling on any notification will still happen prior to any files
/// being modified.
/// 
/// @flags
enum git_checkout_notify_t {
  GIT_CHECKOUT_NOTIFY_NONE(0),
  /// Invokes checkout on conflicting paths.
  GIT_CHECKOUT_NOTIFY_CONFLICT(1),
  /// Notifies about "dirty" files, i.e. those that do not need an update
  /// but no longer match the baseline.  Core git displays these files when
  /// checkout runs, but won't stop the checkout.
  GIT_CHECKOUT_NOTIFY_DIRTY(2),
  /// Sends notification for any file changed.
  GIT_CHECKOUT_NOTIFY_UPDATED(4),
  /// Notifies about untracked files.
  GIT_CHECKOUT_NOTIFY_UNTRACKED(8),
  /// Notifies about ignored files.
  GIT_CHECKOUT_NOTIFY_IGNORED(16),
  GIT_CHECKOUT_NOTIFY_ALL(65535);


  final int value;
  const git_checkout_notify_t(this.value);

  static git_checkout_notify_t fromValue(int value) => switch (value) {
    0 => GIT_CHECKOUT_NOTIFY_NONE,
    1 => GIT_CHECKOUT_NOTIFY_CONFLICT,
    2 => GIT_CHECKOUT_NOTIFY_DIRTY,
    4 => GIT_CHECKOUT_NOTIFY_UPDATED,
    8 => GIT_CHECKOUT_NOTIFY_UNTRACKED,
    16 => GIT_CHECKOUT_NOTIFY_IGNORED,
    65535 => GIT_CHECKOUT_NOTIFY_ALL,
    _ => throw ArgumentError('Unknown value for git_checkout_notify_t: $value'),
  };

}

/// Checkout performance-reporting structure
final class git_checkout_perfdata extends ffi.Struct{
  @ffi.Size()
  external int mkdir_calls;

  @ffi.Size()
  external int stat_calls;

  @ffi.Size()
  external int chmod_calls;

}

/// Checkout options structure
/// 
/// Initialize with `GIT_CHECKOUT_OPTIONS_INIT`. Alternatively, you can
/// use `git_checkout_options_init`.
/// 
/// @options[version] GIT_CHECKOUT_OPTIONS_VERSION
/// @options[init_macro] GIT_CHECKOUT_OPTIONS_INIT
/// @options[init_function] git_checkout_options_init
final class git_checkout_options extends ffi.Struct{
  /// < The version
  @ffi.UnsignedInt()
  external int version;

  /// < default will be a safe checkout
  @ffi.UnsignedInt()
  external int checkout_strategy;

  /// < don't apply filters like CRLF conversion
  @ffi.Int()
  external int disable_filters;

  /// < default is 0755
  @ffi.UnsignedInt()
  external int dir_mode;

  /// < default is 0644 or 0755 as dictated by blob
  @ffi.UnsignedInt()
  external int file_mode;

  /// < default is O_CREAT | O_TRUNC | O_WRONLY
  @ffi.Int()
  external int file_open_flags;

  /// Checkout notification flags specify what operations the notify
  /// callback is invoked for.
  /// 
  /// @type[flags] git_checkout_notify_t
  @ffi.UnsignedInt()
  external int notify_flags;

  /// Optional callback to get notifications on specific file states.
  /// @see git_checkout_notify_t
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt why, ffi.Pointer<ffi.Char> path, ffi.Pointer<git_diff_file> baseline, ffi.Pointer<git_diff_file> target, ffi.Pointer<git_diff_file> workdir, ffi.Pointer<ffi.Void> payload)>> notify_cb;

  /// Payload passed to notify_cb
  external ffi.Pointer<ffi.Void> notify_payload;

  /// Optional callback to notify the consumer of checkout progress.
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char> path, ffi.Size completed_steps, ffi.Size total_steps, ffi.Pointer<ffi.Void> payload)>> progress_cb;

  /// Payload passed to progress_cb
  external ffi.Pointer<ffi.Void> progress_payload;

  /// A list of wildmatch patterns or paths.
  /// 
  /// By default, all paths are processed. If you pass an array of wildmatch
  /// patterns, those will be used to filter which paths should be taken into
  /// account.
  /// 
  /// Use GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH to treat as a simple list.
  external git_strarray paths;

  /// The expected content of the working directory; defaults to HEAD.
  /// 
  /// If the working directory does not match this baseline information,
  /// that will produce a checkout conflict.
  external ffi.Pointer<git_tree> baseline;

  /// Like `baseline` above, though expressed as an index.  This
  /// option overrides `baseline`.
  external ffi.Pointer<git_index> baseline_index;

  /// < alternative checkout path to workdir
  external ffi.Pointer<ffi.Char> target_directory;

  /// < the name of the common ancestor side of conflicts
  external ffi.Pointer<ffi.Char> ancestor_label;

  /// < the name of the "our" side of conflicts
  external ffi.Pointer<ffi.Char> our_label;

  /// < the name of the "their" side of conflicts
  external ffi.Pointer<ffi.Char> their_label;

  /// Optional callback to notify the consumer of performance data.
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_checkout_perfdata> perfdata, ffi.Pointer<ffi.Void> payload)>> perfdata_cb;

  /// Payload passed to perfdata_cb
  external ffi.Pointer<ffi.Void> perfdata_payload;

}

/// Time structure used in a git index entry
final class git_index_time extends ffi.Struct{
  @ffi.Int32()
  external int seconds;

  @ffi.Uint32()
  external int nanoseconds;

}

/// In-memory representation of a file entry in the index.
/// 
/// This is a public structure that represents a file entry in the index.
/// The meaning of the fields corresponds to core Git's documentation (in
/// "Documentation/technical/index-format.txt").
/// 
/// The `flags` field consists of a number of bit fields which can be
/// accessed via the first set of `GIT_INDEX_ENTRY_...` bitmasks below.
/// These flags are all read from and persisted to disk.
/// 
/// The `flags_extended` field also has a number of bit fields which can be
/// accessed via the later `GIT_INDEX_ENTRY_...` bitmasks below.  Some of
/// these flags are read from and written to disk, but some are set aside
/// for in-memory only reference.
/// 
/// Note that the time and size fields are truncated to 32 bits. This
/// is enough to detect changes, which is enough for the index to
/// function as a cache, but it should not be taken as an authoritative
/// source for that data.
final class git_index_entry extends ffi.Struct{
  external git_index_time ctime;

  external git_index_time mtime;

  @ffi.Uint32()
  external int dev;

  @ffi.Uint32()
  external int ino;

  @ffi.Uint32()
  external int mode;

  @ffi.Uint32()
  external int uid;

  @ffi.Uint32()
  external int gid;

  @ffi.Uint32()
  external int file_size;

  external git_oid id;

  @ffi.Uint16()
  external int flags;

  @ffi.Uint16()
  external int flags_extended;

  external ffi.Pointer<ffi.Char> path;

}

/// Flags for index entries
enum git_index_entry_flag_t {
  GIT_INDEX_ENTRY_EXTENDED(16384),
  GIT_INDEX_ENTRY_VALID(32768);


  final int value;
  const git_index_entry_flag_t(this.value);

  static git_index_entry_flag_t fromValue(int value) => switch (value) {
    16384 => GIT_INDEX_ENTRY_EXTENDED,
    32768 => GIT_INDEX_ENTRY_VALID,
    _ => throw ArgumentError('Unknown value for git_index_entry_flag_t: $value'),
  };

}

/// Bitmasks for on-disk fields of `git_index_entry`'s `flags_extended`
/// 
/// In memory, the `flags_extended` fields are divided into two parts: the
/// fields that are read from and written to disk, and other fields that
/// in-memory only and used by libgit2.  Only the flags in
/// `GIT_INDEX_ENTRY_EXTENDED_FLAGS` will get saved on-disk.
/// 
/// Thee first three bitmasks match the three fields in the
/// `git_index_entry` `flags_extended` value that belong on disk.  You
/// can use them to interpret the data in the `flags_extended`.
/// 
/// The rest of the bitmasks match the other fields in the `git_index_entry`
/// `flags_extended` value that are only used in-memory by libgit2.
/// You can use them to interpret the data in the `flags_extended`.
enum git_index_entry_extended_flag_t {
  GIT_INDEX_ENTRY_INTENT_TO_ADD(8192),
  GIT_INDEX_ENTRY_SKIP_WORKTREE(16384),
  GIT_INDEX_ENTRY_EXTENDED_FLAGS(24576),
  GIT_INDEX_ENTRY_UPTODATE(4);


  final int value;
  const git_index_entry_extended_flag_t(this.value);

  static git_index_entry_extended_flag_t fromValue(int value) => switch (value) {
    8192 => GIT_INDEX_ENTRY_INTENT_TO_ADD,
    16384 => GIT_INDEX_ENTRY_SKIP_WORKTREE,
    24576 => GIT_INDEX_ENTRY_EXTENDED_FLAGS,
    4 => GIT_INDEX_ENTRY_UPTODATE,
    _ => throw ArgumentError('Unknown value for git_index_entry_extended_flag_t: $value'),
  };

}

/// Capabilities of system that affect index actions.
enum git_index_capability_t {
  GIT_INDEX_CAPABILITY_IGNORE_CASE(1),
  GIT_INDEX_CAPABILITY_NO_FILEMODE(2),
  GIT_INDEX_CAPABILITY_NO_SYMLINKS(4),
  GIT_INDEX_CAPABILITY_FROM_OWNER(-1);


  final int value;
  const git_index_capability_t(this.value);

  static git_index_capability_t fromValue(int value) => switch (value) {
    1 => GIT_INDEX_CAPABILITY_IGNORE_CASE,
    2 => GIT_INDEX_CAPABILITY_NO_FILEMODE,
    4 => GIT_INDEX_CAPABILITY_NO_SYMLINKS,
    -1 => GIT_INDEX_CAPABILITY_FROM_OWNER,
    _ => throw ArgumentError('Unknown value for git_index_capability_t: $value'),
  };

}

/// Flags for APIs that add files matching pathspec
enum git_index_add_option_t {
  GIT_INDEX_ADD_DEFAULT(0),
  GIT_INDEX_ADD_FORCE(1),
  GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH(2),
  GIT_INDEX_ADD_CHECK_PATHSPEC(4);


  final int value;
  const git_index_add_option_t(this.value);

  static git_index_add_option_t fromValue(int value) => switch (value) {
    0 => GIT_INDEX_ADD_DEFAULT,
    1 => GIT_INDEX_ADD_FORCE,
    2 => GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH,
    4 => GIT_INDEX_ADD_CHECK_PATHSPEC,
    _ => throw ArgumentError('Unknown value for git_index_add_option_t: $value'),
  };

}

/// Git index stage states
enum git_index_stage_t {
  /// Match any index stage.
  /// 
  /// Some index APIs take a stage to match; pass this value to match
  /// any entry matching the path regardless of stage.
  GIT_INDEX_STAGE_ANY(-1),
  /// A normal staged file in the index.
  GIT_INDEX_STAGE_NORMAL(0),
  /// The ancestor side of a conflict.
  GIT_INDEX_STAGE_ANCESTOR(1),
  /// The "ours" side of a conflict.
  GIT_INDEX_STAGE_OURS(2),
  /// The "theirs" side of a conflict.
  GIT_INDEX_STAGE_THEIRS(3);


  final int value;
  const git_index_stage_t(this.value);

  static git_index_stage_t fromValue(int value) => switch (value) {
    -1 => GIT_INDEX_STAGE_ANY,
    0 => GIT_INDEX_STAGE_NORMAL,
    1 => GIT_INDEX_STAGE_ANCESTOR,
    2 => GIT_INDEX_STAGE_OURS,
    3 => GIT_INDEX_STAGE_THEIRS,
    _ => throw ArgumentError('Unknown value for git_index_stage_t: $value'),
  };

}

/// The file inputs to `git_merge_file`.  Callers should populate the
/// `git_merge_file_input` structure with descriptions of the files in
/// each side of the conflict for use in producing the merge file.
final class git_merge_file_input extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// Pointer to the contents of the file.
  external ffi.Pointer<ffi.Char> ptr;

  /// Size of the contents pointed to in `ptr`.
  @ffi.Size()
  external int size;

  /// File name of the conflicted file, or `NULL` to not merge the path.
  external ffi.Pointer<ffi.Char> path;

  /// File mode of the conflicted file, or `0` to not merge the mode.
  @ffi.UnsignedInt()
  external int mode;

}

/// Flags for `git_merge` options.  A combination of these flags can be
/// passed in via the `flags` value in the `git_merge_options`.
enum git_merge_flag_t {
  /// Detect renames that occur between the common ancestor and the "ours"
  /// side or the common ancestor and the "theirs" side.  This will enable
  /// the ability to merge between a modified and renamed file.
  GIT_MERGE_FIND_RENAMES(1),
  /// If a conflict occurs, exit immediately instead of attempting to
  /// continue resolving conflicts.  The merge operation will fail with
  /// GIT_EMERGECONFLICT and no index will be returned.
  GIT_MERGE_FAIL_ON_CONFLICT(2),
  /// Do not write the REUC extension on the generated index
  GIT_MERGE_SKIP_REUC(4),
  /// If the commits being merged have multiple merge bases, do not build
  /// a recursive merge base (by merging the multiple merge bases),
  /// instead simply use the first base.  This flag provides a similar
  /// merge base to `git-merge-resolve`.
  GIT_MERGE_NO_RECURSIVE(8),
  /// Treat this merge as if it is to produce the virtual base
  /// of a recursive merge.  This will ensure that there are
  /// no conflicts, any conflicting regions will keep conflict
  /// markers in the merge result.
  GIT_MERGE_VIRTUAL_BASE(16);


  final int value;
  const git_merge_flag_t(this.value);

  static git_merge_flag_t fromValue(int value) => switch (value) {
    1 => GIT_MERGE_FIND_RENAMES,
    2 => GIT_MERGE_FAIL_ON_CONFLICT,
    4 => GIT_MERGE_SKIP_REUC,
    8 => GIT_MERGE_NO_RECURSIVE,
    16 => GIT_MERGE_VIRTUAL_BASE,
    _ => throw ArgumentError('Unknown value for git_merge_flag_t: $value'),
  };

}

/// Merge file favor options for `git_merge_options` instruct the file-level
/// merging functionality how to deal with conflicting regions of the files.
enum git_merge_file_favor_t {
  /// When a region of a file is changed in both branches, a conflict
  /// will be recorded in the index so that `git_checkout` can produce
  /// a merge file with conflict markers in the working directory.
  /// This is the default.
  GIT_MERGE_FILE_FAVOR_NORMAL(0),
  /// When a region of a file is changed in both branches, the file
  /// created in the index will contain the "ours" side of any conflicting
  /// region.  The index will not record a conflict.
  GIT_MERGE_FILE_FAVOR_OURS(1),
  /// When a region of a file is changed in both branches, the file
  /// created in the index will contain the "theirs" side of any conflicting
  /// region.  The index will not record a conflict.
  GIT_MERGE_FILE_FAVOR_THEIRS(2),
  /// When a region of a file is changed in both branches, the file
  /// created in the index will contain each unique line from each side,
  /// which has the result of combining both files.  The index will not
  /// record a conflict.
  GIT_MERGE_FILE_FAVOR_UNION(3);


  final int value;
  const git_merge_file_favor_t(this.value);

  static git_merge_file_favor_t fromValue(int value) => switch (value) {
    0 => GIT_MERGE_FILE_FAVOR_NORMAL,
    1 => GIT_MERGE_FILE_FAVOR_OURS,
    2 => GIT_MERGE_FILE_FAVOR_THEIRS,
    3 => GIT_MERGE_FILE_FAVOR_UNION,
    _ => throw ArgumentError('Unknown value for git_merge_file_favor_t: $value'),
  };

}

/// File merging flags
enum git_merge_file_flag_t {
  /// Defaults
  GIT_MERGE_FILE_DEFAULT(0),
  /// Create standard conflicted merge files
  GIT_MERGE_FILE_STYLE_MERGE(1),
  /// Create diff3-style files
  GIT_MERGE_FILE_STYLE_DIFF3(2),
  /// Condense non-alphanumeric regions for simplified diff file
  GIT_MERGE_FILE_SIMPLIFY_ALNUM(4),
  /// Ignore all whitespace
  GIT_MERGE_FILE_IGNORE_WHITESPACE(8),
  /// Ignore changes in amount of whitespace
  GIT_MERGE_FILE_IGNORE_WHITESPACE_CHANGE(16),
  /// Ignore whitespace at end of line
  GIT_MERGE_FILE_IGNORE_WHITESPACE_EOL(32),
  /// Use the "patience diff" algorithm
  GIT_MERGE_FILE_DIFF_PATIENCE(64),
  /// Take extra time to find minimal diff
  GIT_MERGE_FILE_DIFF_MINIMAL(128),
  /// Create zdiff3 ("zealous diff3")-style files
  GIT_MERGE_FILE_STYLE_ZDIFF3(256),
  /// Do not produce file conflicts when common regions have
  /// changed; keep the conflict markers in the file and accept
  /// that as the merge result.
  GIT_MERGE_FILE_ACCEPT_CONFLICTS(512);


  final int value;
  const git_merge_file_flag_t(this.value);

  static git_merge_file_flag_t fromValue(int value) => switch (value) {
    0 => GIT_MERGE_FILE_DEFAULT,
    1 => GIT_MERGE_FILE_STYLE_MERGE,
    2 => GIT_MERGE_FILE_STYLE_DIFF3,
    4 => GIT_MERGE_FILE_SIMPLIFY_ALNUM,
    8 => GIT_MERGE_FILE_IGNORE_WHITESPACE,
    16 => GIT_MERGE_FILE_IGNORE_WHITESPACE_CHANGE,
    32 => GIT_MERGE_FILE_IGNORE_WHITESPACE_EOL,
    64 => GIT_MERGE_FILE_DIFF_PATIENCE,
    128 => GIT_MERGE_FILE_DIFF_MINIMAL,
    256 => GIT_MERGE_FILE_STYLE_ZDIFF3,
    512 => GIT_MERGE_FILE_ACCEPT_CONFLICTS,
    _ => throw ArgumentError('Unknown value for git_merge_file_flag_t: $value'),
  };

}

/// Options for merging a file
final class git_merge_file_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// Label for the ancestor file side of the conflict which will be prepended
  /// to labels in diff3-format merge files.
  external ffi.Pointer<ffi.Char> ancestor_label;

  /// Label for our file side of the conflict which will be prepended
  /// to labels in merge files.
  external ffi.Pointer<ffi.Char> our_label;

  /// Label for their file side of the conflict which will be prepended
  /// to labels in merge files.
  external ffi.Pointer<ffi.Char> their_label;

  /// The file to favor in region conflicts.
  @ffi.UnsignedInt()
  external int favorAsInt;

git_merge_file_favor_t get favor => git_merge_file_favor_t.fromValue(favorAsInt);

  /// see `git_merge_file_flag_t` above
  @ffi.Uint32()
  external int flags;

  /// The size of conflict markers (eg, "<<<<<<<").  Default is
  /// GIT_MERGE_CONFLICT_MARKER_SIZE.
  @ffi.UnsignedShort()
  external int marker_size;

}

/// Information about file-level merging
final class git_merge_file_result extends ffi.Struct{
  /// True if the output was automerged, false if the output contains
  /// conflict markers.
  @ffi.UnsignedInt()
  external int automergeable;

  /// The path that the resultant merge file should use, or NULL if a
  /// filename conflict would occur.
  external ffi.Pointer<ffi.Char> path;

  /// The mode that the resultant merge file should use.
  @ffi.UnsignedInt()
  external int mode;

  /// The contents of the merge.
  external ffi.Pointer<ffi.Char> ptr;

  /// The length of the merge contents.
  @ffi.Size()
  external int len;

}

/// Merging options
final class git_merge_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// See `git_merge_flag_t` above
  @ffi.Uint32()
  external int flags;

  /// Similarity to consider a file renamed (default 50).  If
  /// `GIT_MERGE_FIND_RENAMES` is enabled, added files will be compared
  /// with deleted files to determine their similarity.  Files that are
  /// more similar than the rename threshold (percentage-wise) will be
  /// treated as a rename.
  @ffi.UnsignedInt()
  external int rename_threshold;

  /// Maximum similarity sources to examine for renames (default 200).
  /// If the number of rename candidates (add / delete pairs) is greater
  /// than this value, inexact rename detection is aborted.
  /// 
  /// This setting overrides the `merge.renameLimit` configuration value.
  @ffi.UnsignedInt()
  external int target_limit;

  /// Pluggable similarity metric; pass NULL to use internal metric
  external ffi.Pointer<git_diff_similarity_metric> metric;

  /// Maximum number of times to merge common ancestors to build a
  /// virtual merge base when faced with criss-cross merges.  When this
  /// limit is reached, the next ancestor will simply be used instead of
  /// attempting to merge it.  The default is unlimited.
  @ffi.UnsignedInt()
  external int recursion_limit;

  /// Default merge driver to be used when both sides of a merge have
  /// changed.  The default is the `text` driver.
  external ffi.Pointer<ffi.Char> default_driver;

  /// Flags for handling conflicting content, to be used with the standard
  /// (`text`) merge driver.
  @ffi.UnsignedInt()
  external int file_favorAsInt;

git_merge_file_favor_t get file_favor => git_merge_file_favor_t.fromValue(file_favorAsInt);

  /// see `git_merge_file_flag_t` above
  @ffi.Uint32()
  external int file_flags;

}

/// The results of `git_merge_analysis` indicate the merge opportunities.
enum git_merge_analysis_t {
  /// No merge is possible.  (Unused.)
  GIT_MERGE_ANALYSIS_NONE(0),
  /// A "normal" merge; both HEAD and the given merge input have diverged
  /// from their common ancestor.  The divergent commits must be merged.
  GIT_MERGE_ANALYSIS_NORMAL(1),
  /// All given merge inputs are reachable from HEAD, meaning the
  /// repository is up-to-date and no merge needs to be performed.
  GIT_MERGE_ANALYSIS_UP_TO_DATE(2),
  /// The given merge input is a fast-forward from HEAD and no merge
  /// needs to be performed.  Instead, the client can check out the
  /// given merge input.
  GIT_MERGE_ANALYSIS_FASTFORWARD(4),
  /// The HEAD of the current repository is "unborn" and does not point to
  /// a valid commit.  No merge can be performed, but the caller may wish
  /// to simply set HEAD to the target commit(s).
  GIT_MERGE_ANALYSIS_UNBORN(8);


  final int value;
  const git_merge_analysis_t(this.value);

  static git_merge_analysis_t fromValue(int value) => switch (value) {
    0 => GIT_MERGE_ANALYSIS_NONE,
    1 => GIT_MERGE_ANALYSIS_NORMAL,
    2 => GIT_MERGE_ANALYSIS_UP_TO_DATE,
    4 => GIT_MERGE_ANALYSIS_FASTFORWARD,
    8 => GIT_MERGE_ANALYSIS_UNBORN,
    _ => throw ArgumentError('Unknown value for git_merge_analysis_t: $value'),
  };

}

/// The user's stated preference for merges.
enum git_merge_preference_t {
  /// No configuration was found that suggests a preferred behavior for
  /// merge.
  GIT_MERGE_PREFERENCE_NONE(0),
  /// There is a `merge.ff=false` configuration setting, suggesting that
  /// the user does not want to allow a fast-forward merge.
  GIT_MERGE_PREFERENCE_NO_FASTFORWARD(1),
  /// There is a `merge.ff=only` configuration setting, suggesting that
  /// the user only wants fast-forward merges.
  GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY(2);


  final int value;
  const git_merge_preference_t(this.value);

  static git_merge_preference_t fromValue(int value) => switch (value) {
    0 => GIT_MERGE_PREFERENCE_NONE,
    1 => GIT_MERGE_PREFERENCE_NO_FASTFORWARD,
    2 => GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY,
    _ => throw ArgumentError('Unknown value for git_merge_preference_t: $value'),
  };

}

/// Cherry-pick options
final class git_cherrypick_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// For merge commits, the "mainline" is treated as the parent.
  @ffi.UnsignedInt()
  external int mainline;

  /// < Options for the merging
  external git_merge_options merge_opts;

  /// < Options for the checkout
  external git_checkout_options checkout_opts;

}

/// Direction of the connection.
/// 
/// We need this because we need to know whether we should call
/// git-upload-pack or git-receive-pack on the remote end when get_refs
/// gets called.
enum git_direction {
  GIT_DIRECTION_FETCH(0),
  GIT_DIRECTION_PUSH(1);


  final int value;
  const git_direction(this.value);

  static git_direction fromValue(int value) => switch (value) {
    0 => GIT_DIRECTION_FETCH,
    1 => GIT_DIRECTION_PUSH,
    _ => throw ArgumentError('Unknown value for git_direction: $value'),
  };

}

/// A plaintext username and password
final class git_credential_userpass_plaintext extends ffi.Struct{
  /// < The parent credential
  external git_credential parent;

  /// < The username to authenticate as
  external ffi.Pointer<ffi.Char> username;

  /// < The password to use
  external ffi.Pointer<ffi.Char> password;

}

/// Username-only credential information
final class git_credential_username extends ffi.Struct{
  /// < The parent credential
  external git_credential parent;

  /// < The username to authenticate as
@ffi.Array.multi([1])
  external ffi.Array<ffi.Char> username;

}

/// A ssh key from disk
final class git_credential_ssh_key extends ffi.Struct{
  /// < The parent credential
  external git_credential parent;

  /// < The username to authenticate as
  external ffi.Pointer<ffi.Char> username;

  /// < The path to a public key
  external ffi.Pointer<ffi.Char> publickey;

  /// < The path to a private key
  external ffi.Pointer<ffi.Char> privatekey;

  /// < Passphrase to decrypt the private key
  external ffi.Pointer<ffi.Char> passphrase;

}

final class _LIBSSH2_USERAUTH_KBDINT_PROMPT extends ffi.Opaque{
}

final class _LIBSSH2_USERAUTH_KBDINT_RESPONSE extends ffi.Opaque{
}

/// Keyboard-interactive based ssh authentication
final class git_credential_ssh_interactive extends ffi.Struct{
  /// < The parent credential
  external git_credential parent;

  /// < The username to authenticate as
  external ffi.Pointer<ffi.Char> username;

  /// Callback used for authentication.
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char> name, ffi.Int name_len, ffi.Pointer<ffi.Char> instruction, ffi.Int instruction_len, ffi.Int num_prompts, ffi.Pointer<_LIBSSH2_USERAUTH_KBDINT_PROMPT> prompts, ffi.Pointer<_LIBSSH2_USERAUTH_KBDINT_RESPONSE> responses, ffi.Pointer<ffi.Pointer<ffi.Void>> abstract)>> prompt_callback;

  /// < Payload passed to prompt_callback
  external ffi.Pointer<ffi.Void> payload;

}

final class _LIBSSH2_SESSION extends ffi.Opaque{
}

/// A key with a custom signature function
final class git_credential_ssh_custom extends ffi.Struct{
  /// < The parent credential
  external git_credential parent;

  /// < The username to authenticate as
  external ffi.Pointer<ffi.Char> username;

  /// < The public key data
  external ffi.Pointer<ffi.Char> publickey;

  /// < Length of the public key
  @ffi.Size()
  external int publickey_len;

  /// Callback used to sign the data.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<_LIBSSH2_SESSION> session, ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> sig, ffi.Pointer<ffi.Size> sig_len, ffi.Pointer<ffi.UnsignedChar> data, ffi.Size data_len, ffi.Pointer<ffi.Pointer<ffi.Void>> abstract)>> sign_callback;

  /// < Payload passed to prompt_callback
  external ffi.Pointer<ffi.Void> payload;

}

/// Stages that are reported by the packbuilder progress callback.
enum git_packbuilder_stage_t {
  GIT_PACKBUILDER_ADDING_OBJECTS(0),
  GIT_PACKBUILDER_DELTAFICATION(1);


  final int value;
  const git_packbuilder_stage_t(this.value);

  static git_packbuilder_stage_t fromValue(int value) => switch (value) {
    0 => GIT_PACKBUILDER_ADDING_OBJECTS,
    1 => GIT_PACKBUILDER_DELTAFICATION,
    _ => throw ArgumentError('Unknown value for git_packbuilder_stage_t: $value'),
  };

}

/// The type of proxy to use.
enum git_proxy_t {
  /// Do not attempt to connect through a proxy
  /// 
  /// If built against libcurl, it itself may attempt to connect
  /// to a proxy if the environment variables specify it.
  GIT_PROXY_NONE(0),
  /// Try to auto-detect the proxy from the git configuration.
  GIT_PROXY_AUTO(1),
  /// Connect via the URL given in the options
  GIT_PROXY_SPECIFIED(2);


  final int value;
  const git_proxy_t(this.value);

  static git_proxy_t fromValue(int value) => switch (value) {
    0 => GIT_PROXY_NONE,
    1 => GIT_PROXY_AUTO,
    2 => GIT_PROXY_SPECIFIED,
    _ => throw ArgumentError('Unknown value for git_proxy_t: $value'),
  };

}

/// Options for connecting through a proxy
/// 
/// Note that not all types may be supported, depending on the platform
/// and compilation options.
final class git_proxy_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// The type of proxy to use, by URL, auto-detect.
  @ffi.UnsignedInt()
  external int typeAsInt;

git_proxy_t get type => git_proxy_t.fromValue(typeAsInt);

  /// The URL of the proxy.
  external ffi.Pointer<ffi.Char> url;

  /// This will be called if the remote host requires
  /// authentication in order to connect to it.
  /// 
  /// Returning GIT_PASSTHROUGH will make libgit2 behave as
  /// though this field isn't set.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>> out, ffi.Pointer<ffi.Char> url, ffi.Pointer<ffi.Char> username_from_url, ffi.UnsignedInt allowed_types, ffi.Pointer<ffi.Void> payload)>> credentials;

  /// If cert verification fails, this will be called to let the
  /// user make the final decision of whether to allow the
  /// connection to proceed. Returns 0 to allow the connection
  /// or a negative value to indicate an error.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_cert> cert, ffi.Int valid, ffi.Pointer<ffi.Char> host, ffi.Pointer<ffi.Void> payload)>> certificate_check;

  /// Payload to be provided to the credentials and certificate
  /// check callbacks.
  external ffi.Pointer<ffi.Void> payload;

}

/// Remote redirection settings; whether redirects to another host
/// are permitted.  By default, git will follow a redirect on the
/// initial request (`/info/refs`), but not subsequent requests.
enum git_remote_redirect_t {
  /// Do not follow any off-site redirects at any stage of
  /// the fetch or push.
  GIT_REMOTE_REDIRECT_NONE(1),
  /// Allow off-site redirects only upon the initial request.
  /// This is the default.
  GIT_REMOTE_REDIRECT_INITIAL(2),
  /// Allow redirects at any stage in the fetch or push.
  GIT_REMOTE_REDIRECT_ALL(4);


  final int value;
  const git_remote_redirect_t(this.value);

  static git_remote_redirect_t fromValue(int value) => switch (value) {
    1 => GIT_REMOTE_REDIRECT_NONE,
    2 => GIT_REMOTE_REDIRECT_INITIAL,
    4 => GIT_REMOTE_REDIRECT_ALL,
    _ => throw ArgumentError('Unknown value for git_remote_redirect_t: $value'),
  };

}

/// Remote creation options flags
enum git_remote_create_flags {
  /// Ignore the repository apply.insteadOf configuration
  GIT_REMOTE_CREATE_SKIP_INSTEADOF(1),
  /// Don't build a fetchspec from the name if none is set
  GIT_REMOTE_CREATE_SKIP_DEFAULT_FETCHSPEC(2);


  final int value;
  const git_remote_create_flags(this.value);

  static git_remote_create_flags fromValue(int value) => switch (value) {
    1 => GIT_REMOTE_CREATE_SKIP_INSTEADOF,
    2 => GIT_REMOTE_CREATE_SKIP_DEFAULT_FETCHSPEC,
    _ => throw ArgumentError('Unknown value for git_remote_create_flags: $value'),
  };

}

/// How to handle reference updates.
enum git_remote_update_flags {
  GIT_REMOTE_UPDATE_FETCHHEAD(1),
  GIT_REMOTE_UPDATE_REPORT_UNCHANGED(2);


  final int value;
  const git_remote_update_flags(this.value);

  static git_remote_update_flags fromValue(int value) => switch (value) {
    1 => GIT_REMOTE_UPDATE_FETCHHEAD,
    2 => GIT_REMOTE_UPDATE_REPORT_UNCHANGED,
    _ => throw ArgumentError('Unknown value for git_remote_update_flags: $value'),
  };

}

/// Remote creation options structure
/// 
/// Initialize with `GIT_REMOTE_CREATE_OPTIONS_INIT`. Alternatively, you can
/// use `git_remote_create_options_init`.
final class git_remote_create_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// The repository that should own the remote.
  /// Setting this to NULL results in a detached remote.
  external ffi.Pointer<git_repository> repository;

  /// The remote's name.
  /// Setting this to NULL results in an in-memory/anonymous remote.
  external ffi.Pointer<ffi.Char> name;

  /// The fetchspec the remote should use.
  external ffi.Pointer<ffi.Char> fetchspec;

  /// Additional flags for the remote. See git_remote_create_flags.
  @ffi.UnsignedInt()
  external int flags;

}

/// Acceptable prune settings when fetching
enum git_fetch_prune_t {
  /// Use the setting from the configuration
  GIT_FETCH_PRUNE_UNSPECIFIED(0),
  /// Force pruning on
  GIT_FETCH_PRUNE(1),
  /// Force pruning off
  GIT_FETCH_NO_PRUNE(2);


  final int value;
  const git_fetch_prune_t(this.value);

  static git_fetch_prune_t fromValue(int value) => switch (value) {
    0 => GIT_FETCH_PRUNE_UNSPECIFIED,
    1 => GIT_FETCH_PRUNE,
    2 => GIT_FETCH_NO_PRUNE,
    _ => throw ArgumentError('Unknown value for git_fetch_prune_t: $value'),
  };

}

/// Automatic tag following option
/// 
/// Lets us select the --tags option to use.
enum git_remote_autotag_option_t {
  /// Use the setting from the configuration.
  GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED(0),
  /// Ask the server for tags pointing to objects we're already
  /// downloading.
  GIT_REMOTE_DOWNLOAD_TAGS_AUTO(1),
  /// Don't ask for any tags beyond the refspecs.
  GIT_REMOTE_DOWNLOAD_TAGS_NONE(2),
  /// Ask for the all the tags.
  GIT_REMOTE_DOWNLOAD_TAGS_ALL(3);


  final int value;
  const git_remote_autotag_option_t(this.value);

  static git_remote_autotag_option_t fromValue(int value) => switch (value) {
    0 => GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED,
    1 => GIT_REMOTE_DOWNLOAD_TAGS_AUTO,
    2 => GIT_REMOTE_DOWNLOAD_TAGS_NONE,
    3 => GIT_REMOTE_DOWNLOAD_TAGS_ALL,
    _ => throw ArgumentError('Unknown value for git_remote_autotag_option_t: $value'),
  };

}

/// Constants for fetch depth (shallowness of fetch).
enum git_fetch_depth_t {
  /// The fetch is "full" (not shallow). This is the default.
  GIT_FETCH_DEPTH_FULL(0),
  /// The fetch should "unshallow" and fetch missing data.
  GIT_FETCH_DEPTH_UNSHALLOW(2147483647);


  final int value;
  const git_fetch_depth_t(this.value);

  static git_fetch_depth_t fromValue(int value) => switch (value) {
    0 => GIT_FETCH_DEPTH_FULL,
    2147483647 => GIT_FETCH_DEPTH_UNSHALLOW,
    _ => throw ArgumentError('Unknown value for git_fetch_depth_t: $value'),
  };

}

/// Fetch options structure.
/// 
/// Zero out for defaults.  Initialize with `GIT_FETCH_OPTIONS_INIT` macro to
/// correctly set the `version` field.  E.g.
/// 
/// git_fetch_options opts = GIT_FETCH_OPTIONS_INIT;
final class git_fetch_options extends ffi.Struct{
  @ffi.Int()
  external int version;

  /// Callbacks to use for this fetch operation
  external git_remote_callbacks callbacks;

  /// Whether to perform a prune after the fetch
  @ffi.UnsignedInt()
  external int pruneAsInt;

git_fetch_prune_t get prune => git_fetch_prune_t.fromValue(pruneAsInt);

  /// How to handle reference updates; see `git_remote_update_flags`.
  @ffi.UnsignedInt()
  external int update_fetchhead;

  /// Determines how to behave regarding tags on the remote, such
  /// as auto-downloading tags for objects we're downloading or
  /// downloading all of them.
  /// 
  /// The default is to auto-follow tags.
  @ffi.UnsignedInt()
  external int download_tagsAsInt;

git_remote_autotag_option_t get download_tags => git_remote_autotag_option_t.fromValue(download_tagsAsInt);

  /// Proxy options to use, by default no proxy is used.
  external git_proxy_options proxy_opts;

  /// Depth of the fetch to perform, or `GIT_FETCH_DEPTH_FULL`
  /// (or `0`) for full history, or `GIT_FETCH_DEPTH_UNSHALLOW`
  /// to "unshallow" a shallow repository.
  /// 
  /// The default is full (`GIT_FETCH_DEPTH_FULL` or `0`).
  @ffi.Int()
  external int depth;

  /// Whether to allow off-site redirects.  If this is not
  /// specified, the `http.followRedirects` configuration setting
  /// will be consulted.
  @ffi.UnsignedInt()
  external int follow_redirectsAsInt;

git_remote_redirect_t get follow_redirects => git_remote_redirect_t.fromValue(follow_redirectsAsInt);

  /// Extra headers for this fetch operation
  external git_strarray custom_headers;

}

/// Controls the behavior of a git_push object.
final class git_push_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// If the transport being used to push to the remote requires the creation
  /// of a pack file, this controls the number of worker threads used by
  /// the packbuilder when creating that pack file to be sent to the remote.
  /// 
  /// If set to 0, the packbuilder will auto-detect the number of threads
  /// to create. The default value is 1.
  @ffi.UnsignedInt()
  external int pb_parallelism;

  /// Callbacks to use for this push operation
  external git_remote_callbacks callbacks;

  /// Proxy options to use, by default no proxy is used.
  external git_proxy_options proxy_opts;

  /// Whether to allow off-site redirects.  If this is not
  /// specified, the `http.followRedirects` configuration setting
  /// will be consulted.
  @ffi.UnsignedInt()
  external int follow_redirectsAsInt;

git_remote_redirect_t get follow_redirects => git_remote_redirect_t.fromValue(follow_redirectsAsInt);

  /// Extra headers for this push operation
  external git_strarray custom_headers;

  /// "Push options" to deliver to the remote.
  external git_strarray remote_push_options;

}

/// Remote creation options structure
/// 
/// Initialize with `GIT_REMOTE_CREATE_OPTIONS_INIT`. Alternatively, you can
/// use `git_remote_create_options_init`.
final class git_remote_connect_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// Callbacks to use for this connection
  external git_remote_callbacks callbacks;

  /// HTTP Proxy settings
  external git_proxy_options proxy_opts;

  /// Whether to allow off-site redirects.  If this is not
  /// specified, the `http.followRedirects` configuration setting
  /// will be consulted.
  @ffi.UnsignedInt()
  external int follow_redirectsAsInt;

git_remote_redirect_t get follow_redirects => git_remote_redirect_t.fromValue(follow_redirectsAsInt);

  /// Extra HTTP headers to use in this connection
  external git_strarray custom_headers;

}

/// Options for bypassing the git-aware transport on clone. Bypassing
/// it means that instead of a fetch, libgit2 will copy the object
/// database directory instead of figuring out what it needs, which is
/// faster. If possible, it will hardlink the files to save space.
enum git_clone_local_t {
  /// Auto-detect (default), libgit2 will bypass the git-aware
  /// transport for local paths, but use a normal fetch for
  /// `file://` urls.
  GIT_CLONE_LOCAL_AUTO(0),
  /// Bypass the git-aware transport even for a `file://` url.
  GIT_CLONE_LOCAL(1),
  /// Do no bypass the git-aware transport
  GIT_CLONE_NO_LOCAL(2),
  /// Bypass the git-aware transport, but do not try to use
  /// hardlinks.
  GIT_CLONE_LOCAL_NO_LINKS(3);


  final int value;
  const git_clone_local_t(this.value);

  static git_clone_local_t fromValue(int value) => switch (value) {
    0 => GIT_CLONE_LOCAL_AUTO,
    1 => GIT_CLONE_LOCAL,
    2 => GIT_CLONE_NO_LOCAL,
    3 => GIT_CLONE_LOCAL_NO_LINKS,
    _ => throw ArgumentError('Unknown value for git_clone_local_t: $value'),
  };

}

/// Clone options structure
/// 
/// Initialize with `GIT_CLONE_OPTIONS_INIT`. Alternatively, you can
/// use `git_clone_options_init`.
/// 
/// @options[version] GIT_CLONE_OPTIONS_VERSION
/// @options[init_macro] GIT_CLONE_OPTIONS_INIT
/// @options[init_function] git_clone_options_init
final class git_clone_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// These options are passed to the checkout step. To disable
  /// checkout, set the `checkout_strategy` to `GIT_CHECKOUT_NONE`
  /// or `GIT_CHECKOUT_DRY_RUN`.
  external git_checkout_options checkout_opts;

  /// Options which control the fetch, including callbacks.
  /// 
  /// The callbacks are used for reporting fetch progress, and for acquiring
  /// credentials in the event they are needed.
  external git_fetch_options fetch_opts;

  /// Set to zero (false) to create a standard repo, or non-zero
  /// for a bare repo
  @ffi.Int()
  external int bare;

  /// Whether to use a fetch or copy the object database.
  @ffi.UnsignedInt()
  external int localAsInt;

git_clone_local_t get local => git_clone_local_t.fromValue(localAsInt);

  /// The name of the branch to checkout. NULL means use the
  /// remote's default branch.
  external ffi.Pointer<ffi.Char> checkout_branch;

  /// A callback used to create the new repository into which to
  /// clone. If NULL, the 'bare' field will be used to determine
  /// whether to create a bare repository.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>> out, ffi.Pointer<ffi.Char> path, ffi.Int bare, ffi.Pointer<ffi.Void> payload)>> repository_cb;

  /// An opaque payload to pass to the git_repository creation callback.
  /// This parameter is ignored unless repository_cb is non-NULL.
  external ffi.Pointer<ffi.Void> repository_cb_payload;

  /// A callback used to create the git_remote, prior to its being
  /// used to perform the clone operation. See the documentation for
  /// git_remote_create_cb for details. This parameter may be NULL,
  /// indicating that git_clone should provide default behavior.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Pointer<git_remote>> out, ffi.Pointer<git_repository> repo, ffi.Pointer<ffi.Char> name, ffi.Pointer<ffi.Char> url, ffi.Pointer<ffi.Void> payload)>> remote_cb;

  /// An opaque payload to pass to the git_remote creation callback.
  /// This parameter is ignored unless remote_cb is non-NULL.
  external ffi.Pointer<ffi.Void> remote_cb_payload;

}

/// Priority level of a config file.
/// 
/// These priority levels correspond to the natural escalation logic
/// (from higher to lower) when reading or searching for config entries
/// in git.git. Meaning that for the same key, the configuration in
/// the local configuration is preferred over the configuration in
/// the system configuration file.
/// 
/// Callers can add their own custom configuration, beginning at the
/// `GIT_CONFIG_LEVEL_APP` level.
/// 
/// Writes, by default, occur in the highest priority level backend
/// that is writable. This ordering can be overridden with
/// `git_config_set_writeorder`.
/// 
/// git_config_open_default() and git_repository_config() honor those
/// priority levels as well.
/// 
/// @see git_config_open_default
/// @see git_repository_config
enum git_config_level_t {
  /// System-wide on Windows, for compatibility with "Portable Git".
  GIT_CONFIG_LEVEL_PROGRAMDATA(1),
  /// System-wide configuration file; `/etc/gitconfig` on Linux.
  GIT_CONFIG_LEVEL_SYSTEM(2),
  /// XDG compatible configuration file; typically
  /// `~/.config/git/config`.
  GIT_CONFIG_LEVEL_XDG(3),
  /// Global configuration file is the user-specific configuration;
  /// typically `~/.gitconfig`.
  GIT_CONFIG_LEVEL_GLOBAL(4),
  /// Local configuration, the repository-specific configuration file;
  /// typically `$GIT_DIR/config`.
  GIT_CONFIG_LEVEL_LOCAL(5),
  /// Worktree-specific configuration; typically
  /// `$GIT_DIR/config.worktree`.
  GIT_CONFIG_LEVEL_WORKTREE(6),
  /// Application-specific configuration file. Callers into libgit2
  /// can add their own configuration beginning at this level.
  GIT_CONFIG_LEVEL_APP(7),
  /// Not a configuration level; callers can use this value when
  /// querying configuration levels to specify that they want to
  /// have data from the highest-level currently configuration.
  /// This can be used to indicate that callers want the most
  /// specific config file available that actually is loaded.
  GIT_CONFIG_HIGHEST_LEVEL(-1);


  final int value;
  const git_config_level_t(this.value);

  static git_config_level_t fromValue(int value) => switch (value) {
    1 => GIT_CONFIG_LEVEL_PROGRAMDATA,
    2 => GIT_CONFIG_LEVEL_SYSTEM,
    3 => GIT_CONFIG_LEVEL_XDG,
    4 => GIT_CONFIG_LEVEL_GLOBAL,
    5 => GIT_CONFIG_LEVEL_LOCAL,
    6 => GIT_CONFIG_LEVEL_WORKTREE,
    7 => GIT_CONFIG_LEVEL_APP,
    -1 => GIT_CONFIG_HIGHEST_LEVEL,
    _ => throw ArgumentError('Unknown value for git_config_level_t: $value'),
  };

}

/// An entry in a configuration file
final class git_config_entry extends ffi.Struct{
  /// Name of the configuration entry (normalized).
  external ffi.Pointer<ffi.Char> name;

  /// Literal (string) value of the entry.
  external ffi.Pointer<ffi.Char> value;

  /// The type of backend that this entry exists in (eg, "file").
  external ffi.Pointer<ffi.Char> backend_type;

  /// The path to the origin of this entry. For config files, this is
  /// the path to the file.
  external ffi.Pointer<ffi.Char> origin_path;

  /// Depth of includes where this variable was found.
  @ffi.UnsignedInt()
  external int include_depth;

  /// Configuration level for the file this was found in.
  @ffi.Int()
  external int levelAsInt;

git_config_level_t get level => git_config_level_t.fromValue(levelAsInt);

}

final class git_config_iterator extends ffi.Opaque{
}

/// Config var type
enum git_configmap_t {
  GIT_CONFIGMAP_FALSE(0),
  GIT_CONFIGMAP_TRUE(1),
  GIT_CONFIGMAP_INT32(2),
  GIT_CONFIGMAP_STRING(3);


  final int value;
  const git_configmap_t(this.value);

  static git_configmap_t fromValue(int value) => switch (value) {
    0 => GIT_CONFIGMAP_FALSE,
    1 => GIT_CONFIGMAP_TRUE,
    2 => GIT_CONFIGMAP_INT32,
    3 => GIT_CONFIGMAP_STRING,
    _ => throw ArgumentError('Unknown value for git_configmap_t: $value'),
  };

}

/// Mapping from config variables to values.
final class git_configmap extends ffi.Struct{
  @ffi.UnsignedInt()
  external int typeAsInt;

git_configmap_t get type => git_configmap_t.fromValue(typeAsInt);

  external ffi.Pointer<ffi.Char> str_match;

  @ffi.Int()
  external int map_value;

}

/// Reference lookup strategy
/// 
/// These behave like the --tags and --all options to git-describe,
/// namely they say to look for any reference in either refs/tags/ or
/// refs/ respectively.
enum git_describe_strategy_t {
  GIT_DESCRIBE_DEFAULT(0),
  GIT_DESCRIBE_TAGS(1),
  GIT_DESCRIBE_ALL(2);


  final int value;
  const git_describe_strategy_t(this.value);

  static git_describe_strategy_t fromValue(int value) => switch (value) {
    0 => GIT_DESCRIBE_DEFAULT,
    1 => GIT_DESCRIBE_TAGS,
    2 => GIT_DESCRIBE_ALL,
    _ => throw ArgumentError('Unknown value for git_describe_strategy_t: $value'),
  };

}

/// Describe options structure
/// 
/// Initialize with `GIT_DESCRIBE_OPTIONS_INIT`. Alternatively, you can
/// use `git_describe_options_init`.
final class git_describe_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// < default: 10
  @ffi.UnsignedInt()
  external int max_candidates_tags;

  /// < default: GIT_DESCRIBE_DEFAULT
  @ffi.UnsignedInt()
  external int describe_strategy;

  external ffi.Pointer<ffi.Char> pattern;

  /// When calculating the distance from the matching tag or
  /// reference, only walk down the first-parent ancestry.
  @ffi.Int()
  external int only_follow_first_parent;

  /// If no matching tag or reference is found, the describe
  /// operation would normally fail. If this option is set, it
  /// will instead fall back to showing the full id of the
  /// commit.
  @ffi.Int()
  external int show_commit_oid_as_fallback;

}

/// Describe format options structure
/// 
/// Initialize with `GIT_DESCRIBE_FORMAT_OPTIONS_INIT`. Alternatively, you can
/// use `git_describe_format_options_init`.
final class git_describe_format_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// Size of the abbreviated commit id to use. This value is the
  /// lower bound for the length of the abbreviated string. The
  /// default is 7.
  @ffi.UnsignedInt()
  external int abbreviated_size;

  /// Set to use the long format even when a shorter name could be used.
  @ffi.Int()
  external int always_use_long_format;

  /// If the workdir is dirty and this is set, this string will
  /// be appended to the description string.
  external ffi.Pointer<ffi.Char> dirty_suffix;

}

final class git_describe_result extends ffi.Opaque{
}

/// Generic return codes
enum git_error_code {
  /// No error occurred; the call was successful.
  GIT_OK(0),
  /// An error occurred; call `git_error_last` for more information.
  GIT_ERROR(-1),
  /// < Requested object could not be found.
  GIT_ENOTFOUND(-3),
  /// < Object exists preventing operation.
  GIT_EEXISTS(-4),
  /// < More than one object matches.
  GIT_EAMBIGUOUS(-5),
  /// < Output buffer too short to hold data.
  GIT_EBUFS(-6),
  /// GIT_EUSER is a special error that is never generated by libgit2
  /// code.  You can return it from a callback (e.g to stop an iteration)
  /// to know that it was generated by the callback and not by libgit2.
  GIT_EUSER(-7),
  /// < Operation not allowed on bare repository.
  GIT_EBAREREPO(-8),
  /// < HEAD refers to branch with no commits.
  GIT_EUNBORNBRANCH(-9),
  /// < Merge in progress prevented operation
  GIT_EUNMERGED(-10),
  /// < Reference was not fast-forwardable
  GIT_ENONFASTFORWARD(-11),
  /// < Name/ref spec was not in a valid format
  GIT_EINVALIDSPEC(-12),
  /// < Checkout conflicts prevented operation
  GIT_ECONFLICT(-13),
  /// < Lock file prevented operation
  GIT_ELOCKED(-14),
  /// < Reference value does not match expected
  GIT_EMODIFIED(-15),
  /// < Authentication error
  GIT_EAUTH(-16),
  /// < Server certificate is invalid
  GIT_ECERTIFICATE(-17),
  /// < Patch/merge has already been applied
  GIT_EAPPLIED(-18),
  /// < The requested peel operation is not possible
  GIT_EPEEL(-19),
  /// < Unexpected EOF
  GIT_EEOF(-20),
  /// < Invalid operation or input
  GIT_EINVALID(-21),
  /// < Uncommitted changes in index prevented operation
  GIT_EUNCOMMITTED(-22),
  /// < The operation is not valid for a directory
  GIT_EDIRECTORY(-23),
  /// < A merge conflict exists and cannot continue
  GIT_EMERGECONFLICT(-24),
  /// < A user-configured callback refused to act
  GIT_PASSTHROUGH(-30),
  /// < Signals end of iteration with iterator
  GIT_ITEROVER(-31),
  /// < Internal only
  GIT_RETRY(-32),
  /// < Hashsum mismatch in object
  GIT_EMISMATCH(-33),
  /// < Unsaved changes in the index would be overwritten
  GIT_EINDEXDIRTY(-34),
  /// < Patch application failed
  GIT_EAPPLYFAIL(-35),
  /// < The object is not owned by the current user
  GIT_EOWNER(-36),
  /// < The operation timed out
  GIT_TIMEOUT(-37),
  /// < There were no changes
  GIT_EUNCHANGED(-38),
  /// < An option is not supported
  GIT_ENOTSUPPORTED(-39),
  /// < The subject is read-only
  GIT_EREADONLY(-40);


  final int value;
  const git_error_code(this.value);

  static git_error_code fromValue(int value) => switch (value) {
    0 => GIT_OK,
    -1 => GIT_ERROR,
    -3 => GIT_ENOTFOUND,
    -4 => GIT_EEXISTS,
    -5 => GIT_EAMBIGUOUS,
    -6 => GIT_EBUFS,
    -7 => GIT_EUSER,
    -8 => GIT_EBAREREPO,
    -9 => GIT_EUNBORNBRANCH,
    -10 => GIT_EUNMERGED,
    -11 => GIT_ENONFASTFORWARD,
    -12 => GIT_EINVALIDSPEC,
    -13 => GIT_ECONFLICT,
    -14 => GIT_ELOCKED,
    -15 => GIT_EMODIFIED,
    -16 => GIT_EAUTH,
    -17 => GIT_ECERTIFICATE,
    -18 => GIT_EAPPLIED,
    -19 => GIT_EPEEL,
    -20 => GIT_EEOF,
    -21 => GIT_EINVALID,
    -22 => GIT_EUNCOMMITTED,
    -23 => GIT_EDIRECTORY,
    -24 => GIT_EMERGECONFLICT,
    -30 => GIT_PASSTHROUGH,
    -31 => GIT_ITEROVER,
    -32 => GIT_RETRY,
    -33 => GIT_EMISMATCH,
    -34 => GIT_EINDEXDIRTY,
    -35 => GIT_EAPPLYFAIL,
    -36 => GIT_EOWNER,
    -37 => GIT_TIMEOUT,
    -38 => GIT_EUNCHANGED,
    -39 => GIT_ENOTSUPPORTED,
    -40 => GIT_EREADONLY,
    _ => throw ArgumentError('Unknown value for git_error_code: $value'),
  };

}

/// Error classes are the category of error. They reflect the area of the
/// code where an error occurred.
enum git_error_t {
  GIT_ERROR_NONE(0),
  GIT_ERROR_NOMEMORY(1),
  GIT_ERROR_OS(2),
  GIT_ERROR_INVALID(3),
  GIT_ERROR_REFERENCE(4),
  GIT_ERROR_ZLIB(5),
  GIT_ERROR_REPOSITORY(6),
  GIT_ERROR_CONFIG(7),
  GIT_ERROR_REGEX(8),
  GIT_ERROR_ODB(9),
  GIT_ERROR_INDEX(10),
  GIT_ERROR_OBJECT(11),
  GIT_ERROR_NET(12),
  GIT_ERROR_TAG(13),
  GIT_ERROR_TREE(14),
  GIT_ERROR_INDEXER(15),
  GIT_ERROR_SSL(16),
  GIT_ERROR_SUBMODULE(17),
  GIT_ERROR_THREAD(18),
  GIT_ERROR_STASH(19),
  GIT_ERROR_CHECKOUT(20),
  GIT_ERROR_FETCHHEAD(21),
  GIT_ERROR_MERGE(22),
  GIT_ERROR_SSH(23),
  GIT_ERROR_FILTER(24),
  GIT_ERROR_REVERT(25),
  GIT_ERROR_CALLBACK(26),
  GIT_ERROR_CHERRYPICK(27),
  GIT_ERROR_DESCRIBE(28),
  GIT_ERROR_REBASE(29),
  GIT_ERROR_FILESYSTEM(30),
  GIT_ERROR_PATCH(31),
  GIT_ERROR_WORKTREE(32),
  GIT_ERROR_SHA(33),
  GIT_ERROR_HTTP(34),
  GIT_ERROR_INTERNAL(35),
  GIT_ERROR_GRAFTS(36);


  final int value;
  const git_error_t(this.value);

  static git_error_t fromValue(int value) => switch (value) {
    0 => GIT_ERROR_NONE,
    1 => GIT_ERROR_NOMEMORY,
    2 => GIT_ERROR_OS,
    3 => GIT_ERROR_INVALID,
    4 => GIT_ERROR_REFERENCE,
    5 => GIT_ERROR_ZLIB,
    6 => GIT_ERROR_REPOSITORY,
    7 => GIT_ERROR_CONFIG,
    8 => GIT_ERROR_REGEX,
    9 => GIT_ERROR_ODB,
    10 => GIT_ERROR_INDEX,
    11 => GIT_ERROR_OBJECT,
    12 => GIT_ERROR_NET,
    13 => GIT_ERROR_TAG,
    14 => GIT_ERROR_TREE,
    15 => GIT_ERROR_INDEXER,
    16 => GIT_ERROR_SSL,
    17 => GIT_ERROR_SUBMODULE,
    18 => GIT_ERROR_THREAD,
    19 => GIT_ERROR_STASH,
    20 => GIT_ERROR_CHECKOUT,
    21 => GIT_ERROR_FETCHHEAD,
    22 => GIT_ERROR_MERGE,
    23 => GIT_ERROR_SSH,
    24 => GIT_ERROR_FILTER,
    25 => GIT_ERROR_REVERT,
    26 => GIT_ERROR_CALLBACK,
    27 => GIT_ERROR_CHERRYPICK,
    28 => GIT_ERROR_DESCRIBE,
    29 => GIT_ERROR_REBASE,
    30 => GIT_ERROR_FILESYSTEM,
    31 => GIT_ERROR_PATCH,
    32 => GIT_ERROR_WORKTREE,
    33 => GIT_ERROR_SHA,
    34 => GIT_ERROR_HTTP,
    35 => GIT_ERROR_INTERNAL,
    36 => GIT_ERROR_GRAFTS,
    _ => throw ArgumentError('Unknown value for git_error_t: $value'),
  };

}

/// Structure to store extra details of the last error that occurred.
/// 
/// This is kept on a per-thread basis if GIT_THREADS was defined when the
/// library was build, otherwise one is kept globally for the library
final class git_error extends ffi.Struct{
  /// < The error message for the last error.
  external ffi.Pointer<ffi.Char> message;

  /// < The category of the last error. @type git_error_t
  @ffi.Int()
  external int klass;

}

/// Filters are applied in one of two directions: smudging - which is
/// exporting a file from the Git object database to the working directory,
/// and cleaning - which is importing a file from the working directory to
/// the Git object database.  These values control which direction of
/// change is being applied.
enum git_filter_mode_t {
  GIT_FILTER_TO_WORKTREE(0),
  GIT_FILTER_TO_ODB(1);

  static const GIT_FILTER_SMUDGE = GIT_FILTER_TO_WORKTREE;
  static const GIT_FILTER_CLEAN = GIT_FILTER_TO_ODB;

  final int value;
  const git_filter_mode_t(this.value);

  static git_filter_mode_t fromValue(int value) => switch (value) {
    0 => GIT_FILTER_TO_WORKTREE,
    1 => GIT_FILTER_TO_ODB,
    _ => throw ArgumentError('Unknown value for git_filter_mode_t: $value'),
  };

  @override
  String toString() {
    if (this == GIT_FILTER_TO_WORKTREE) return "git_filter_mode_t.GIT_FILTER_TO_WORKTREE, git_filter_mode_t.GIT_FILTER_SMUDGE";
    if (this == GIT_FILTER_TO_ODB) return "git_filter_mode_t.GIT_FILTER_TO_ODB, git_filter_mode_t.GIT_FILTER_CLEAN";
    return super.toString();
  }}

/// Filter option flags.
enum git_filter_flag_t {
  GIT_FILTER_DEFAULT(0),
  /// Don't error for `safecrlf` violations, allow them to continue.
  GIT_FILTER_ALLOW_UNSAFE(1),
  /// Don't load `/etc/gitattributes` (or the system equivalent)
  GIT_FILTER_NO_SYSTEM_ATTRIBUTES(2),
  /// Load attributes from `.gitattributes` in the root of HEAD
  GIT_FILTER_ATTRIBUTES_FROM_HEAD(4),
  /// Load attributes from `.gitattributes` in a given commit.
  /// This can only be specified in a `git_filter_options`.
  GIT_FILTER_ATTRIBUTES_FROM_COMMIT(8);


  final int value;
  const git_filter_flag_t(this.value);

  static git_filter_flag_t fromValue(int value) => switch (value) {
    0 => GIT_FILTER_DEFAULT,
    1 => GIT_FILTER_ALLOW_UNSAFE,
    2 => GIT_FILTER_NO_SYSTEM_ATTRIBUTES,
    4 => GIT_FILTER_ATTRIBUTES_FROM_HEAD,
    8 => GIT_FILTER_ATTRIBUTES_FROM_COMMIT,
    _ => throw ArgumentError('Unknown value for git_filter_flag_t: $value'),
  };

}

/// Filtering options
final class git_filter_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// See `git_filter_flag_t` above
  @ffi.Uint32()
  external int flags;

  external ffi.Pointer<git_oid> commit_id;

  /// The commit to load attributes from, when
  /// `GIT_FILTER_ATTRIBUTES_FROM_COMMIT` is specified.
  external git_oid attr_commit_id;

}

final class git_filter extends ffi.Opaque{
}

final class git_filter_list extends ffi.Opaque{
}

/// Rebase options
/// 
/// Use to tell the rebase machinery how to operate.
final class git_rebase_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// Used by `git_rebase_init`, this will instruct other clients working
  /// on this rebase that you want a quiet rebase experience, which they
  /// may choose to provide in an application-specific manner.  This has no
  /// effect upon libgit2 directly, but is provided for interoperability
  /// between Git tools.
  @ffi.Int()
  external int quiet;

  /// Used by `git_rebase_init`, this will begin an in-memory rebase,
  /// which will allow callers to step through the rebase operations and
  /// commit the rebased changes, but will not rewind HEAD or update the
  /// repository to be in a rebasing state.  This will not interfere with
  /// the working directory (if there is one).
  @ffi.Int()
  external int inmemory;

  /// Used by `git_rebase_finish`, this is the name of the notes reference
  /// used to rewrite notes for rebased commits when finishing the rebase;
  /// if NULL, the contents of the configuration option `notes.rewriteRef`
  /// is examined, unless the configuration option `notes.rewrite.rebase`
  /// is set to false.  If `notes.rewriteRef` is also NULL, notes will
  /// not be rewritten.
  external ffi.Pointer<ffi.Char> rewrite_notes_ref;

  /// Options to control how trees are merged during `git_rebase_next`.
  external git_merge_options merge_options;

  /// Options to control how files are written during `git_rebase_init`,
  /// `git_rebase_next` and `git_rebase_abort`.  Note that during
  /// `abort`, these options will add an implied `GIT_CHECKOUT_FORCE`
  /// to match git semantics.
  external git_checkout_options checkout_options;

  /// Optional callback that allows users to override commit
  /// creation in `git_rebase_commit`.  If specified, users can
  /// create their own commit and provide the commit ID, which
  /// may be useful for signing commits or otherwise customizing
  /// the commit creation.
  /// 
  /// If this callback returns `GIT_PASSTHROUGH`, then
  /// `git_rebase_commit` will continue to create the commit.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_oid> out, ffi.Pointer<git_signature> author, ffi.Pointer<git_signature> committer, ffi.Pointer<ffi.Char> message_encoding, ffi.Pointer<ffi.Char> message, ffi.Pointer<git_tree> tree, ffi.Size parent_count, ffi.Pointer<ffi.Pointer<git_commit>> parents, ffi.Pointer<ffi.Void> payload)>> commit_create_cb;

  /// If provided, this will be called with the commit content, allowing
  /// a signature to be added to the rebase commit. Can be skipped with
  /// GIT_PASSTHROUGH. If GIT_PASSTHROUGH is returned, a commit will be made
  /// without a signature.
  /// 
  /// This field is only used when performing git_rebase_commit.
  /// 
  /// This callback is not invoked if a `git_commit_create_cb` is
  /// specified.
  /// 
  /// This callback is deprecated; users should provide a
  /// creation callback as `commit_create_cb` that produces a
  /// commit buffer, signs it, and commits it.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_buf> , ffi.Pointer<git_buf> , ffi.Pointer<ffi.Char> , ffi.Pointer<ffi.Void> )>> signing_cb;

  /// This will be passed to each of the callbacks in this struct
  /// as the last parameter.
  external ffi.Pointer<ffi.Void> payload;

}

/// Type of rebase operation in-progress after calling `git_rebase_next`.
enum git_rebase_operation_t {
  /// The given commit is to be cherry-picked.  The client should commit
  /// the changes and continue if there are no conflicts.
  GIT_REBASE_OPERATION_PICK(0),
  /// The given commit is to be cherry-picked, but the client should prompt
  /// the user to provide an updated commit message.
  GIT_REBASE_OPERATION_REWORD(1),
  /// The given commit is to be cherry-picked, but the client should stop
  /// to allow the user to edit the changes before committing them.
  GIT_REBASE_OPERATION_EDIT(2),
  /// The given commit is to be squashed into the previous commit.  The
  /// commit message will be merged with the previous message.
  GIT_REBASE_OPERATION_SQUASH(3),
  /// The given commit is to be squashed into the previous commit.  The
  /// commit message from this commit will be discarded.
  GIT_REBASE_OPERATION_FIXUP(4),
  /// No commit will be cherry-picked.  The client should run the given
  /// command and (if successful) continue.
  GIT_REBASE_OPERATION_EXEC(5);


  final int value;
  const git_rebase_operation_t(this.value);

  static git_rebase_operation_t fromValue(int value) => switch (value) {
    0 => GIT_REBASE_OPERATION_PICK,
    1 => GIT_REBASE_OPERATION_REWORD,
    2 => GIT_REBASE_OPERATION_EDIT,
    3 => GIT_REBASE_OPERATION_SQUASH,
    4 => GIT_REBASE_OPERATION_FIXUP,
    5 => GIT_REBASE_OPERATION_EXEC,
    _ => throw ArgumentError('Unknown value for git_rebase_operation_t: $value'),
  };

}

/// A rebase operation
/// 
/// Describes a single instruction/operation to be performed during the
/// rebase.
final class git_rebase_operation extends ffi.Struct{
  /// The type of rebase operation.
  @ffi.UnsignedInt()
  external int typeAsInt;

git_rebase_operation_t get type => git_rebase_operation_t.fromValue(typeAsInt);

  /// The commit ID being cherry-picked.  This will be populated for
  /// all operations except those of type `GIT_REBASE_OPERATION_EXEC`.
  external git_oid id;

  /// The executable the user has requested be run.  This will only
  /// be populated for operations of type `GIT_REBASE_OPERATION_EXEC`.
  external ffi.Pointer<ffi.Char> exec;

}

/// Available tracing levels.  When tracing is set to a particular level,
/// callers will be provided tracing at the given level and all lower levels.
enum git_trace_level_t {
  /// No tracing will be performed.
  GIT_TRACE_NONE(0),
  /// Severe errors that may impact the program's execution
  GIT_TRACE_FATAL(1),
  /// Errors that do not impact the program's execution
  GIT_TRACE_ERROR(2),
  /// Warnings that suggest abnormal data
  GIT_TRACE_WARN(3),
  /// Informational messages about program execution
  GIT_TRACE_INFO(4),
  /// Detailed data that allows for debugging
  GIT_TRACE_DEBUG(5),
  /// Exceptionally detailed debugging data
  GIT_TRACE_TRACE(6);


  final int value;
  const git_trace_level_t(this.value);

  static git_trace_level_t fromValue(int value) => switch (value) {
    0 => GIT_TRACE_NONE,
    1 => GIT_TRACE_FATAL,
    2 => GIT_TRACE_ERROR,
    3 => GIT_TRACE_WARN,
    4 => GIT_TRACE_INFO,
    5 => GIT_TRACE_DEBUG,
    6 => GIT_TRACE_TRACE,
    _ => throw ArgumentError('Unknown value for git_trace_level_t: $value'),
  };

}

/// Options for revert
final class git_revert_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// For merge commits, the "mainline" is treated as the parent.
  @ffi.UnsignedInt()
  external int mainline;

  /// < Options for the merging
  external git_merge_options merge_opts;

  /// < Options for the checkout
  external git_checkout_options checkout_opts;

}

/// Revparse flags.  These indicate the intended behavior of the spec passed to
/// git_revparse.
enum git_revspec_t {
  /// The spec targeted a single object.
  GIT_REVSPEC_SINGLE(1),
  /// The spec targeted a range of commits.
  GIT_REVSPEC_RANGE(2),
  /// The spec used the '...' operator, which invokes special semantics.
  GIT_REVSPEC_MERGE_BASE(4);


  final int value;
  const git_revspec_t(this.value);

  static git_revspec_t fromValue(int value) => switch (value) {
    1 => GIT_REVSPEC_SINGLE,
    2 => GIT_REVSPEC_RANGE,
    4 => GIT_REVSPEC_MERGE_BASE,
    _ => throw ArgumentError('Unknown value for git_revspec_t: $value'),
  };

}

/// Git Revision Spec: output of a `git_revparse` operation
final class git_revspec extends ffi.Struct{
  /// The left element of the revspec; must be freed by the user
  external ffi.Pointer<git_object> from;

  /// The right element of the revspec; must be freed by the user
  external ffi.Pointer<git_object> to;

  /// The intent of the revspec (i.e. `git_revspec_mode_t` flags)
  @ffi.UnsignedInt()
  external int flags;

}

/// Stash flags
enum git_stash_flags {
  /// No option, default
  GIT_STASH_DEFAULT(0),
  /// All changes already added to the index are left intact in
  /// the working directory
  GIT_STASH_KEEP_INDEX(1),
  /// All untracked files are also stashed and then cleaned up
  /// from the working directory
  GIT_STASH_INCLUDE_UNTRACKED(2),
  /// All ignored files are also stashed and then cleaned up from
  /// the working directory
  GIT_STASH_INCLUDE_IGNORED(4),
  /// All changes in the index and working directory are left intact
  GIT_STASH_KEEP_ALL(8);


  final int value;
  const git_stash_flags(this.value);

  static git_stash_flags fromValue(int value) => switch (value) {
    0 => GIT_STASH_DEFAULT,
    1 => GIT_STASH_KEEP_INDEX,
    2 => GIT_STASH_INCLUDE_UNTRACKED,
    4 => GIT_STASH_INCLUDE_IGNORED,
    8 => GIT_STASH_KEEP_ALL,
    _ => throw ArgumentError('Unknown value for git_stash_flags: $value'),
  };

}

/// Stash save options structure
/// 
/// Initialize with `GIT_STASH_SAVE_OPTIONS_INIT`. Alternatively, you can
/// use `git_stash_save_options_init`.
final class git_stash_save_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// Flags to control the stashing process. (see GIT_STASH_* above)
  @ffi.Uint32()
  external int flags;

  /// The identity of the person performing the stashing.
  external ffi.Pointer<git_signature> stasher;

  /// Optional description along with the stashed state.
  external ffi.Pointer<ffi.Char> message;

  /// Optional paths that control which files are stashed.
  external git_strarray paths;

}

/// Stash application flags.
enum git_stash_apply_flags {
  GIT_STASH_APPLY_DEFAULT(0),
  GIT_STASH_APPLY_REINSTATE_INDEX(1);


  final int value;
  const git_stash_apply_flags(this.value);

  static git_stash_apply_flags fromValue(int value) => switch (value) {
    0 => GIT_STASH_APPLY_DEFAULT,
    1 => GIT_STASH_APPLY_REINSTATE_INDEX,
    _ => throw ArgumentError('Unknown value for git_stash_apply_flags: $value'),
  };

}

/// Stash apply progression states
enum git_stash_apply_progress_t {
  GIT_STASH_APPLY_PROGRESS_NONE(0),
  /// Loading the stashed data from the object database.
  GIT_STASH_APPLY_PROGRESS_LOADING_STASH(1),
  /// The stored index is being analyzed.
  GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX(2),
  /// The modified files are being analyzed.
  GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED(3),
  /// The untracked and ignored files are being analyzed.
  GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED(4),
  /// The untracked files are being written to disk.
  GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED(5),
  /// The modified files are being written to disk.
  GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED(6),
  /// The stash was applied successfully.
  GIT_STASH_APPLY_PROGRESS_DONE(7);


  final int value;
  const git_stash_apply_progress_t(this.value);

  static git_stash_apply_progress_t fromValue(int value) => switch (value) {
    0 => GIT_STASH_APPLY_PROGRESS_NONE,
    1 => GIT_STASH_APPLY_PROGRESS_LOADING_STASH,
    2 => GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX,
    3 => GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED,
    4 => GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED,
    5 => GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED,
    6 => GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED,
    7 => GIT_STASH_APPLY_PROGRESS_DONE,
    _ => throw ArgumentError('Unknown value for git_stash_apply_progress_t: $value'),
  };

}

/// Stash application options structure
/// 
/// Initialize with `GIT_STASH_APPLY_OPTIONS_INIT`. Alternatively, you can
/// use `git_stash_apply_options_init`.
final class git_stash_apply_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// See `git_stash_apply_flags`, above.
  @ffi.Uint32()
  external int flags;

  /// Options to use when writing files to the working directory.
  external git_checkout_options checkout_options;

  /// Optional callback to notify the consumer of application progress.
  external ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt progress, ffi.Pointer<ffi.Void> payload)>> progress_cb;

  external ffi.Pointer<ffi.Void> progress_payload;

}

/// Status flags for a single file.
/// 
/// A combination of these values will be returned to indicate the status of
/// a file.  Status compares the working directory, the index, and the
/// current HEAD of the repository.  The `GIT_STATUS_INDEX` set of flags
/// represents the status of file in the index relative to the HEAD, and the
/// `GIT_STATUS_WT` set of flags represent the status of the file in the
/// working directory relative to the index.
enum git_status_t {
  GIT_STATUS_CURRENT(0),
  GIT_STATUS_INDEX_NEW(1),
  GIT_STATUS_INDEX_MODIFIED(2),
  GIT_STATUS_INDEX_DELETED(4),
  GIT_STATUS_INDEX_RENAMED(8),
  GIT_STATUS_INDEX_TYPECHANGE(16),
  GIT_STATUS_WT_NEW(128),
  GIT_STATUS_WT_MODIFIED(256),
  GIT_STATUS_WT_DELETED(512),
  GIT_STATUS_WT_TYPECHANGE(1024),
  GIT_STATUS_WT_RENAMED(2048),
  GIT_STATUS_WT_UNREADABLE(4096),
  GIT_STATUS_IGNORED(16384),
  GIT_STATUS_CONFLICTED(32768);


  final int value;
  const git_status_t(this.value);

  static git_status_t fromValue(int value) => switch (value) {
    0 => GIT_STATUS_CURRENT,
    1 => GIT_STATUS_INDEX_NEW,
    2 => GIT_STATUS_INDEX_MODIFIED,
    4 => GIT_STATUS_INDEX_DELETED,
    8 => GIT_STATUS_INDEX_RENAMED,
    16 => GIT_STATUS_INDEX_TYPECHANGE,
    128 => GIT_STATUS_WT_NEW,
    256 => GIT_STATUS_WT_MODIFIED,
    512 => GIT_STATUS_WT_DELETED,
    1024 => GIT_STATUS_WT_TYPECHANGE,
    2048 => GIT_STATUS_WT_RENAMED,
    4096 => GIT_STATUS_WT_UNREADABLE,
    16384 => GIT_STATUS_IGNORED,
    32768 => GIT_STATUS_CONFLICTED,
    _ => throw ArgumentError('Unknown value for git_status_t: $value'),
  };

}

/// Select the files on which to report status.
/// 
/// With `git_status_foreach_ext`, this will control which changes get
/// callbacks.  With `git_status_list_new`, these will control which
/// changes are included in the list.
enum git_status_show_t {
  /// The default. This roughly matches `git status --porcelain` regarding
  /// which files are included and in what order.
  GIT_STATUS_SHOW_INDEX_AND_WORKDIR(0),
  /// Only gives status based on HEAD to index comparison, not looking at
  /// working directory changes.
  GIT_STATUS_SHOW_INDEX_ONLY(1),
  /// Only gives status based on index to working directory comparison,
  /// not comparing the index to the HEAD.
  GIT_STATUS_SHOW_WORKDIR_ONLY(2);


  final int value;
  const git_status_show_t(this.value);

  static git_status_show_t fromValue(int value) => switch (value) {
    0 => GIT_STATUS_SHOW_INDEX_AND_WORKDIR,
    1 => GIT_STATUS_SHOW_INDEX_ONLY,
    2 => GIT_STATUS_SHOW_WORKDIR_ONLY,
    _ => throw ArgumentError('Unknown value for git_status_show_t: $value'),
  };

}

/// Flags to control status callbacks
/// 
/// Calling `git_status_foreach()` is like calling the extended version
/// with: GIT_STATUS_OPT_INCLUDE_IGNORED, GIT_STATUS_OPT_INCLUDE_UNTRACKED,
/// and GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS.  Those options are bundled
/// together as `GIT_STATUS_OPT_DEFAULTS` if you want them as a baseline.
enum git_status_opt_t {
  /// Says that callbacks should be made on untracked files.
  /// These will only be made if the workdir files are included in the status
  /// "show" option.
  GIT_STATUS_OPT_INCLUDE_UNTRACKED(1),
  /// Says that ignored files get callbacks.
  /// Again, these callbacks will only be made if the workdir files are
  /// included in the status "show" option.
  GIT_STATUS_OPT_INCLUDE_IGNORED(2),
  /// Indicates that callback should be made even on unmodified files.
  GIT_STATUS_OPT_INCLUDE_UNMODIFIED(4),
  /// Indicates that submodules should be skipped.
  /// This only applies if there are no pending typechanges to the submodule
  /// (either from or to another type).
  GIT_STATUS_OPT_EXCLUDE_SUBMODULES(8),
  /// Indicates that all files in untracked directories should be included.
  /// Normally if an entire directory is new, then just the top-level
  /// directory is included (with a trailing slash on the entry name).
  /// This flag says to include all of the individual files in the directory
  /// instead.
  GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS(16),
  /// Indicates that the given path should be treated as a literal path,
  /// and not as a pathspec pattern.
  GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH(32),
  /// Indicates that the contents of ignored directories should be included
  /// in the status. This is like doing `git ls-files -o -i --exclude-standard`
  /// with core git.
  GIT_STATUS_OPT_RECURSE_IGNORED_DIRS(64),
  /// Indicates that rename detection should be processed between the head and
  /// the index and enables the GIT_STATUS_INDEX_RENAMED as a possible status
  /// flag.
  GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX(128),
  /// Indicates that rename detection should be run between the index and the
  /// working directory and enabled GIT_STATUS_WT_RENAMED as a possible status
  /// flag.
  GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR(256),
  /// Overrides the native case sensitivity for the file system and forces
  /// the output to be in case-sensitive order.
  GIT_STATUS_OPT_SORT_CASE_SENSITIVELY(512),
  /// Overrides the native case sensitivity for the file system and forces
  /// the output to be in case-insensitive order.
  GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY(1024),
  /// Iindicates that rename detection should include rewritten files.
  GIT_STATUS_OPT_RENAMES_FROM_REWRITES(2048),
  /// Bypasses the default status behavior of doing a "soft" index reload
  /// (i.e. reloading the index data if the file on disk has been modified
  /// outside libgit2).
  GIT_STATUS_OPT_NO_REFRESH(4096),
  /// Tells libgit2 to refresh the stat cache in the index for files that are
  /// unchanged but have out of date stat einformation in the index.
  /// It will result in less work being done on subsequent calls to get status.
  /// This is mutually exclusive with the NO_REFRESH option.
  GIT_STATUS_OPT_UPDATE_INDEX(8192),
  /// Normally files that cannot be opened or read are ignored as
  /// these are often transient files; this option will return
  /// unreadable files as `GIT_STATUS_WT_UNREADABLE`.
  GIT_STATUS_OPT_INCLUDE_UNREADABLE(16384),
  /// Unreadable files will be detected and given the status
  /// untracked instead of unreadable.
  GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED(32768);


  final int value;
  const git_status_opt_t(this.value);

  static git_status_opt_t fromValue(int value) => switch (value) {
    1 => GIT_STATUS_OPT_INCLUDE_UNTRACKED,
    2 => GIT_STATUS_OPT_INCLUDE_IGNORED,
    4 => GIT_STATUS_OPT_INCLUDE_UNMODIFIED,
    8 => GIT_STATUS_OPT_EXCLUDE_SUBMODULES,
    16 => GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS,
    32 => GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH,
    64 => GIT_STATUS_OPT_RECURSE_IGNORED_DIRS,
    128 => GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX,
    256 => GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR,
    512 => GIT_STATUS_OPT_SORT_CASE_SENSITIVELY,
    1024 => GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY,
    2048 => GIT_STATUS_OPT_RENAMES_FROM_REWRITES,
    4096 => GIT_STATUS_OPT_NO_REFRESH,
    8192 => GIT_STATUS_OPT_UPDATE_INDEX,
    16384 => GIT_STATUS_OPT_INCLUDE_UNREADABLE,
    32768 => GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED,
    _ => throw ArgumentError('Unknown value for git_status_opt_t: $value'),
  };

}

/// Options to control how `git_status_foreach_ext()` will issue callbacks.
/// 
/// Initialize with `GIT_STATUS_OPTIONS_INIT`. Alternatively, you can
/// use `git_status_options_init`.
final class git_status_options extends ffi.Struct{
  /// The struct version; pass `GIT_STATUS_OPTIONS_VERSION`.
  @ffi.UnsignedInt()
  external int version;

  /// The `show` value is one of the `git_status_show_t` constants that
  /// control which files to scan and in what order. The default is
  /// `GIT_STATUS_SHOW_INDEX_AND_WORKDIR`.
  @ffi.UnsignedInt()
  external int showAsInt;

git_status_show_t get show => git_status_show_t.fromValue(showAsInt);

  /// The `flags` value is an OR'ed combination of the
  /// `git_status_opt_t` values above. The default is
  /// `GIT_STATUS_OPT_DEFAULTS`, which matches git's default
  /// behavior.
  @ffi.UnsignedInt()
  external int flags;

  /// The `pathspec` is an array of path patterns to match (using
  /// fnmatch-style matching), or just an array of paths to match
  /// exactly if `GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH` is specified
  /// in the flags.
  external git_strarray pathspec;

  /// The `baseline` is the tree to be used for comparison to the
  /// working directory and index; defaults to HEAD.
  external ffi.Pointer<git_tree> baseline;

  /// Threshold above which similar files will be considered renames.
  /// This is equivalent to the -M option. Defaults to 50.
  @ffi.Uint16()
  external int rename_threshold;

}

/// A status entry, providing the differences between the file as it exists
/// in HEAD and the index, and providing the differences between the index
/// and the working directory.
/// 
/// The `status` value provides the status flags for this file.
/// 
/// The `head_to_index` value provides detailed information about the
/// differences between the file in HEAD and the file in the index.
/// 
/// The `index_to_workdir` value provides detailed information about the
/// differences between the file in the index and the file in the
/// working directory.
final class git_status_entry extends ffi.Struct{
  @ffi.UnsignedInt()
  external int statusAsInt;

git_status_t get status => git_status_t.fromValue(statusAsInt);

  external ffi.Pointer<git_diff_delta> head_to_index;

  external ffi.Pointer<git_diff_delta> index_to_workdir;

}

/// Return codes for submodule status.
/// 
/// A combination of these flags will be returned to describe the status of a
/// submodule.  Depending on the "ignore" property of the submodule, some of
/// the flags may never be returned because they indicate changes that are
/// supposed to be ignored.
/// 
/// Submodule info is contained in 4 places: the HEAD tree, the index, config
/// files (both .git/config and .gitmodules), and the working directory.  Any
/// or all of those places might be missing information about the submodule
/// depending on what state the repo is in.  We consider all four places to
/// build the combination of status flags.
/// 
/// There are four values that are not really status, but give basic info
/// about what sources of submodule data are available.  These will be
/// returned even if ignore is set to "ALL".
/// 
/// * IN_HEAD   - superproject head contains submodule
/// * IN_INDEX  - superproject index contains submodule
/// * IN_CONFIG - superproject gitmodules has submodule
/// * IN_WD     - superproject workdir has submodule
/// 
/// The following values will be returned so long as ignore is not "ALL".
/// 
/// * INDEX_ADDED       - in index, not in head
/// * INDEX_DELETED     - in head, not in index
/// * INDEX_MODIFIED    - index and head don't match
/// * WD_UNINITIALIZED  - workdir contains empty directory
/// * WD_ADDED          - in workdir, not index
/// * WD_DELETED        - in index, not workdir
/// * WD_MODIFIED       - index and workdir head don't match
/// 
/// The following can only be returned if ignore is "NONE" or "UNTRACKED".
/// 
/// * WD_INDEX_MODIFIED - submodule workdir index is dirty
/// * WD_WD_MODIFIED    - submodule workdir has modified files
/// 
/// Lastly, the following will only be returned for ignore "NONE".
/// 
/// * WD_UNTRACKED      - wd contains untracked files
enum git_submodule_status_t {
  GIT_SUBMODULE_STATUS_IN_HEAD(1),
  GIT_SUBMODULE_STATUS_IN_INDEX(2),
  GIT_SUBMODULE_STATUS_IN_CONFIG(4),
  GIT_SUBMODULE_STATUS_IN_WD(8),
  GIT_SUBMODULE_STATUS_INDEX_ADDED(16),
  GIT_SUBMODULE_STATUS_INDEX_DELETED(32),
  GIT_SUBMODULE_STATUS_INDEX_MODIFIED(64),
  GIT_SUBMODULE_STATUS_WD_UNINITIALIZED(128),
  GIT_SUBMODULE_STATUS_WD_ADDED(256),
  GIT_SUBMODULE_STATUS_WD_DELETED(512),
  GIT_SUBMODULE_STATUS_WD_MODIFIED(1024),
  GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED(2048),
  GIT_SUBMODULE_STATUS_WD_WD_MODIFIED(4096),
  GIT_SUBMODULE_STATUS_WD_UNTRACKED(8192);


  final int value;
  const git_submodule_status_t(this.value);

  static git_submodule_status_t fromValue(int value) => switch (value) {
    1 => GIT_SUBMODULE_STATUS_IN_HEAD,
    2 => GIT_SUBMODULE_STATUS_IN_INDEX,
    4 => GIT_SUBMODULE_STATUS_IN_CONFIG,
    8 => GIT_SUBMODULE_STATUS_IN_WD,
    16 => GIT_SUBMODULE_STATUS_INDEX_ADDED,
    32 => GIT_SUBMODULE_STATUS_INDEX_DELETED,
    64 => GIT_SUBMODULE_STATUS_INDEX_MODIFIED,
    128 => GIT_SUBMODULE_STATUS_WD_UNINITIALIZED,
    256 => GIT_SUBMODULE_STATUS_WD_ADDED,
    512 => GIT_SUBMODULE_STATUS_WD_DELETED,
    1024 => GIT_SUBMODULE_STATUS_WD_MODIFIED,
    2048 => GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED,
    4096 => GIT_SUBMODULE_STATUS_WD_WD_MODIFIED,
    8192 => GIT_SUBMODULE_STATUS_WD_UNTRACKED,
    _ => throw ArgumentError('Unknown value for git_submodule_status_t: $value'),
  };

}

/// Submodule update options structure
/// 
/// Initialize with `GIT_SUBMODULE_UPDATE_OPTIONS_INIT`. Alternatively, you can
/// use `git_submodule_update_options_init`.
final class git_submodule_update_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// These options are passed to the checkout step. To disable
  /// checkout, set the `checkout_strategy` to `GIT_CHECKOUT_NONE`
  /// or `GIT_CHECKOUT_DRY_RUN`.
  external git_checkout_options checkout_opts;

  /// Options which control the fetch, including callbacks.
  /// 
  /// The callbacks to use for reporting fetch progress, and for acquiring
  /// credentials in the event they are needed.
  external git_fetch_options fetch_opts;

  /// Allow fetching from the submodule's default remote if the target
  /// commit isn't found. Enabled by default.
  @ffi.Int()
  external int allow_fetch;

}

/// Worktree add options structure
/// 
/// Initialize with `GIT_WORKTREE_ADD_OPTIONS_INIT`. Alternatively, you can
/// use `git_worktree_add_options_init`.
final class git_worktree_add_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// < lock newly created worktree
  @ffi.Int()
  external int lock;

  /// < allow checkout of existing branch matching worktree name
  @ffi.Int()
  external int checkout_existing;

  /// < reference to use for the new worktree HEAD
  external ffi.Pointer<git_reference> ref;

  /// Options for the checkout.
  external git_checkout_options checkout_options;

}

/// Flags which can be passed to git_worktree_prune to alter its
/// behavior.
enum git_worktree_prune_t {
  GIT_WORKTREE_PRUNE_VALID(1),
  GIT_WORKTREE_PRUNE_LOCKED(2),
  GIT_WORKTREE_PRUNE_WORKING_TREE(4);


  final int value;
  const git_worktree_prune_t(this.value);

  static git_worktree_prune_t fromValue(int value) => switch (value) {
    1 => GIT_WORKTREE_PRUNE_VALID,
    2 => GIT_WORKTREE_PRUNE_LOCKED,
    4 => GIT_WORKTREE_PRUNE_WORKING_TREE,
    _ => throw ArgumentError('Unknown value for git_worktree_prune_t: $value'),
  };

}

/// Worktree prune options structure
/// 
/// Initialize with `GIT_WORKTREE_PRUNE_OPTIONS_INIT`. Alternatively, you can
/// use `git_worktree_prune_options_init`.
final class git_worktree_prune_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// A combination of `git_worktree_prune_t`
  @ffi.Uint32()
  external int flags;

}

/// Payload for git_credential_userpass_plaintext.
final class git_credential_userpass_payload extends ffi.Struct{
  external ffi.Pointer<ffi.Char> username;

  external ffi.Pointer<ffi.Char> password;

}

/// Formatting options for diff e-mail generation
enum git_diff_format_email_flags_t {
  /// Normal patch, the default
  GIT_DIFF_FORMAT_EMAIL_NONE(0),
  /// Don't insert "[PATCH]" in the subject header
  GIT_DIFF_FORMAT_EMAIL_EXCLUDE_SUBJECT_PATCH_MARKER(1);


  final int value;
  const git_diff_format_email_flags_t(this.value);

  static git_diff_format_email_flags_t fromValue(int value) => switch (value) {
    0 => GIT_DIFF_FORMAT_EMAIL_NONE,
    1 => GIT_DIFF_FORMAT_EMAIL_EXCLUDE_SUBJECT_PATCH_MARKER,
    _ => throw ArgumentError('Unknown value for git_diff_format_email_flags_t: $value'),
  };

}

/// Options for controlling the formatting of the generated e-mail.
/// 
/// @deprecated use `git_email_create_options`
final class git_diff_format_email_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// see `git_diff_format_email_flags_t` above
  @ffi.Uint32()
  external int flags;

  /// This patch number
  @ffi.Size()
  external int patch_no;

  /// Total number of patches in this series
  @ffi.Size()
  external int total_patches;

  /// id to use for the commit
  external ffi.Pointer<git_oid> id;

  /// Summary of the change
  external ffi.Pointer<ffi.Char> summary;

  /// Commit message's body
  external ffi.Pointer<ffi.Char> body;

  /// Author of the change
  external ffi.Pointer<git_signature> author;

}

/// Formatting options for diff e-mail generation
enum git_email_create_flags_t {
  /// Normal patch, the default
  GIT_EMAIL_CREATE_DEFAULT(0),
  /// Do not include patch numbers in the subject prefix.
  GIT_EMAIL_CREATE_OMIT_NUMBERS(1),
  /// Include numbers in the subject prefix even when the
  /// patch is for a single commit (1/1).
  GIT_EMAIL_CREATE_ALWAYS_NUMBER(2),
  /// Do not perform rename or similarity detection.
  GIT_EMAIL_CREATE_NO_RENAMES(4);


  final int value;
  const git_email_create_flags_t(this.value);

  static git_email_create_flags_t fromValue(int value) => switch (value) {
    0 => GIT_EMAIL_CREATE_DEFAULT,
    1 => GIT_EMAIL_CREATE_OMIT_NUMBERS,
    2 => GIT_EMAIL_CREATE_ALWAYS_NUMBER,
    4 => GIT_EMAIL_CREATE_NO_RENAMES,
    _ => throw ArgumentError('Unknown value for git_email_create_flags_t: $value'),
  };

}

/// Options for controlling the formatting of the generated e-mail.
final class git_email_create_options extends ffi.Struct{
  @ffi.UnsignedInt()
  external int version;

  /// see `git_email_create_flags_t` above
  @ffi.Uint32()
  external int flags;

  /// Options to use when creating diffs
  external git_diff_options diff_opts;

  /// Options for finding similarities within diffs
  external git_diff_find_options diff_find_opts;

  /// The subject prefix, by default "PATCH".  If set to an empty
  /// string ("") then only the patch numbers will be shown in the
  /// prefix.  If the subject_prefix is empty and patch numbers
  /// are not being shown, the prefix will be omitted entirely.
  external ffi.Pointer<ffi.Char> subject_prefix;

  /// The starting patch number; this cannot be 0.  By default,
  /// this is 1.
  @ffi.Size()
  external int start_number;

  /// The "re-roll" number.  By default, there is no re-roll.
  @ffi.Size()
  external int reroll_number;

}

/// Represents a single git message trailer.
final class git_message_trailer extends ffi.Struct{
  external ffi.Pointer<ffi.Char> key;

  external ffi.Pointer<ffi.Char> value;

}

/// Represents an array of git message trailers.
/// 
/// Struct members under the private comment are private, subject to change
/// and should not be used by callers.
final class git_message_trailer_array extends ffi.Struct{
  external ffi.Pointer<git_message_trailer> trailers;

  @ffi.Size()
  external int count;

  external ffi.Pointer<ffi.Char> _trailer_block;

}

final class git_iterator extends ffi.Opaque{
}

/// Options for configuring a packfile object backend.
final class git_odb_backend_pack_options extends ffi.Struct{
  /// < version for the struct
  @ffi.UnsignedInt()
  external int version;

  /// Type of object IDs to use for this object database, or
  /// 0 for default (currently SHA1).
  @ffi.UnsignedInt()
  external int oid_typeAsInt;

git_oid_t get oid_type => git_oid_t.fromValue(oid_typeAsInt);

}

enum git_odb_backend_loose_flag_t {
  GIT_ODB_BACKEND_LOOSE_FSYNC(1);


  final int value;
  const git_odb_backend_loose_flag_t(this.value);

  static git_odb_backend_loose_flag_t fromValue(int value) => switch (value) {
    1 => GIT_ODB_BACKEND_LOOSE_FSYNC,
    _ => throw ArgumentError('Unknown value for git_odb_backend_loose_flag_t: $value'),
  };

}

/// Options for configuring a loose object backend.
final class git_odb_backend_loose_options extends ffi.Struct{
  /// < version for the struct
  @ffi.UnsignedInt()
  external int version;

  /// A combination of the `git_odb_backend_loose_flag_t` types.
  @ffi.Uint32()
  external int flags;

  /// zlib compression level to use (0-9), where 1 is the fastest
  /// at the expense of larger files, and 9 produces the best
  /// compression at the expense of speed.  0 indicates that no
  /// compression should be performed.  -1 is the default (currently
  /// optimizing for speed).
  @ffi.Int()
  external int compression_level;

  /// Permissions to use creating a directory or 0 for defaults
  @ffi.UnsignedInt()
  external int dir_mode;

  /// Permissions to use creating a file or 0 for defaults
  @ffi.UnsignedInt()
  external int file_mode;

  /// Type of object IDs to use for this object database, or
  /// 0 for default (currently SHA1).
  @ffi.UnsignedInt()
  external int oid_typeAsInt;

git_oid_t get oid_type => git_oid_t.fromValue(oid_typeAsInt);

}

/// Streaming mode
enum git_odb_stream_t {
  GIT_STREAM_RDONLY(2),
  GIT_STREAM_WRONLY(4),
  GIT_STREAM_RW(6);


  final int value;
  const git_odb_stream_t(this.value);

  static git_odb_stream_t fromValue(int value) => switch (value) {
    2 => GIT_STREAM_RDONLY,
    4 => GIT_STREAM_WRONLY,
    6 => GIT_STREAM_RW,
    _ => throw ArgumentError('Unknown value for git_odb_stream_t: $value'),
  };

}

final class git_patch extends ffi.Opaque{
}

final class git_pathspec extends ffi.Opaque{
}

final class git_pathspec_match_list extends ffi.Opaque{
}

/// Options controlling how pathspec match should be executed
enum git_pathspec_flag_t {
  GIT_PATHSPEC_DEFAULT(0),
  /// GIT_PATHSPEC_IGNORE_CASE forces match to ignore case; otherwise
  /// match will use native case sensitivity of platform filesystem
  GIT_PATHSPEC_IGNORE_CASE(1),
  /// GIT_PATHSPEC_USE_CASE forces case sensitive match; otherwise
  /// match will use native case sensitivity of platform filesystem
  GIT_PATHSPEC_USE_CASE(2),
  /// GIT_PATHSPEC_NO_GLOB disables glob patterns and just uses simple
  /// string comparison for matching
  GIT_PATHSPEC_NO_GLOB(4),
  /// GIT_PATHSPEC_NO_MATCH_ERROR means the match functions return error
  /// code GIT_ENOTFOUND if no matches are found; otherwise no matches is
  /// still success (return 0) but `git_pathspec_match_list_entrycount`
  /// will indicate 0 matches.
  GIT_PATHSPEC_NO_MATCH_ERROR(8),
  /// GIT_PATHSPEC_FIND_FAILURES means that the `git_pathspec_match_list`
  /// should track which patterns matched which files so that at the end of
  /// the match we can identify patterns that did not match any files.
  GIT_PATHSPEC_FIND_FAILURES(16),
  /// GIT_PATHSPEC_FAILURES_ONLY means that the `git_pathspec_match_list`
  /// does not need to keep the actual matching filenames.  Use this to
  /// just test if there were any matches at all or in combination with
  /// GIT_PATHSPEC_FIND_FAILURES to validate a pathspec.
  GIT_PATHSPEC_FAILURES_ONLY(32);


  final int value;
  const git_pathspec_flag_t(this.value);

  static git_pathspec_flag_t fromValue(int value) => switch (value) {
    0 => GIT_PATHSPEC_DEFAULT,
    1 => GIT_PATHSPEC_IGNORE_CASE,
    2 => GIT_PATHSPEC_USE_CASE,
    4 => GIT_PATHSPEC_NO_GLOB,
    8 => GIT_PATHSPEC_NO_MATCH_ERROR,
    16 => GIT_PATHSPEC_FIND_FAILURES,
    32 => GIT_PATHSPEC_FAILURES_ONLY,
    _ => throw ArgumentError('Unknown value for git_pathspec_flag_t: $value'),
  };

}

/// Kinds of reset operation
enum git_reset_t {
  /// < Move the head to the given commit
  GIT_RESET_SOFT(1),
  /// < SOFT plus reset index to the commit
  GIT_RESET_MIXED(2),
  /// < MIXED plus changes in working tree discarded
  GIT_RESET_HARD(3);


  final int value;
  const git_reset_t(this.value);

  static git_reset_t fromValue(int value) => switch (value) {
    1 => GIT_RESET_SOFT,
    2 => GIT_RESET_MIXED,
    3 => GIT_RESET_HARD,
    _ => throw ArgumentError('Unknown value for git_reset_t: $value'),
  };

}

/// Flags to specify the sorting which a revwalk should perform.
enum git_sort_t {
  /// Sort the output with the same default method from `git`: reverse
  /// chronological order. This is the default sorting for new walkers.
  GIT_SORT_NONE(0),
  /// Sort the repository contents in topological order (no parents before
  /// all of its children are shown); this sorting mode can be combined
  /// with time sorting to produce `git`'s `--date-order``.
  GIT_SORT_TOPOLOGICAL(1),
  /// Sort the repository contents by commit time;
  /// this sorting mode can be combined with
  /// topological sorting.
  GIT_SORT_TIME(2),
  /// Iterate through the repository contents in reverse
  /// order; this sorting mode can be combined with
  /// any of the above.
  GIT_SORT_REVERSE(4);


  final int value;
  const git_sort_t(this.value);

  static git_sort_t fromValue(int value) => switch (value) {
    0 => GIT_SORT_NONE,
    1 => GIT_SORT_TOPOLOGICAL,
    2 => GIT_SORT_TIME,
    4 => GIT_SORT_REVERSE,
    _ => throw ArgumentError('Unknown value for git_sort_t: $value'),
  };

}


const int GIT_PATH_LIST_SEPARATOR = 58;


const int GIT_PATH_MAX = 4096;


const int GIT_OID_DEFAULT = 1;


const int GIT_OID_SHA1_SIZE = 20;


const int GIT_OID_SHA1_HEXSIZE = 40;


const String GIT_OID_SHA1_HEXZERO = '0000000000000000000000000000000000000000';


const int GIT_OID_MAX_SIZE = 20;


const int GIT_OID_MAX_HEXSIZE = 40;


const int GIT_OID_MINPREFIXLEN = 4;


const int GIT_INDEXER_OPTIONS_VERSION = 1;


const int GIT_ODB_OPTIONS_VERSION = 1;


const int GIT_OBJECT_SIZE_MAX = -1;


const int GIT_COMMIT_CREATE_OPTIONS_VERSION = 1;


const int GIT_REPOSITORY_INIT_OPTIONS_VERSION = 1;


const int GIT_DIFF_OPTIONS_VERSION = 1;


const int GIT_DIFF_HUNK_HEADER_SIZE = 128;


const int GIT_DIFF_FIND_OPTIONS_VERSION = 1;


const int GIT_DIFF_PARSE_OPTIONS_VERSION = 1;


const int GIT_DIFF_PATCHID_OPTIONS_VERSION = 1;


const int GIT_APPLY_OPTIONS_VERSION = 1;


const int GIT_ATTR_CHECK_FILE_THEN_INDEX = 0;


const int GIT_ATTR_CHECK_INDEX_THEN_FILE = 1;


const int GIT_ATTR_CHECK_INDEX_ONLY = 2;


const int GIT_ATTR_CHECK_NO_SYSTEM = 4;


const int GIT_ATTR_CHECK_INCLUDE_HEAD = 8;


const int GIT_ATTR_CHECK_INCLUDE_COMMIT = 16;


const int GIT_ATTR_OPTIONS_VERSION = 1;


const int GIT_BLOB_FILTER_OPTIONS_VERSION = 1;


const int GIT_BLAME_OPTIONS_VERSION = 1;


const int GIT_CHECKOUT_OPTIONS_VERSION = 1;


const int GIT_INDEX_ENTRY_NAMEMASK = 4095;


const int GIT_INDEX_ENTRY_STAGEMASK = 12288;


const int GIT_INDEX_ENTRY_STAGESHIFT = 12;


const int GIT_MERGE_FILE_INPUT_VERSION = 1;


const int GIT_MERGE_CONFLICT_MARKER_SIZE = 7;


const int GIT_MERGE_FILE_OPTIONS_VERSION = 1;


const int GIT_MERGE_OPTIONS_VERSION = 1;


const int GIT_CHERRYPICK_OPTIONS_VERSION = 1;


const String GIT_DEFAULT_PORT = '9418';


const int GIT_PROXY_OPTIONS_VERSION = 1;


const int GIT_REMOTE_CREATE_OPTIONS_VERSION = 1;


const int GIT_REMOTE_CALLBACKS_VERSION = 1;


const int GIT_FETCH_OPTIONS_VERSION = 1;


const int GIT_PUSH_OPTIONS_VERSION = 1;


const int GIT_REMOTE_CONNECT_OPTIONS_VERSION = 1;


const int GIT_CLONE_OPTIONS_VERSION = 1;


const int GIT_DESCRIBE_DEFAULT_MAX_CANDIDATES_TAGS = 10;


const int GIT_DESCRIBE_DEFAULT_ABBREVIATED_SIZE = 7;


const int GIT_DESCRIBE_OPTIONS_VERSION = 1;


const int GIT_DESCRIBE_FORMAT_OPTIONS_VERSION = 1;


const int GIT_FILTER_OPTIONS_VERSION = 1;


const int GIT_REBASE_OPTIONS_VERSION = 1;


const int GIT_REBASE_NO_OPERATION = -1;


const int GIT_REVERT_OPTIONS_VERSION = 1;


const int GIT_STASH_SAVE_OPTIONS_VERSION = 1;


const int GIT_STASH_APPLY_OPTIONS_VERSION = 1;


const int GIT_STATUS_OPT_DEFAULTS = 19;


const int GIT_STATUS_OPTIONS_VERSION = 1;


const int GIT_SUBMODULE_STATUS__IN_FLAGS = 15;


const int GIT_SUBMODULE_STATUS__INDEX_FLAGS = 112;


const int GIT_SUBMODULE_STATUS__WD_FLAGS = 16256;


const int GIT_SUBMODULE_UPDATE_OPTIONS_VERSION = 1;


const int GIT_WORKTREE_ADD_OPTIONS_VERSION = 1;


const int GIT_WORKTREE_PRUNE_OPTIONS_VERSION = 1;


const int GIT_ATTR_UNSPECIFIED_T = 0;


const int GIT_ATTR_TRUE_T = 1;


const int GIT_ATTR_FALSE_T = 2;


const int GIT_ATTR_VALUE_T = 3;


const int GIT_BLOB_FILTER_ATTTRIBUTES_FROM_HEAD = 4;


const int GIT_CVAR_FALSE = 0;


const int GIT_CVAR_TRUE = 1;


const int GIT_CVAR_INT32 = 2;


const int GIT_CVAR_STRING = 3;


const int GIT_DIFF_FORMAT_EMAIL_OPTIONS_VERSION = 1;


const int GIT_ERROR_SHA1 = 33;


const int GIT_IDXENTRY_NAMEMASK = 4095;


const int GIT_IDXENTRY_STAGEMASK = 12288;


const int GIT_IDXENTRY_STAGESHIFT = 12;


const int GIT_IDXENTRY_EXTENDED = 16384;


const int GIT_IDXENTRY_VALID = 32768;


const int GIT_IDXENTRY_INTENT_TO_ADD = 8192;


const int GIT_IDXENTRY_SKIP_WORKTREE = 16384;


const int GIT_IDXENTRY_EXTENDED_FLAGS = 24576;


const int GIT_IDXENTRY_EXTENDED2 = 32768;


const int GIT_IDXENTRY_UPDATE = 1;


const int GIT_IDXENTRY_REMOVE = 2;


const int GIT_IDXENTRY_UPTODATE = 4;


const int GIT_IDXENTRY_ADDED = 8;


const int GIT_IDXENTRY_HASHED = 16;


const int GIT_IDXENTRY_UNHASHED = 32;


const int GIT_IDXENTRY_WT_REMOVE = 64;


const int GIT_IDXENTRY_CONFLICTED = 128;


const int GIT_IDXENTRY_UNPACKED = 256;


const int GIT_IDXENTRY_NEW_SKIP_WORKTREE = 512;


const int GIT_INDEXCAP_IGNORE_CASE = 1;


const int GIT_INDEXCAP_NO_FILEMODE = 2;


const int GIT_INDEXCAP_NO_SYMLINKS = 4;


const int GIT_INDEXCAP_FROM_OWNER = -1;


const int GIT_OBJ_ANY = -2;


const int GIT_OBJ_BAD = -1;


const int GIT_OBJ__EXT1 = 0;


const int GIT_OBJ_COMMIT = 1;


const int GIT_OBJ_TREE = 2;


const int GIT_OBJ_BLOB = 3;


const int GIT_OBJ_TAG = 4;


const int GIT_OBJ__EXT2 = 5;


const int GIT_OBJ_OFS_DELTA = 6;


const int GIT_OBJ_REF_DELTA = 7;


const int GIT_REF_INVALID = 0;


const int GIT_REF_OID = 1;


const int GIT_REF_SYMBOLIC = 2;


const int GIT_REF_LISTALL = 3;


const int GIT_REF_FORMAT_NORMAL = 0;


const int GIT_REF_FORMAT_ALLOW_ONELEVEL = 1;


const int GIT_REF_FORMAT_REFSPEC_PATTERN = 2;


const int GIT_REF_FORMAT_REFSPEC_SHORTHAND = 4;


const int GIT_REVPARSE_SINGLE = 1;


const int GIT_REVPARSE_RANGE = 2;


const int GIT_REVPARSE_MERGE_BASE = 4;


const int GIT_CREDTYPE_USERPASS_PLAINTEXT = 1;


const int GIT_CREDTYPE_SSH_KEY = 2;


const int GIT_CREDTYPE_SSH_CUSTOM = 4;


const int GIT_CREDTYPE_DEFAULT = 8;


const int GIT_CREDTYPE_SSH_INTERACTIVE = 16;


const int GIT_CREDTYPE_USERNAME = 32;


const int GIT_CREDTYPE_SSH_MEMORY = 64;


const int GIT_OID_RAWSZ = 20;


const int GIT_OID_HEXSZ = 40;


const String GIT_OID_HEX_ZERO = '0000000000000000000000000000000000000000';


const int GIT_EMAIL_CREATE_OPTIONS_VERSION = 1;


const int GIT_ODB_BACKEND_PACK_OPTIONS_VERSION = 1;


const int GIT_ODB_BACKEND_LOOSE_OPTIONS_VERSION = 1;

